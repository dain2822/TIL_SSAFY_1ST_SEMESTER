---

## 251001_2

---

### [Objectives_  학습 목표]

- UserChangeForm을 상속받아 회원정보 수정 폼을 만듦
- PasswordChangeForm을 사용하여 비밀번호 변경 기능을 구현함
- update_session_auth_hash 함수로 비밀번호 변경 후 세션을 유지함
- 단방향 해시를 통한 비밀번호 암호화의 필요성을 앎
- 솔트와 키 스트레칭을 통한 암호화 강화 원리를 앎
- Django의 비밀번호 저장 방식(알고리즘, 솔트 등)을 앎
- Django 내장 auth URL을 활용해 비밀번호 초기화를 구현함

---

### [Build_ 이론]

### 회원 정보 수정

: User 객체를 Update하는 과정

: 수정할 대상 User 객체를 가져오고, 입력받은 새로운 정보로 기존 내용 갱신

![image.png](attachment:62a27d30-dc3f-4330-946a-858355d33bb4:image.png)

**회원정보 수정 페이지 작성**

- 회원 정보 수정 경로 url 생성
    
    ![image.png](attachment:cfbbc9fc-8505-4a6f-bc3a-ce36c5d4cbc6:image.png)
    
    - UserChangeForm()
        - 회원정보 수정 시 사용자 입력 데이터를 받는 built-in ModelForm
        - ModelForm이기 때문에, 유효성 검사를 통과한 데이터로 기존 User 객체의 내용을 갱신하고 저장(주로 관리자 페이지에서 사용)
            
            ![image.png](attachment:c95ece50-7c67-4983-8d1a-d607d705bf65:image.png)
            
- 커스텀 유저 모델을 사용하기 위해 Form을 다시 작성
- Custom User model을 사용할 수 있도록 상속 후 일부분만 재작성
    
    ![image.png](attachment:20dc0764-282c-43dd-bf91-8654d53b6f50:image.png)
    
- …/accounts/update/ url로 요청이 들어왔을 때 실행할 update 함수 작성
- 회원정보 수정에 사용할 데이터를 입력 받는 CustomUserChangeForm built-in form 사용
    
    ![image.png](attachment:6bb356ef-3cd8-4b42-b134-d7e713b3d42d:image.png)
    
- 회원가입을 위해 작성한 정보를 서버에 안전하게 전송하기 위해 “POST 방식”을 사용
- 서버로부터 전달받은 CustomUserChangeForm을 화면에 출력
    
    ![image.png](attachment:01245d47-332c-45a1-b1a3-e65854331caf:image.png)
    
- 메인 페이지에서 회원정보 수정 페이지에 접근할 수 있는 태그 생성
    
    ![image.png](attachment:812d3980-a08d-4a7d-b33f-d5efeec7b8d3:image.png)
    

**UserChangeForm 사용 시 문제점**

- User 모델의 모든 정보들(fields)까지 모두 출력됨
- 일반 사용자들이 접근하면 안되는 정보는 출력하지 않아야 함

⇒ CustomUserChangeForm에서 출력 필드 다시 조정

![image.png](attachment:a7173566-00b8-483c-9c9e-e8f69e576a0d:image.png)

**CustomUserChangeForm 출력 필드 재정의**

- User Model의 필드 목록 확인
    
    ![image.png](attachment:206c3dce-02bc-4730-ada0-9b05d91135f5:image.png)
    
- 회원 정보 수정 로직 완성
    
    ![image.png](attachment:d8df2c6b-e9b0-40cf-8fe7-632774207957:image.png)
    

### 비밀번호 변경

: 인증된 사용자의 Session 데이터를 Update하는 과정

: 기존 비밀번호를 통해 사용자를 인증하고, 새로운 비밀번호를 암호화하여 갱신

![image.png](attachment:c90a4528-f388-4119-9659-7d95aa129e2d:image.png)

**비밀번호 변경 페이지 작성**

- django는 비밀번호 변경 페이지를 회원정보 수정 form 하단에서 별도 주소로 안내

![image.png](attachment:93a8f5ae-aa49-4c81-849b-49a58a30e15a:image.png)

- django에서 안내하는 비밀번호 변경 URL에 맞춰서 작성
    
    ![image.png](attachment:931bc71a-db99-4fee-8cec-65518980888b:image.png)
    
- …/accounts/password url로 요청이 들어올 때 실행할 password 함수 작성
- 비밀번호 변경에 사용할 데이터를 입력 받는 PasswordChangeForm built-in form 사용
    
    ![image.png](attachment:ec382e73-d13b-441d-9c7f-2e93d2f5ca43:image.png)
    
    - PasswordChangeForm()
        - 비밀번호 변경 시 사용자 입력 데이터를 받는 built-in Form
        - 일반 ‘Form’이며, 유효성 검사(기존 비밀번호 확인, 새 비밀번호 일치 여부)를 통과한 데이터로 사용자의 비밀번호를 안전하게 암호화하여 갱신하는 역할을 수행
            
            ![image.png](attachment:231212ea-feac-4d0b-b80b-0e4b4987908d:image.png)
            

![image.png](attachment:91a5c98a-601c-44d3-9667-7a449f7e819d:image.png)

![image.png](attachment:589c29f1-6486-45b2-83a9-4a0af2d7e77d:image.png)

### 세션 무효화 방지

**암호 변경 시 세션 무효화**

- 비밀번호가 변경되면 기존 세션과의 회원 인증 정보가 일치하지 않게 되어 버려 로그인 상태가 유지되지 못하고 로그아웃 처리됨
    
    → 비밀번호가 변경되면서 기존 세션과의 회원 인증 정보가 일치하지 않기 때문
    

**암호 변경 시 세션 무효화를 막아주는 함수_ ‘update_session_auth_hash’**

![image.png](attachment:7794d282-0a41-4d9d-bee0-139e89431b5b:image.png)

- 암호가 변경되면 새로운 password의 Session Data로 기존 session을 자동으로 갱신
- update_session_auth_hash를 password 함수에 적용

![image.png](attachment:0a011832-c8a7-46a3-8c1e-a3aa5f9c6681:image.png)

### 비밀번호 암호화

**암호화의 중요성**

: 많은 해킹사태가 발생하고 있고, 데이터가 유출되더라도 그 내용을 알 수 없도록 하는 암호화는 특히 중요함

![image.png](attachment:e8903f74-5a96-4e03-a01d-a320c365b5ec:image.png)

**우리가 사용하는 비밀번호는 어떻게 저장되고 있을까?**

1. 사용자가 입력한 비밀번호 그대로 저장하는 방식 → 보안에 매우 취약하므로 X
    1. 데이터 베이스가 해킹 당하면, 공격자는 아이디와 비밀번호 목록을 그대로 손에 넣게 되고, 이를 통해 직접 로그인하여 개인정보, 금융 정보, 주소록 등 모든 데이터를 유출하거나 서비스를 악용할 수 있음
    2. 악의적인 내부 직원이 데이터 베이스에 접근하여 모든 사용자의 비밀번호를 볼 수 있음
    3. 대부분의 사람들은 여러 서비스에서 동일한 아이디와 비밀번호를 사용하기에 탈취한 정보를 이용해 다른 사이트에 그대로 대입하여 2차 피해를 발생시킴(Credential Stuffing 공격)
2. 일정한 규칙에 따라 비밀번호를 알아볼 수 없는 문자로 ‘인코딩’한 후 저장 → 보안에 매우 취약하므로 X
    1. 데이터 베이스에 알아볼 수 없는 문자로 저장되어 있다고 하더라도, 인코딩은 비밀키 없이도 정해진 규칙에 따라 누구나 원래의 값으로 되돌릴 수 있음
    2. 공격자는 아주 간단한 디코딩 작업만으로 모든 사용자의 실제 비밀번호를 즉시 알아낼 수 있음
    3. 사실상 비밀번호를 평문으로 저장하는 것과 동일한 수준의 위험을 초래함
3. 비밀번호를 복원이 불가능한 고정된 길이의 문자열로 변환 후 저장 → 보안에 필수
    1. 데이터 베이스가 유출되어도 공격자는 복잡하게 얽힌 문자열을 보게 되고, 복원이 불가능하기 때문에 실제 비밀번호를 알 수 없음
    2. 악의적인 내부 직원이 비밀번호를 보더라도 암호화된 비밀번호를 보게 되므로, 실제 비밀번호를 유추할 수 없음
    
    ⇒ 비밀번호를 복원 불가능한 고정된 길이로 바꾸는 과정을 “해시(Hash)”라고 함
    
    - 고정된 길이의 문자열로 변환하는 이유?
        - 보안성: 변환된 문자열의 길이가 다르면, 길이만 보고도 원래 비밀번호의 길이를 유추할 수 있음
        - 일관성: 길이가 동일하기 때문에 저장 공간을 예측하고 설계하기 쉬우며, 검색/비교하는 처리 속도도 일정하게 유지할 수 있음
    
    - 해시(Hash)
        
        : 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것
        
        : 작은 변화에도 해시값이 크게 달라지는 특성으로 인해 변조 여부를 쉽게 확인할 수 있음
        
        : 입력값이 들어오더라도 해시 함수에 의해 다른 값으로 바뀌며, 동일한 값은 항상 동일한 해시값을 생성
        
        ![image.png](attachment:c44110c9-bd1b-486c-a61e-5fbcb3e3ac92:image.png)
        
    - 해시함수(Hash function)
        
        : 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수
        

- Django는 기본적으로 SHA-256 해시 함수를 사용해서 암호화
    - 입력한 비밀번호의 길이와는 상관없이 동일한 길이의 해시 값을 생성
    - 1글자만 다르더라도 전혀 다른 해시 값을 생성
    
    ![image.png](attachment:34f84a14-e7ce-4a5a-ac6c-8aacd63340c9:image.png)
    
- SHA-256_ Secure Hash Algorithm - 256
    
    : 안전한 해시 알고리즘으로, 어떤 데이터를 입력하든 256비트 길이의 결과물을 만들어 냄
    
    : 전 세계적인 표준으로 사용되고 있으며, 비트코인과 같은 블록체인 기술에서도 사용함
    
- 해시 함수를 활용해 단방향 암호화를 하면 더 이상 문제가 없을까?
    - 비밀번호를 해시 값으로 저장하면 공격자가 유출된 데이터베이스를 봐도 원래 비밀번호를 알 수 없어 안전해 보일 수 있음
    - 하지만 공격자들은 해시값을 미리 계산해두는 방식으로 공격을 시도
        
        ⇒ 레이보우 테이블 공격
        

**레인보우 테이블(Rainbow Table)**

- 공격자가 자주 사용되는 비밀번호들(ex: 123456, qwer1234, …)을 미리 수백만, 수십억 개를 해시로 변환해 저장해 둔 거대한 정답지
- 공격 방식
    1. 공격자가 DB를 탈취해 사용자의 비밀번호 해시 값을 얻음
    2. 해시 값을 공격자 자신의 레인보우 테이블에서 검색
    3. 테이블에서 일치되는 값을 찾아내면서, 역방향으로 되돌리지 않고 비밀번호를 알아내는 데 성공
    
    ![image.png](attachment:949fea38-5bab-47c8-9d72-96665b40e605:image.png)
    
- 레인보우 테이블 공격 방어
    - 공격자가 아무리 거대한 레인보우 테이블을 가지고 있더라도, 사용자의 해시 값이 레인보우 테이블에 없도록 해시 값을 만들면 됨
    - 해시 값은 입력값이 단 한 글자만 달라져도 해시값은 완전히 달라지는 눈사태 효과가 있음
    - 결국 같은 비밀번호라도 사용자마다 “임의의 문자열”을 비밀번호에 붙여서 해시 암호화를 진행
        - 임의의 문자열이 추가된 상태로 해시 값을 만들기 때문에 눈사태 효과에 의해 같은 비밀번호도 다른 해시 값이 나옴
    
    → “임의의 문자열” 역할을 하는 것이 바로 “솔트(Salt)”
    

**솔트(Salt)**

: 각 사용자마다 고유하게 생성된 임의의 문자열(솔트)을 비밀번호에 덧붙여서 해시 값을 생성

: 솔트는 해시 값과 함께 데이터 베이스에 저장