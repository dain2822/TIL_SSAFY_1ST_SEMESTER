## 250728

### [Objectives_학습 목표]

- 데이터 구조의 개념과 필요성을 이해하고 설명할 수 있음
- 문자열(String)의 다양한 메서드를 활용해 텍스트 데이터를 처리할 수 있음
- 리스트(List)의 주요 메서드를 사용하여 데이터를 추가, 삭제, 탐색, 정렬할 수 있음
- 객체, 참조, 가변성의 개념을 이해하고 파이썬 변수 할당의 원리를 설명할 수 있음
- 얕은 복사(Shallow Copy)와 깊은 복사(Deep Copy)의 차이를 이해하고 적절하게 활용할 수 있음
- List Comprehension을 사용하여 간결하고 효율적인 리스트 생성을 할 수 있음
- 메서드 체이닝(Method Chaining)의 원리를 이해하고 코드를 더 효율적으로 작성할 수 있음

---

### [Build_이론]

### Data Structure(자료 구조)

: 여러 데이터를 효과적으로 사용, 관리하기 위한 구조(str, list, dict 등)

: 단순히 데이터를 묶는 것을 넘어 프로그램의 성능과 효율성, 유지보수성에 큰 영향을 미치는 핵심적인 개념

![image.png](attachment:7e417188-1ed2-475e-b1ee-6aa43144ef58:image.png)

### 메서드(Method)

: **객체**에 속한 함수 / 객체가 특정 작업을 수행하도록 정의된 함수

*객체: 특정 데이터(정보)와 그 데이터를 처리하는 기능(메서드)을 하나로 묶은 것

: 클래스(Class) 내부에 정의되는 함수

*클래스: 파이썬에서 ‘타입을 표현하는 방법’

![help 함수를 통해 str을 호출해보면 class였다는 것을 확인 가능함](attachment:32feaea2-e24d-4d22-84f6-328ec6a6f2e4:image.png)

help 함수를 통해 str을 호출해보면 class였다는 것을 확인 가능함

→ 메서드는 어딘가(클래스)에 속해 있는 **함수**이며, 각 데이터 타입별로 다양한 **기능**을 가진 **메서드**가 존재

![우리가 만든 **객체(데이터)**에게 원하는 **명령(메서드)**을 내리는 방법](attachment:14e27709-d4b4-4c44-be3c-753f02814c10:image.png)

우리가 만든 **객체(데이터)**에게 원하는 **명령(메서드)**을 내리는 방법

![메서드 호출 예시](attachment:3cdaf307-6651-4edb-886d-2657aedf226f:image.png)

메서드 호출 예시

### 시퀀스 데이터 구조

### 문자열(str)

**문자열 조회 / 탐색 및 검증 메서드**

- `.find(x)` → 문자가 없어도 코드 진행에 지장이 없을 경우 사용
    
    : x의 첫 번째 위치를 반환, 없으면 -1을 반환
    
    ![image.png](attachment:061268a3-ad89-4c25-a031-c9dfe4896861:image.png)
    
- `.index(x)` → 문자가 없으면 코드가 더이상 진행이 되지 않을 경우 사용
    
    : x의 첫 번째 위치를 반환, 없으면 오류 발생
    
    ![image.png](attachment:06cba7c9-d686-4613-b50f-1d0aed63338c:image.png)
    
- `.isupper()` , `.islower()`
    
    : 문자열이 모두 대문자 / 소문자로 이루어져 있는지 확인(T / F)
    
    ![image.png](attachment:f721ef7b-a39c-4fc2-89c3-1b3f56f311c5:image.png)
    
- `.isalpha()`
    
    : 문자열이 알파벳으로만 이루어져 있는지 확인(T / F)
    
    ![image.png](attachment:bdcc094e-3eab-4e7f-8edc-333b0b02a544:image.png)
    

**문자열 조작 메서드(새로운 문자열 반환 → 원 문자열 변경되지 않음!)**

- `.replace(old, new[,count])` (count : 바꾸려는 개수)
    
    : 바꿀 대상 글자를 새로운 글자로 바꿔서 **반환**
    
    ![image.png](attachment:4ce566fd-e78f-4dfd-8240-a2404e3a807e:image.png)
    
- `.strip([chars])`
    
    : 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거
    
    ![image.png](attachment:a966abb3-5fa3-4ce2-8c90-4b36f3af295e:image.png)
    
- `.split(sep = None, maxsplit = 1)`
    
    : sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 **리스트를 반환**
    
    ![image.png](attachment:36cbe14f-de55-49c1-a10c-f3cb5ec09dd4:image.png)
    
- `'separator'.join(iterable)`
    
    : iterable의 문자열을 연결한 **문자열을 반환**
    
    ![image.png](attachment:c0e59b72-cb7d-4d02-8410-b78105bb18a9:image.png)
    
- 기타 문자열 메서드
    
    ![image.png](attachment:b876341c-3e7f-4db2-96e8-35f8d18c9e01:image.png)
    

### 리스트(list)

**리스트 값 추가 및 삭제 메서드(반환값 X)**

- `append(x)`
    
    : 리스트 마지막에 항목 x를 추가
    
    ![image.png](attachment:2e4d1b0d-3c60-4d9a-8f64-0e06f53bfca7:image.png)
    
- `.extend(iterable)`
    
    : 리스트에 다른 반복 가능한 객체의 모든 항목을 추가
    
    ![image.png](attachment:7ce402d6-27d4-49fc-beb3-b916b5155e58:image.png)
    
    → 반복 가능한 객체가 아니면 추가가 불가함
    
    ![image.png](attachment:d774dedc-e707-4474-a5c0-4a7cdd725c4a:image.png)
    
    ![image.png](attachment:bfd5abf2-cb66-4d1a-a3cc-5f01b7872e71:image.png)
    
- `.insert(i, x)`
    
    : 리스트의 지정한 인덱스 i 위치에 항목 x를 삽입
    
    ![image.png](attachment:1f9642d3-0bd1-4d2e-884d-5763a40d2789:image.png)
    
- `.remove(x)`
    
    : 리스트에서 첫 번째로 일치하는 항목을 삭제
    
    ![image.png](attachment:9ed9f3c3-0290-4205-831b-724086c5fe60:image.png)
    
- `.pop(i)`
    
    : 리스트에서 지정한 인덱스의 항목을 제거하고 반환
    
    : 작성하지 않을 경우 **마지막 항목을 제거**
    
    ![image.png](attachment:51c1997b-3c42-4277-9398-bec44ca78549:image.png)
    
- `.clear()`
    
    : 리스트의 모든 항목을 삭제
    
    ![image.png](attachment:bc3b0bf9-12c2-447c-8118-a2930c04b685:image.png)
    

**리스트 탐색 및 정렬 메서드**

- `.index(x)`
    
    : 리스트에서 첫 번째로 일치하는 항목 x의 **인덱스를 반환**
    
    ![image.png](attachment:e57cee00-6d1a-470a-aebb-4063f5649fd6:image.png)
    
- `.count(x)`
    
    : 리스트에서 항목 x의 **개수를 반환**
    
    ![image.png](attachment:ab585dfb-9f71-4563-900a-85a6580bbece:image.png)
    
- `.reverse()`
    
    : 리스트의 순서를 **역순**으로 변경(**정렬X**)
    
    ![image.png](attachment:89c7689f-1713-4154-8401-cfec0a8b80d7:image.png)
    
- `.sort()`
    
    : 원본 리스트를 오름차순으로 정렬
    
    ![image.png](attachment:cd64fba9-efc1-4427-a949-6377d38eaa0e:image.png)
    
- 기타 리스트 메서드
    
    https://docs.python.org/3.11/tutorial/datastructures.html#data-structures
    

---

### 복사

### 객체와 참조

**가변(Mutable) 객체**

: 생성 후 내용을 변경할 수 있는 객체

ex) list, dict, set

![image.png](attachment:e855471e-9138-428f-9533-779d3b504065:image.png)

![image.png](attachment:2b4278ba-7963-4ffa-b74d-c1aa06690d1d:image.png)

**불변(Immutable) 객체**

: 생성 후 내용을 변경할 수 없는 객체

ex) int, float, str, tuple

![image.png](attachment:3fc9588b-70c2-4e62-b34a-1cecd211e92b:image.png)

![image.png](attachment:ead226a6-e987-4ea5-9160-d38801b225f1:image.png)

**변수 할당의 의미**

: 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정

- 변수는 객체의 메모리 주소를 가리키는 Label 역할을 함’
- ‘=’연산자를 사용하여 변수에 값을 할당
    - 할당 시 **새로운 객체**가 생성되거나 **기존 객체에 대한 참조**가 생성됨

새로운 객체 생성 후 참조

: 할당되는 값이 새로운 객체일 경우, 파이썬은 먼저 해당 객체를 메모리에 만들고, 변수가 그 객체를 가리키도록 함

기존 객체에 대한 참조

: 이미 메모리에 존재하는 객체를 변수에 할당하면, 새로운 객체를 만들지 않고 해당 객체에 대한 참조만 생성함

**id() 함수를 사용한 메모리 주소 확인**

: id() 함수를 사용하여 객체의 메모리 주소를 확인 가능

: is 연산자를 통해 두 변수가 같은 객체를 참조하는지 확인 가능

![image.png](attachment:fe6b6ccd-b756-48d4-afcb-b825e4d960f5:image.png)

![image.png](attachment:6a145e29-d29f-4018-bbc1-000f65288e15:image.png)

**가변 / 불변 메모리 관리 방식**

- 가변 객체
    
    : 생성 후에도 그 내용을 수정할 수 있음
    
    : 객체의 내용이 변경되어도 같은 메모리 주소를 유지
    
- 불변 객체
    
    : 생성 후 그 값을 변경할 수 없음
    
    : 새로운 값을 할당하면 새로운 객체가 생성되고, 변수는 새 객체를 참조하게 됨
    

**가변 / 불변 메모리 관리 방식의 이유**

- 성능 최적화
    - 불변 객체 : 변경이 불가능하므로, **여러 변수가 동일한 객체를 안전하게 공유**할 수 있음
    - 가변 객체 : 내용 수정이 빈번할 때, 새로운 객체를 생성하는 대신 **기존 객체를 직접 수정**할 수 있음
        
        → 이로 인해 객체 생성 및 삭제에 드는 비용을 절감하여 성능을 향상시킴
        
- 메모리 효율성
    - 불변 객체 : 동일한 값을 가진 여러 변수가 같은 객체를 참조할 수 있어 **메모리 사용을 최소화**할 수 있음
    - 가변 객체 : 크기가 큰 데이터를 효율적으로 수정할 수 있음

---

### 얕은 복사(Shallow Copy)

: 객체의 **최상위 요소**만 새로운 메모리에 복사하는 방법

: 내부에 **중첩된 객체**가 있다면 그 객체의 **참조만** 복사됨

- 얕은 복사 후 중첩된 리스트나 딕셔너리 같은 **가변 객체**를 수정하면, 원본 객체와 복사본 객체가 함께 변경됨
    
    → 복사본의 중첩 객체가 여전히 원본 객체의 **중첩 객체를 참조**하고 있기 때문!
    

**얕은 복사 예시_ 1차원 리스트에서의 얕은 복사**

1. 리스트 슬라이싱

![image.png](attachment:c1a7442f-4f55-4f4e-8397-9b6ff57612f6:image.png)

: 리스트 슬라이싱([:])은 **원본 리스트와 동일한 내용의** **새로운 리스트**를 만듦

→ 새로운 리스트에 복사되는 것은 요소 자체의 값이 아니라 **해당 요소들이 참조하는 주소**임

![image.png](attachment:0b88bfa0-af36-4b1b-aae5-89f10834ecd9:image.png)

1. copy() 메서드

![image.png](attachment:681c54b7-3c7e-41e0-b1a8-eda1c69f266d:image.png)

: 원본 리스트와 **동일한 내용을 가진 새로운 리스트 객체**를 반환

→ 리스트 슬라이싱과 마찬가지로 복사된 새 리스트의 요소들은 **원본 리스트의 요소들과 동일한 객체를 참조**함

![image.png](attachment:151d6243-d025-4c75-9fa4-e99bf6850a33:image.png)

1. list() 함수

![image.png](attachment:45797ce1-defb-4f0c-abf1-15221e57a8fe:image.png)

![image.png](attachment:2fda1164-b58e-4c7f-bf4c-3b5fca674fd7:image.png)

**얕은 복사의 한계**

- 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우

![image.png](attachment:3d5b5035-e10b-40b2-adec-8b92e6caa11e:image.png)

![image.png](attachment:7a6df26f-c6bb-4f4f-a60f-7d4862e6e427:image.png)

→ a와 b의 주소는 다르지만 내부 객체의 주소는 같기 때문에 함께 변경됨

: 1차원 리스트 → 얕은 복사로 충분히 독립적인 복사본을 만들 수 있음

: 다차원 리스트 → 최상위 리스트만 복사되고, 내부 리스트는 여전히 원본과 같은 객체를 참조

---

### 깊은 복사(Deep Copy)

: 객체의 모든 수준의 요소를 새로운 메모리에 복사하는 방법

: **중첩된 객체까지** 모두 새로운 객체로 생성됨

- 완전한 독립성 보장
    - 깊은 복사는 원본 객체와 복사본이 **완전히 독립적**임을 보장함
    - 복사본의 어떤 수준에 있는 중첩된 내용을 변경하더라도 **원본 객체**에는 **절대 영향을 주지 않음**

→ copy 모듈에서 제공하는 **deepcopy()** 함수를 사용

![image.png](attachment:1f3b5f01-88ee-4ec3-8c5f-c7a4490cfb58:image.png)

**깊은 복사 예시**

![image.png](attachment:1f7574f0-f487-4eb6-9b71-3b9486b23427:image.png)

- 중첩된 객체에서의 깊은 복사

![image.png](attachment:1c7b6eed-0018-41a8-84f8-1baf9cfab08e:image.png)

![image.png](attachment:0838b4f6-8bb6-46e2-8396-11f5b6b14dc3:image.png)

---

### 참고

### List Comprehension

: 간결하고 효율적인 리스트 생성 방법

![image.png](attachment:0f1f471f-1a1a-44aa-9fc3-e396ca47bc6b:image.png)

![image.png](attachment:141cb9dc-8ea7-4e96-bcd3-5d81b95b5b62:image.png)

→ 표현식은 결과 리스트에 추가될 값, 변수는 순회 중인 현재 요소, 순회 가능한 객체는 반복할 데이터, 조건식은 필터링 조건

→ if 조건식 부분은 선택 사항이며, 조건을 명시하지 않으면 모든 요소에 대해 표현식이 적용됨

![image.png](attachment:e086f32e-e084-4286-8c57-ff73a68b1623:image.png)

**List Comprehension 활용 예시**_ 2차원 배열 생성 시(인접행렬 생성)

![image.png](attachment:74a790b5-c652-440d-82c0-525bde654d43:image.png)

![image.png](attachment:f4db7bcd-62b5-4319-8f6e-baf1b6baeffe:image.png)

---

### 메서드 체이닝(Method Chaining)

: 여러 메서드를 연속해서 호출하는 방식

**문자열에서의 메서드 체이닝 예시**

![image.png](attachment:c425ff95-7ed8-4011-a85c-2863b486b4fd:image.png)

1. text.swapcase() : 대소문자를 반전시킴
    
    ‘hello, woRld!’ → ‘HEllO, WOrLD!’
    
2. .replace(’l’, ‘z’) : 소문자 ‘l’을 ‘z’로 교체
    
    ‘HEllO, WOrLD!’ → ‘HEzzO, WOrLD!’
    

![image.png](attachment:006a24b9-6960-483c-ad54-ab0c713504ba:image.png)

- copy()로 리스트를 복사한 후, sorted() 함수로 정렬

![image.png](attachment:84eb0bc8-7910-4ce4-8930-f00799a484f6:image.png)

**주의 사항**

- 모든 메서드가 체이닝을 지원하는 것은 아님
    - 메서드가 객체를 반환할 때만 체이닝이 가능
- None을 반환하는 메서드는 메서드 체이닝이 불가능
    - ex) 리스트의 append(), sort()
- 메서드 체이닝을 사용할 때는 각 메서드의 반환 값을 잘 이해하고 있어야 함

---

### 문자 유형 판별 메서드

- isdecimal()
    
    : 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
    
- isdigit()
    
    : isdecimal()과 비슷하지만, 유니코드 숫자도 인식(’①’도 숫자로 인식)
    
- isnumeric()
    
    : isdigit()과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식(분수, 지수, 루트 기호도 숫자로 인식)
    
    ![image.png](attachment:4d1044af-fd21-4e87-9d65-af80e2b73828:image.png)
    

---

### [Review_활동 정리]

- 자료 구조(Data Structure)
    
    : 데이터를 효율적으로 저장, 관리하기 위한 형식
    
    ex) 리스트, 문자열 등
    
- 시퀀스(Sequence)
    
    : 순서를 유지하고 인덱스로 요소 접근 가능
    
    ex) “abc”[1] → ‘b’
    
- 문자열(str)
    
    : 불변(Immutable) 문자 시퀀스
    
    ex) “Hello”.upper() → “HELLO”
    
- 리스트(list)
    
    : 순서가 있고 가변(Mutable)인 시퀀스
    
    ex) lst = [1, 2]
    
    lst.append(3) → [1, 2, 3]
    
- 불변 객체(Immutable)
    
    : 내부 값 변경 불가, 연산 시 새 객체 생성
    
    ex) id(”a” + “b”) ≠ id(”ab”)
    
- 가변 객체(Mutable)
    
    : 내부 값 직접 변경, 참조는 유지
    
    ex) id(lst)는 append 전후 동일
    
- 얕은 복사(Shallow Copy)
    
    : 최상위만 새 메모리, 내부 객체는 참조 공유
    
    ex) lst2 = lst[:]
    
- 깊은 복사(Deep Copy)
    
    : 모든 중첩 레벨까지 새 객체 생성
    
    ex) copy.deepcopy(obj)
    
- 리스트 컴프리헨션
    
    : [expr for x in iterable if  조건] 형식으로 간결, 효율적 리스트 생성
    
    ex) [x**2 for x in range(5) if x%2]
    
- 메서드 체이닝
    
    : 객체를 반환하는 메서드를 연속 호출
    
    ex) “Hello”.swapcase().replace(’e’, ‘E’)
    

---

- 자료 구조(Data Structure)란?
    - 데이터를 효율적으로 저장, 관리하기 위한 형식
    - 올바른 구조 선택이 실행 시간, 메모리 사용을 좌우
- 시퀀스 데이터 구조
    - 문자열(str) : 불변(Immutable) 문자 시퀀스
    - 리스트(list) : 순서가 있고 가변(Mutable)인 시퀀스
- 객체, 참조, 가변성
    
    : 변수는 객체의 참조를 저장
    
    : 가변 객체는 원본이 직접 바뀌고, 불변 객체는 새 객체가 생성
    
    : 동일 객체 여부는 id() 또는 is로 확인
    
- 문자열 메서드 분류
    - 탐색, 검증 : find(), index(), isupper(), islower()
    - 변환 : replace(), strip(), split(), ‘*’.join(), capitalize(), title(), upper(), lower(), swapcase()
- 리스트 메서드 분류
    - 추가, 확장 : append(), extend(), insert()
    - 삭제 : remove(), pop(), clear()
    - 탐색, 정렬 : index(), count(), reverse(), sort()
- 메서드 사용 팁
    - extend()는 리스트를 이어서 펼치고, append()는 전체를 한 요소로 추가
    - list.sort()는 제자리 정렬(반환값 None)이므로 체이닝 불가
- 얕은 복사(Shallow Copy)
    - 슬라이싱 lst[:], list(), lst,.copy → 최상위만 새 메모리
    - 중첩 구조의 내부 객체는 참조만 복사
- 깊은 복사(Deep Copy)
    - import copy → copy.deepcopy(obj)
    - 모든 중첩 수준까지 새로운 객체 생성
- 리스트 컴프리헨션
    - [exp for x in iterable if 조건]으로 간격, 효율적 리스트 생성
    - 읽기 어려울 정도로 복잡해지지 않도록 주의
- 메서드 체이닝
    - 객체를 반환하는 메서드만 연속 호출 가능
        - ex) “Hello”.swapcase().replace(’e’, ‘E’)
        - None을 반환하는 메서드(list.sort() 등)는 체이닝에 포함하면 안