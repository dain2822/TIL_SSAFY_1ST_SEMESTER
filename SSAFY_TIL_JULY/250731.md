---

## 250731

---

### [Objectives_ 학습 목표]

- 클래스 상속의 개념과 장점을 설명할 수 있음
- 자식 클래스에서 부모 클래스의 속성과 메서드를 재사용할 수 있음
- 메서드 오버라이딩을 통해 부모의 기능을 변경하거나 확장할 수 있음
- 다중 상속 시 메서드 탐색 순서(MRO)를 이해하고 설명할 수 있음
- super()를 사용하여 부모 클래스의 메서드를 호출할 수 있음
- try, except, else, finally 구문을 사용하여 예외 상황을 안전하게 처리할 수 있음

---

### [Build_ 이론]

### 상속_Inheritance

: 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려받는 것

→ 부모 클래스와 자식 클래스 간의 상하 관계가 형성되고, 위쪽에 있는 부모 클래스가 본인의 속성과 메서드를 아래쪽에 있는 자식에게 넘겨주는 것

→ 속성과 메서드를 자식에게 넘겨주는 과정을 상속 과정이라 함

**상속이 필요한 이유**

- 코드 재사용
    - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
    - 기존 클래스를 수정하지 않고도 기능을 확장할 수 있음
- 계층 구조
    - 상속을 통해 클래스들 간의 계층 구조를 형성할 수 있음
    - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음
- 유지 보수의 용이성
    - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
    - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화할 수 있음

**클래스의 상속 개념 다이어그램 예시**

![image.png](attachment:2666e4c2-8446-47fd-a5d9-d2fa70629a94:image.png)

→ 게임에 직업군(마법사, 전사)이 있음. 마법사, 전사의 공통점은 게임 캐릭터라는 점임. 또한 마법사와 전사, 모두 돈과 레벨을 가지고 있음. 전사, 마법사 모두 공격, 수비, 이동 능력이 있음

⇒ 공통적인 속성은 상위 캐릭터에서 구현하고, 각 캐릭터별 특징에 따라 추가 속성을 구현함

![image.png](attachment:89ce619f-e36a-454f-9bda-f8f25e397c56:image.png)

![image.png](attachment:f4d3ba01-1fb4-4284-865e-d5c6510ccc6d:image.png)

→ 자식 클래스를 정의할 때 반드시 상속하려는 부모 클래스 이름을 함께 선언해야 함

**상속 없이 구현하는 경우**

![image.png](attachment:6ebab818-7dc6-4399-bb64-227d3083439f:image.png)

→ 상속 없이 구현하는 경우 학생 / 교수 정보를 별도로 표현하기 어려움

→ Person class만을 사용하는 경우 학생과 교수가 가지는 각각의 고유 속성을 표현하기 어려움

→ 나이와 이름만으로 직업 정보를 나타낼 수 없음

![image.png](attachment:96e01495-fa7e-451d-8eca-fb0edd6b31e6:image.png)

→ 상속 없이 구현하는 경우 교수 / 학생 클래스로 각각 선언하여 구현

→ 클래스를 각각 분리했지만 메서드가 중복으로 정의될 수 있음

⇒ 중복되고 있는 공통 속성인 name, age와 메서드 talk를 부모 클래스에서 한 번만 정의하고, 필요한 클래스들이 부모 클래스를 물려받아 사용할 수 있음

**상속을 통한 계층 구조 변경**

![image.png](attachment:f2dab37a-1ef4-4a98-93a8-c5f1538f894b:image.png)

### 메서드 오버라이딩_ Method Overriding

: 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하는 것

→ 자식 클래스에서 메서드를 다시 정의하면, 부모 클래스의 메서드 대신 자식 클래스의 메서드가 실행됨

→ 오버라이딩은 동일한 이름과 매개변수를 사용하지만, 내부 동작을 원하는 대로 바꿀 수 있게 해줌

⇒ 부모 클래스의 기능을 유지하면서도 일부 동작을 맞춤형으로 바꾸고 싶을 때 유용함

**메서드 오버라이딩 예시**

![image.png](attachment:bf43f909-4231-4a60-84c7-89d83c5b9e96:image.png)

→ 자식 클래스가 부모 클래스의 메서드를 덮어써서 새로운 동작을 구현할 수 있음

→ Animal class를 상속받은 Dog 클래스에서 eat 메서드를 다시 정의하는 것

[참고] 오버로딩(Overloading)

: 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것(파이썬은 미지원)

: 파이썬은 실제로 하나의 메서드만 인식하며, 인자의 형태가 다르다는 이유로 메서드를 여러 개 구분하여 불러주지 않음

![image.png](attachment:97dabf8e-d224-41fd-aa6c-641b642099b1:image.png)

### 다중 상속

![image.png](attachment:95d9a22a-1f1f-4b53-b4b0-b91f5e922bf2:image.png)

: 둘 이상의 상위 클래스로부터 여러 행동이나 특징을 상속받을 수 있음

: 상속받은 모든 클래스의 요소를 활용 가능함

: 중복된 속성이나 메서드가 있는 경우 상속 순서에 의해 결정 됨

**다중 상속 예시**

![image.png](attachment:d81a3375-f0ab-4134-a931-f5d9af692d96:image.png)

→ 상속 작성 시 먼저 위치한 것부터 탐색

**다이아몬드 문제(The diamond problem)**

![image.png](attachment:8494a393-b0db-445a-b05f-ffcf8dbe4f0b:image.png)

: 두 클래스 B와 C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함

: B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우라면, D는 B의 메서드 중 어떤 버전을 상속하는가? 아니면 C의 메서드 버전을 상속하는 가?

→ MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성

→ 부모 클래스로부터 상속된 속성을 정해진 내부 알고리즘에 따라 검색

→ 순서는 기본적으로 왼쪽에서 오른쪽으로 진행되며, 계층 구조에서 중복되는 클래스는 한 번만 확인함

![image.png](attachment:8517ce1f-e905-4682-bff0-38604745c7c7:image.png)

⇒ 속성이 D에서 발견되지 않으면, B에서 찾고, 거기에서도 발견되지 않으면, C에서 찾는 방법으로 진행

**MRO(Method Resolution Order)**

: 파이썬이 메서드를 찾는 순서에 대한 규칙 / 메서드 결정 순서

: MRO는 다중 상속에서 어떤 부모 클래스의 메서드를 먼저 사용할 지 순서를 정의함

: 파이썬은 미리 정해진 MRO를 통해 다중 상속 환경에서도 예측 가능한 방식으로 메서드 탐색이 이루어질 수 있도록 함

### super() 메서드

: 메서드 해석 순서(MRO)에 따라 현재 클래스의 부모(상위) 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수

: 직접 부모 클래스 이름을 적지 않아도 MRO에 따라 자동으로 올바른 메서드를 찾아 실행할 수 있음

: 다중 상속에서 super()를 호출하면 상속 순서에 맞춰 여러 부모 클래스의 메서드를 순차적으로 실행할 수 있음

: 생성자나 오버라이딩된 메서드에서 super()를 호출하면 부모 클래스의 초기화나 로직을 그대로 활용 가능함

**super()의 특징**

: 단순히 “부모 클래스의 메서드를 호출”하기 위한 용도 뿐 아니라, **다중 상속(Multiple Inheritance)이 있을 때도 올바른 순서(MRO)에 따라 상위 클래스의 메서드를 찾아 실행하기 위해 super()를 사용**

**super() 사용 예시_단일 상속**

![image.png](attachment:ca6b6f7a-df91-4dfe-818a-6b545ffaa73a:image.png)

→ 명시적으로 부모 클래스 이름을 적지 않아도 부모 메서드를 안전하게 호출할 수 있음

![image.png](attachment:3a225314-a307-4396-9b75-d297c44ebfc9:image.png)

→ Student의 생성자에서 super().__init__()를 호출하면, Person의 __init__() 메서드가 호출되어 name, age, number, email 속성을 초기화한 뒤 Student 고유의 student_id 속성을 추가

→ Person 클래스를 직접 명시하지 않고 super()를 사용하므로, 나중에 클래스 이름이 바뀌거나 상속 구조가 변경되어도 super() 호출 부분을 그대로 사용할 수 있어 유지 보수성이 향상됨

**단일 상속 구조에서의 super 함수**

: 부모 클래스의 생성자(또는 메서드)를 호출하기 위해 사용

: 명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지, 관리하기 쉽게 만들 수 있음

: 클래스 이름이 변경되거나 부모 클래스가 교체되어도 super()를 사용하면 코드 수정이 더 적게 필요

- 단일 상속에서는 super()를 사용해 부모 클래스를 직접 지정하지 않고 메서드를 호출함
    
    → 나중에 부모 클래스 이름이 바뀌거나 계층이 수정되어도 코드 유지 관리가 훨씬 수월해짐
    

**super() 사용 예시_다중 상속**

![image.png](attachment:cbd76cc3-4fe0-4205-82ae-36bd81cf6504:image.png)

![image.png](attachment:be681ff9-2e2e-47e2-bd9b-06963cf6e843:image.png)

→ Child 클래스는 ParentA, ParentB를 순서대로 상속

→ child = Child()를 실행하면 Child의 init 메서드에서 super().__init__()를 호출

→ MRO에 의해 Child → ParentA → ParentB 순으로 메서드를 찾는데, 이 상황에서 super().__init__()는 바로 다음 순서에 할당하는 ParentA의 init을 호출

→ ParentA의 init이 실행되어 value_a가 초기화 / ParentB의 init은 이 예제에서는 자동으로 호출되지 않음

→ 만약 ParentA의 init 안에서도 super().__init__()를 호출한다면, 그 다음으로 ParentB의 init이 실행되어 value_b도 초기화할 수 있음

→ child.show_value()를 호출하면 Child의 show_value에서 super().show_vaule()를 호출

→ show_value() 메서드를 찾기 위해 Child → ParentA → ParentB 순서로 탐색하므로, 첫 번째로 ParentA의 show_value()가 실행됨

**다중 상속 구조에서의 super 함수**

: MRO(메서드 해석 순서)에 따라 각 클래스의 메서드를 찾아가기 때문에 단순히 직계 부모만이 아니라 다중 상속 관계에서도 적절한 상위 클래싀의 메서드를 안전하게 호출할 수 있음

→ 복잡한 상속 구조에서도 코드를 유연하고 깔끔하게 유지할 수 있음

- super()를 사용할 때는 MRO를 잘 이해하고 있어야 함
- ClassName.__mro__ 또는 ClassName.mro()를 확인해 MRO 순서를 파악한 뒤 적절힌 활용하는 연습을 하면, 보다 복잡한 상속 구조에서도 코드를 잘 관리할 수 있음

**mro(), __mro__ 사용 예시**

![image.png](attachment:25de778d-a4c6-44bc-ba86-714dfd59150e:23982723-3fdf-46f6-90ee-531e4c72a1d9.png)

**MRO가 필요한 이유**

: 부모 클래스들이 여러 번 액세스 되지 않도록 각 클래스에서 지정된 왼쪽→오른쪽 순서를 보존하고 각 부모를 한 번만 호출하여 부모들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조를 형성

→ 프로그래밍 언어에서 신뢰성 있고 확장성 있는 클래스 설계 가능

→ 클래스 간의 메서드 호출 순서가 예측 가능하게 유지되며, 코드 재사용성과 유지보수성 향상

---

### 버그_ Bug

: 소프트웨어에서 발생하는 오류 또는 결함

: 프로그램의 예상된 동작과 실제 동작 사이의 불일치

![image.png](attachment:8698ab76-f96a-49a4-bb2b-e4d2611c5eba:image.png)

![image.png](attachment:206f102d-ff72-4a21-b953-a658d9c6073a:image.png)

### 디버깅_ Debugging

: 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정

: 프로그램의 오작동 원인을 식별하여 수정하는 작업

: 코드 실행 과정에서 변수 값이나 흐름을 점검하며 문제의 정확한 위치와 원인을 찾아내는 과정

: 효과적인 디버깅을 위해 단계별로 코드를 실행하거나 로그를 출력해 프로그램 상태를 확인함

**디버깅 방법**

1. print 함수 활용
    
    : 특정 함수 결과, 반복 / 조건 결과 등 나눠서 생각, 코드를 bisection으로 나눠 생각
    
2. 개발환경(text editor, IDE) 등에서 제공하는 기능 활용
    
    : breakpoint, 변수 조회 등
    
3. Python tutor 활용(단순 파이썬 코드인 경우)
4. 뇌 컴파일, 눈 디버깅 등

### 에러_ Error

: 프로그램 실행 중에 발생하는 예외 상황

: 프로그램을 실행할 때 예상치 못한 문제가 발생하면 오류가 생김

: 예를 들어 존재하지 않는 파일을 읽으려 하거나 0으로 나누면 오류가 발생

→ 이런 상황을 처리하지 않으면 프로그램이 중단됨

![image.png](attachment:b9ee646c-72af-432f-9860-0a6ccc1e35f6:image.png)

**문법 에러 예시**

- Invalid syntax(문법 오류)

![image.png](attachment:6534e5a0-12f8-4048-8eb9-8a41f582379d:image.png)

- assign to literal(잘못된 할당)

![image.png](attachment:fc96c8c1-ba78-46c2-8c4d-0aef97ebbc34:image.png)

- Unterminated string literal
    
    : 보통 문자열이나 문장을 제대로 닫지 않은 상태에서 줄 끝에 다다랐을 때 발생 
    

![image.png](attachment:04c1a53a-d18f-4027-910f-58bad098b909:image.png)

### 예외_ Exception

: 프로그램 실행 중에 감지되는 에러

: 예외는 프로그램이 잘못된 동작을 시도할 때 자동으로 감지됨

ex) 리스트에 없는 값을 꺼내려 하면 예외 발생

: 이런 상황을 처리하지 않으면 프로그램은 즉시 종료됨

### 내장 예외_ Built-in Exception

: 예외 상황을 나타내는 예외 클래스들

: 내장 예외는 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용함

ex) ZeroDivisionError는 0으로 나눌 때, FileNotFoundError는 없는 파일을 열 때 발생

- ZeroDivisionError
    
    : 나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생
    
    ![image.png](attachment:09178bf3-e09c-43d3-9153-c884adba8b8f:image.png)
    
- NameError
    
    : 지역 또는 전역 이름을 찾을 수 없을 때 발생
    
    ![image.png](attachment:38a180fa-7437-4a37-9c7b-9014c0411cd1:image.png)
    
- TypeError
    
    : 타입 불일치
    
    ![image.png](attachment:23b856ae-d01b-41df-9580-2c7ba5c348e4:image.png)
    
- TypeError
    
    : 인자 누락
    
    ![image.png](attachment:2e23dfa8-f0db-4b0d-9fbf-b092ba68e722:image.png)
    
- TypeError
    
    : 인자 초과
    
    ![image.png](attachment:891515eb-9ea4-4e80-84ac-49fc4bad2ccb:image.png)
    
- TypeError
    
    : 인자 타입 불일치
    
    ![image.png](attachment:2c5e29c2-b47e-44ea-bb4b-e21a6dac355c:image.png)
    
- ValueError
    
    : 연산이나 함수에 문제가 없지만 부적절한 값을 가진 인자를 받았고, 상황이 IndexError처럼 더 구체적인 예외로 설명되지 않는 경우 발생
    
    ![image.png](attachment:e0923586-7c2d-4eb0-8400-9377c35de933:image.png)
    
- IndexError
    
    : 시퀀스 인덱스가 범위를 벗어남
    
    ![image.png](attachment:ea7ddc4e-5dd9-43ca-8a92-9e73d688d9b6:image.png)
    
- KeyError
    
    : 딕셔너리에 해당 키가 존재하지 않는 경우
    
    ![image.png](attachment:1908ec7b-8f54-4f1c-8ef2-2cc0c7010c7d:image.png)
    
- ModuleNotFoundError
    
    : 모듈을 찾을 수 없을 때
    
    ![image.png](attachment:ca02c687-dafe-415a-ae23-3828187c667e:image.png)
    
- ImportError
    
    : import하려는 이름을 찾을 수 없을 때
    
    ![image.png](attachment:e47a3048-a8e5-4051-94d7-655bf708b86d:image.png)
    
- KeyboardInterrupt
    
    : 사용자가 Ctl-C 또는 Delete를 누를 때 발생
    
    ![image.png](attachment:eac6cddd-bc1d-4e00-9035-ec31ef038e8a:image.png)
    
- IndentationError
    
    : 잘못된 들여쓰기와 관련된 문법 오류
    
    ![image.png](attachment:9cd01b48-bd84-4239-93a2-e1b08f90cd40:image.png)
    

### 예외 처리_ Exception Handling

: 예외가 발생했을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게  처리할 수 있도록 하는 방법

: 예외 처리를 통해 오류가 발생해도 프로그램의 흐름을 안전하게 이어갈 수 있음

: Python에서는 try, except 구문을 사용해 특정 예외를 잡아내고 원하는 동작을 수행할 수 있음

: 예외 처리를 구현하면 프로그램 사용자에게 오류 메시지를 보여주거나 대체 로직을 실행할 수 있음

- try
    
    : 예외가 발생할 수 있는 코드 작성
    
- except
    
    : 예외가 발생했을 때 실행할 코드 작성
    
- else
    
    : 예외가 발생하지 않았을 때 실행할 코드 작성
    
- finally
    
    : 예외 발생 여부와 상관없이 항상 실행할 코드 작성
    

![image.png](attachment:9497525b-3664-4e3d-be58-16da528e066b:image.png)

**try-except 구조**

- try:
    
    #예외가 발생할 수 있는 코드
    
- except 예외:
    
    #예외 처리 코드
    

: try 블록 안에는 예외가 발생할 수 있는 코드를 작성

: except 블록 안에는 예외가 발생했을 때 처리할 코드를 작성함

: 예외가 발생하면 프로그램 흐름은 try 블록을 빠져나와 해당 예외에 대응하는 except 블록으로 이동

![image.png](attachment:030bddd7-e68f-4458-ad55-dbda1cee445c:image.png)

**복수 예외 처리**

![image.png](attachment:0d04fde0-363b-4feb-af01-34409e4bdf87:image.png)

**else & finally**

: else 블록은 예외가 발생하지 않았을 때 추가 작업을 진행

: finally 블록은 예외 발생 여부와 상관없이 항상 실행할 코드를 작성

![image.png](attachment:30b99215-9fb0-4bea-a52b-573847c47c1a:image.png)

---

### 참고

**내장 예외의 상속 계층 구조 주의**

![image.png](attachment:d89b9ba1-b9c7-4888-adbd-a64013e1f80b:image.png)

→ 코드는 2번째 except 절에 이후로 도달하지 못함

→ except Exception이 모든 예외를 먼저 가로채기 때문에 그 아래에 있는 ZeroDivisionError 전용 처리 코드는 실행이 되지 않음

→ 범용적인 예외 처리(Exception)는 마지막에 두어야 함

![image.png](attachment:1b6b5845-dde4-4400-b577-e0dae59b6df8:image.png)

→ 내장 예외 클래스는 상속 계층 구조를 가지기 때문에 except절로 분기 시 반드시 하위 클래스를 먼저 확인할 수 있도록 작성해야 함

→ 가장 구체적인 예외부터 처리하고, 마지막에 범용 예외를 처리하도록 순서를 배치

**as 키워드**

- 예외 객체: 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
- except 블록에서 예외 객체를 받아 상세한 예외 정보를 활용 가능

![image.png](attachment:c50d2d0f-b22a-4652-ad6b-35127746c812:image.png)

→ 빈 리스트에서 잘못된 인덱스를 참조할 때 IndexError 예외가 발생하는 예시

→ error 변수에 담긴 예외 메시지를 출력하면 구체적인 오류 내용을 쉽게 확인할 수 있음

**try-except와 if-else**

: try-except와 if-else를 함께 사용할 수 있음

![image.png](attachment:3d72b405-44ee-45b9-85b1-525366476c37:image.png)

→ 입력값이 정수가 아니면 ValueError 예외가 발생해 오류 메시지를 출력함

→ 정상 입력이면 음수인지 양수인지 구분해 각각 다른 문장을 출력함

**EAFP & LBYL**

- EAFP _ Easier to Ask for Forgiveness than Permission
    
    : 예외 처리를 중심으로 코드를 작성하는 접근 방식(try-except)
    
    ![image.png](attachment:5de9bb88-69d0-4a34-9a10-9879e06c1578:image.png)
    
- LBYL_ Look Before You Leap
    
    : 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)
    
    ![image.png](attachment:58ff3b8f-51da-4020-bef3-b57bdabbdb97:image.png)
    

![EAFP와 LBYL 접근 방식 비교](attachment:e00595ff-0636-42e1-a1fe-007537561f47:image.png)

EAFP와 LBYL 접근 방식 비교

**클래스의 의미와 활용**

: 프로그램 규모가 커지면 서로 관련 있는 정보와 기능을 따로따로 관리하기가 점점 어려워짐

: 클래스를 사용하면 관련된 데이터와 기능을 ‘한 덩어리’로 묶어 구조를 명확히 할 수 있음

→ 작성한 코드가 훨씬 깔끔해지고, 나중에 수정하거나 기능을 추가할 때 더 쉽고 안전해짐

ex) 도서 관리 프로그램

- 책을 나타내는 클래스를 만들고(title, author, price 같은 속성과 print_info() 같은 기능), 이 클래스를 이용해 여러 권의 책 객체를 다룰 수 있음
- 책 관련 코드와 로직이 한 곳에 모여 있어 재사용과 관리가 편해짐

---

### [Review_활동 정리]

![image.png](attachment:c54748ee-d3d2-4556-b3c3-7240e68771c5:image.png)

![image.png](attachment:a5a707b4-6e59-4b41-be6a-65799258235f:image.png)

![image.png](attachment:4ae9b28d-f974-44a3-9e7d-d0a1e598bfbd:image.png)