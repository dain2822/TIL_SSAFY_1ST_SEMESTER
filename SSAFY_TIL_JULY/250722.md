## 250722

---

### [Objectives_학습 목표]

- 여러 개의 값을 순서대로 저장하는 시퀀스 타입의 특징과 차이를 이해하고 활용할 수 있음
- Key-Value 쌍으로 데이터를 저장하는 딕셔너리와 중복 없는 데이터 묶음인 세트를 활용할 수 있음
- Boolean과 None 타입의 의미와 쓰임새를 이해함
- 암시적 / 명시적 형 변환의 개념을 이해하고 원하는 데이터 타입으로 값을 변환할 수 있음
- 산술, 비교, 논리 등 다양한 연산자를 사용하여 복합적인 데이터 처리 및 조건 검사를 수행할 수 있음
- 논리 연산의 효율을 높이는 단축 평가의 동작 원리를 설명할 수 있음

---

### [Build_이론]

### 리스트(List)

: 여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형

: 대괄호([]) 안에 값들을 쉼표(,)로 구분하여 만듦

: 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음

: 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음

![image.png](attachment:9b067e88-ccef-4f14-9a8f-c2ad353c32a4:image.png)

**리스트의 시퀀스 특징**

: 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능함

![image.png](attachment:4420cd10-14bc-4ce0-830d-c925fa4c22ed:image.png)

**중첩 리스트**_Nested List

: 다른 리스트를 값으로 가진 리스트

: 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음

1. 바깥 리스트의 인덱스로 안쪽 리스트 선택
2. 선택된 안쪽 리스트에 다시 한 번 인덱스 사용

![image.png](attachment:b9c17027-1d46-4e1a-8e67-00f43a4cbe5d:image.png)

**리스트의 가변성**(Mutability)

: 한 번 생성된 리스트는 **“그 내용을 자유롭게 수정, 추가, 삭제할 수 있음”**

![image.png](attachment:8938cd54-56a1-4f96-b51a-bb98209d55f3:image.png)

![image.png](attachment:0cd22905-93a8-4b80-bb44-5bcedcf81348:image.png)

![image.png](attachment:360bbb18-b643-4330-951b-4455bd773f65:image.png)

![image.png](attachment:0ba2aa6e-85bd-4b76-b260-a3a9592c9c56:image.png)

![image.png](attachment:af4c2400-4c02-4a71-8d66-1102bc547b7f:image.png)

### 튜플(Tuple)

: 여러 개의 값을 순서대로 저장하는 변경 불가능한(immutable) 시퀀스 자료형

: 소괄호 (()) 안에 값들을 쉼표(,)로 구분하여 만듦

: 모든 종류의 데이터를 담을 수 있음

리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음

![단일 요소 튜플을 만들 때는 **반드시 Trailing comma(후행 쉼표)**를 사용해야 함](attachment:06b5d09b-7922-48aa-8cb3-7e0245e56205:image.png)

단일 요소 튜플을 만들 때는 **반드시 Trailing comma(후행 쉼표)**를 사용해야 함

**시퀀스로서의 튜플**

: 튜플 역시 시퀀스이므로, 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음

![image.png](attachment:c6b220ac-d9be-464e-b52d-a9d5165e6cbe:image.png)

**튜플의 불변성**

: 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음

![image.png](attachment:c977d207-8b91-4bf0-af0e-6651891d0e0d:image.png)

: 튜플의 불변 특성을 이용하여 내부 동작과 안전한 데이터 전달에 사용됨

: 다중 할당, 값 교환, 함수 다중 반환 값 등

![image.png](attachment:a85b9e37-a516-45d8-a3ab-189ea6b4112d:image.png)

⇒ 튜플은 데이터의 “안정성과 무결성”을 보장함

### range

: **연속된 정수 시퀀스**를 생성하는 **변경 불가능한(immutable)** 자료형

: 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용함

: 실제로 모든 숫자를 메로리에 저장하는 대신 시작 값, 끝 값, 가격이라는 ‘규칙’만 기억하여 메모리를 매우 효율적으로 사용함

**ragne 기본 구문**

: range()는 1개, 2개, 또는 3개의 **매개변수(인자)**를 가질 수 있음

`range(start, stop, step)`

![image.png](attachment:66549ba4-4ec8-4395-af32-359c92f6a7b2:image.png)

- `range(stop)`

: 매개변수가 하나면 stop으로 인식

: start는 0이, step은 1이 default값

: range(5) → 0, 1, 2, 3, 4

- `range(start, stop)`

: 매개변수가 두 개면 start와 stop으로 인식

: step은 1이 default값

: range(2, 5) → 2, 3, 4

- `range(start, stop, step)`

: 모든 매개변수를 직접 지정

: range(2, 10, 2) → 2, 4, 6, 8

⇒ range는 list로 형 변환시 내부 값을 확인할 수 있음

**range의 규칙**

1. 값의 범위 규칙

: stop값은 생성되는 시퀀스에 절대 포함되지 않음

: range(1, 5)는 1부터 5 **전**까지의 숫자를 의미하므로 1, 2, 3, 4가 생성

![stop 값 바로 앞에서 시퀀스가 끝난다고 기억](attachment:2e65a2ee-21ad-4d01-9af5-2dc5abe8bb58:image.png)

stop 값 바로 앞에서 시퀀스가 끝난다고 기억

1. 증가 / 감소 값(step) 규칙

: step값은 숫자 시퀀스의 간격과 방향을 결정

- step이 양수일 때(기본값: 1)

![image.png](attachment:61ce35d0-001b-417e-904a-1daef8c25348:image.png)

→ 숫자가 start부터 stop을 향해 증가

→ range(1, 10, 2) → 1, 3, 5, 7, 9

- step이 음수일 때

![image.png](attachment:ec6c94a1-efe5-4798-9e92-e40aa3772245:image.png)

→ 숫자가 start부터 stop을 향해 감소

→ start값은 stop값보다 반드시 커야함

→ range(10, 1, -2) → 10, 8, 6, 4, 2

### dict(딕셔너리)

: key-value 쌍으로 이루어진 **순서와 중복이 없는** 변경 가능한 자료형

: 중괄호({}) 안에 값들이 쉼표(,)로 구분되어 있음

: 값 1개는 키와 값이 쌍으로 이루어져 있음

- Key(키) : 값을 식별하기 위한 고유한 ‘이름표’(중복 불가)
- Value(값) : 키에 해당하는 실제 데이터

: **각 값에는 순서가 없음 = 인덱스 값이 없음**

: **시퀀스 자료형이 아님**

**딕셔너리 규칙**

- Key의 규칙

: 고유해야 함 → Key는 중복될 수 없음

: 변경 불가능한(immutable) 자료형만 사용 가능

→ str, int, float, tuple : 가능(O)

→ list, dict : 불가능(X)

- Value의 규칙

: 어떤 자료형이든 자유롭게 사용할 수 있음

**딕셔너리 값 접근 방법**

: Key를 사용하여 해당 Value를 꺼내올 수 있음

: Key에 접근 시 대괄호([]) 사용

![image.png](attachment:1744cd23-395b-4f43-b294-dac1c6766e18:image.png)

→ 존재하지 않는 Key로 접근하면 KeyErro가 발생하며 프로그램이 멈춤

→ 사전에서 단어(Key)를 찾아 뜻(Value)을 확인하는 것처럼, 딕셔너리는 Key를 통해 Value에 빠르게 접근함

![Key의 값이 아닌 Value의 값 변경 가능함](attachment:4f66c72e-55c1-47db-8e52-d74d3a6bb909:image.png)

Key의 값이 아닌 Value의 값 변경 가능함

→ 데이터에 순서가 필요 없고, 각 데이터에 의미있는 이름(Key)을 붙여 관리하고 싶을 때 사용함(ex: 사람의 인적 정보, 게임 캐릭터의 능력치 등)

### set

: 순서와 중복이 없는 변경 가능한 자료형

: 중괄호({}) 안에 값들을 쉼표(,)로 구분하여 만듦

: 수학에서의 집합과 동일한 연산 처리 가능

: **시퀀스 자료형이 아님**

![image.png](attachment:57673084-494a-45e6-9599-71b5445acc3d:image.png)

⇒ 비어있는 딕셔너리와 혼동을 피하기 위해, 비어있는 세트는 반드시  set() 함수로 만들어야 함

- 중복을 허용하지 않음

→ 똑같은 값은 단 하나만 존재할 수 있음

- 순서가 없음

→ 인덱싱(set[0])이나 슬라이싱(set[0:2])을 사용할 수 없음

**set의 집합 연산**

: 세트는 수학의 ‘집합’ 개념을 그대로 가져와 두 데이터 그룹 간의 관계를 파악하는 데 매우 효과적임

![image.png](attachment:f33fce74-1188-4f6a-8ada-11e0ae84cd50:image.png)

---

### Other Types

**None**

: **’값이 없음’**을 표현하는 특별한 데이터 타입

→ 내용물이 없는 ‘빈 상자’와 같음

→ 숫자 0이나 빈 문자열(’’)과는 다른 **‘값이 존재하지 않음’** 또는 **‘아직 정해지지 않음’**이라는 상태를 나타내기 위해 사용됨

![image.png](attachment:cfca3bcf-5965-4c33-b9fb-c8c4adcc078e:image.png)

**Boolean**

: ‘참(True)’과 ‘거짓(False)’ 단 두 가지 값만 가지는 데이터 타입

→ 마치 ‘ON / OFF’ 스위치처럼 프로그램의 흐름을 제어하는 조건문에서 ‘맞다’ 또는 ‘틀리다’를 판단하는 역할을 함

![image.png](attachment:e9435956-9f62-4530-889d-6ba6631beccd:image.png)

→ 비교 / 논리 연산의 평가 결과로 사용됨

⇒ 주로 조건 / 반복문과 함께 사용

**Collection**

: **여러 개의 값을 하나로 묶어 관리**하는 자료형들을 통칭하는 말

→ 여러 물건을 담는 ‘보관함’과 같으며, 파이썬은 목적에 따라 다양한 종류의 컬렉션을 제공함

→ str, list, tuple, range, set, dict 데이터 타입이 모두 Collection에 분류됨

![image.png](attachment:1c86d41f-b337-42e2-986e-8b9365d33ae6:image.png)

---

### 불변과 가변

: 컬렉션 타입은 생성 후 내용을 변경할 수 있는 지 없는 지에 따라 ‘불변’과 ‘가변’ 두 그룹으로 나뉨

![image.png](attachment:919991c6-cc31-4198-a754-1351ca85687f:image.png)

![image.png](attachment:2db0adf8-dbef-49fe-974b-f0ac5d6ed5b6:image.png)

![image.png](attachment:13c264ae-be5c-4ceb-bed6-a8ff1bd15fc3:image.png)

→ 불변은 메모리에 값 자체가 들어가있고, 가변은 메모리에 주소값이 들어가있어 주소값을 변경함으로 해당 값을 변경할 수 있게됨

//얕은 복사, 깊은 복사 서치(가변의 개념 이해를 위해)//

---

### 형 변환(Type Conversion)

: 한 데이터 타입을 **다른 데이터 타입으로 변환**하는 과정

ex) 문자열 ‘100’을 숫자 100으로 바꾸거나, 숫자 3.14를 정수 3으로 바꾸는 등 데이터의 ‘형태’를 필요에 따라 바꾸는 것

**암시적 형변환(Implicit Conversion)**

: 파이썬이 연산 중에 **자동으로 데이터 타입을 변환**하는 것

: 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙

: 작은 ‘정수 상자’와 큰 ‘실수 상자’의 내용물을 합칠 때 더 안전하게 담을 수 있는 큰 ‘실수 상자’로 알아서 옮겨 담는 것과 같음

ex)

- 정수와 실수의 연산에서 정수가 실수로 변환됨
- Boolean과 Numeric Type에서만 가능

![image.png](attachment:01c1bae5-b2f0-4398-a534-643e3043a265:image.png)

**명시적 형변환(Explicit Conversion)**

: 개발자가 변환하고 싶은 타입을 **직접 함수로 지정하여 변환**하는 것

: 서로 다른 타입의 데이터를 ‘호환’되도록 맞추는 과정

![image.png](attachment:2b9e36b0-039b-4865-a32f-65831bf892f6:image.png)

ex)

- str → int : 형식에 맞는 숫자만 가능

![image.png](attachment:8838ce49-3cdf-4a71-ac45-768c376ac179:image.png)

- int → str : 모두 가능

![image.png](attachment:1e61b505-0bc3-4520-9d35-ba0c9ebb0fb7:image.png)

(참고)

![image.png](attachment:77cdc9b3-f767-4dcc-864d-d57cd4524caa:image.png)

---

### 복합 연산자

: 연산과 할당이 함께 이루어짐

![image.png](attachment:a68314f9-626b-44d8-8d18-2ef831e1a55c:image.png)

### 비교 연산자

: 두 값을 비교하여 그 관계가 맞는지 틀리는지를  True 또는 False로 반환

![image.png](attachment:adc2db84-718c-4511-8f66-307a20df3abd:image.png)

**== 연산자**

: 값(데이터)이 같은지를 비교

: 동등성(equality)

ex) 1 == True의 경우 파이썬이 내부적으로 True를 1로 간주할 수 있으므로 True 결과가 나옴

![image.png](attachment:d0d238ad-2d97-4d69-a7c5-b2c1f9870ac8:image.png)

**is 연산자**

: 객체 자체가 같은지를 비교(값, 주소 모두 비교)

: 식별성(identity)

: 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용

![image.png](attachment:1de36fa4-7cf1-4221-a01d-05367ead5690:image.png)

**is 대신 ==를 사용해야 하는 이유**

: is는 ‘정체성’을, ==는 ‘가치’를 비교하기 때문

→ ‘같다’를 확인하는 목적이 근본적으로 다름

- is (Identity Operator)

: 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지, 즉 ‘정체성(Identity)’이 같은 지를 확인

- ==(Equality Operator)

: 두 변수가 가리키는 객체의 내용, 즉 ‘값(Value)’이 같은지를 확인

**is를 값 비교에 사용하면 안 되는 이유 - “의도와 다른 결과를 낳음”**

: 아래 코드에서 is는 “두 객체가 메모리상에서 같은 존재인가?”를 묻기 때문에 False를 출력

: 우리가 궁금한 것은 “두 객체의 값이 논리적으로 같은가?”이므로 ==를 사용해야 의도에 맞는 True를 얻을 수 있음

![image.png](attachment:4dded2e0-737b-4b31-b676-c40835953988:image.png)

**is 연산자는 언제 사용하는가?**

⇒ 주로 싱글턴 객체를 비교할 때 사용함

**싱글턴(Singleton) 객체**

: 특정 값에 대해 파이썬 전체에서 **단 하나의 객체만 생성된어 재사용**되는 특별한 객체

: 여러 변수가 이 값을 가지더라도 모두 **미리 만들어진 하나의 객체**를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐

⇒ None, True, False

**싱글턴 객체를 비교할 때**

: is 연산자는 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용

![image.png](attachment:68b3a3d3-802c-4547-ad2b-dd1ad904d992:image.png)

++ 리스트나 객체 비교 시 주의사항

: 리스트 또는 다른 가변 객체(mutable)를 비교할 때 값 자체가 같은 지 확인하려면 ==를 사용

: 두 변수가 완전히 동일한 객체를 가리키는지를 확인해야 한다면 is를 사용

![image.png](attachment:febe85f9-2f7a-4bba-8d54-f8462dbee187:image.png)

- 값 비교에는 ==을 사용하고, 객체(레퍼런스) 비교에는 is를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값)을 판단해야 할 때 is를 쓰면 의도치 않은 결과(False)가 나올 수 있음 → 파이썬 내부적 최적화나 타입 차이로 인해 일관성이 깨질 수 있기 때문
- is는 주로 싱글턴 객체에 대한 비교 시 사용

### 논리 연산자

: 여러 개의 조건을 조합하거나 True / False 값을 반대로 뒤집을 때 사용

![image.png](attachment:911a15a5-de9a-44a7-bb2b-c0615e47d50f:image.png)

![image.png](attachment:37c6f58f-2123-442d-9ae4-d1785811890f:image.png)

---

### 단축 평가

: 논리 연산에서 **두 번째 피연산자를 평가하지 않고 결과를 결정**하는 동작

- 거짓으로 취급되는 것들

: False, 숫자 0, 빈 문자열 ‘’, 빈 리스트 [], None 등 ‘비어있거나 없다’는 느낌의 것들

- 참으로 취급되는 것들

: True 그리고 ‘거짓’이 아닌 모든 값

: 1, -10, ‘hello’, [1, 2] 등 내용이 있는 값

- and 연산자

: 하나라도 ‘거짓’이면 바로 ‘거짓’

: and는 연산을 왼쪽에서 오른쪽으로 진행하다가 처음 만나는 ‘거짓’ 값을 바로 반환

: 만약 끝까지 갔는데 모든 값이 ‘참’이면 맨 마지막 ‘참’ 값을 반환

- or 연산자

: 하나라도 ‘참’이면 바로 ‘참’

: or은 연산을 왼쪽에서 오른쪽으로 진행하다가 처음 만나는 ‘참’값을 바로 반환

: 만약 끝까지 갔는데 모든 값이 ‘거짓’이면 맨 마지막 ‘거짓’ 값을 반환

![image.png](attachment:a991c1b1-8b6a-4dcb-84d6-19cc67a70266:image.png)

→ 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함

→ 단순히 True / False 논리 연산을 넘어, 이처럼 코드의 흐름을 제어하고 오류를 방지하며, 간결한 코드를 작성하는 데 매우 유용하게 사용되는 파이썬의 중요한 기능

---

### 멤버십 연산자

: 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자

![image.png](attachment:e9281b4f-a5be-41f9-a1da-e3bfe269e387:image.png)

![image.png](attachment:0287df2d-2d59-455b-a0e5-c6f8f4be43a1:image.png)

### 시퀀스형 연산자

: 시퀀스 자료형(문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자

: ‘+’는 시퀀스를 연결하는 기능, ‘*’는 시퀀스를 반복하는 기능을 함

![image.png](attachment:45a49052-0dd5-4c9f-969c-7dca9b768652:image.png)

![image.png](attachment:e530ff77-c5b6-475e-b558-16917c55d004:image.png)

### 연산자 우선순위

![image.png](attachment:6264c1a4-0b77-4cfc-87c3-93795dc50a09:image.png)

---

### 참고

**Trailing Comma(후행 쉼표)**

: 컬렉션의 마지막 요소 뒤에 붙는 쉼표

: 일반적으로 Trailing Comma 작성은 ‘선택사항’

: 단, 하나의 요소로 구성된 튜플을 만들 때는 필수

![image.png](attachment:1e4b43d9-49e6-4209-916e-66cb2695f6b0:image.png)

: 각 요소를 별도의 줄에 작성

: 마지막 요소 뒤에 trailing comma 추가

: 닫는 괄호는 새로운 줄에 배치

![image.png](attachment:cdb648e2-b2a0-4e52-b989-7c20750c20ca:image.png)

![image.png](attachment:ebba0422-8b33-49c5-80e2-6bef5cadc5af:image.png)

**Trailing Comma 장점**

- 가독성 향상

: 각 줄이 동일한 패턴을 가짐

: 코드 리뷰가 용이함

- 유지보수 용이성

: 항목 추가 / 제거가 간단

: 실수로 인한 구문 오류 방지

---

### [Review_활동 정리]

- 리스트(List)

: 순서가 있고, 수정 가능한 값들의 묶음

ex) my_list = [1, ‘a’, True]

- 딕셔너리(dict)

: 순서 없이 Key-Value 쌍으로 이루어진 데이터 묶음

ex) my_dict = {’사과’ : 1500, ‘바나나’ : 3000}

- 형 변환

: 데이터의 타입을 의도적으로 변경하는 것

ex) int(’123’), str(3.14)

- Boolean

: 참(True) 또는 거짓(False)을 나타내는 데이터 타입

ex) is_student = True

- 멤버십 연산자

: 특정 값이 컬렉션에 포함되어 있는지 확인하는 연산자

ex) ‘apple’ in fruit_basket

- 논리 연산자

: 여러 조건을 조합(and, or)하거나 반전(not)시키는 연산자

ex) if age > 19 and has_ticket:

- 단축 평가

: 논리 연산에서 전체 결과가 확정되면 나머지 부분은 평가하지 않는 동작

ex) True or (some_complex_fuction())