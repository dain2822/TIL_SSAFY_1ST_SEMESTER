## 250729

### [Objectives_학습 목표]

- 딕셔너리와 세트의 개념과 필요성을 설명할 수 있음
- get, update, pop 등 딕셔너리 메서드를 활용해 데이터를 안전하게 조회, 수정, 삭제할 수 있음
- union, intersection, difference 등 세트 집합 연산으로 중복을 제거하고 관계를 분석할 수 있음
- 해시 테이블과 hashable 원리를 이해하고 키 제약을 설명할 수 있음
- EBNF 메타기호([])를 해석해 공식 문서를 효율적으로 읽을 수 있음

---

### [Build_ 이론]

### 딕셔너리(Dictionary)

: 키(Key)와 값(Value)을 짝지어 저장하는 자료구조

: 내부적으로 해시 테이블을 사용하여 키-값 쌍을 관리함

: 키를 통한 값의 삽입, 삭제, 검색이 데이터의 크기와 관계없이 매우 빠름

: 키(key)는 hashable한 고유 값이어야 하지만, 값(value)은 중복이 가능하고 어떤 자료형도 저장할 수 있음

- `.get(key[,default])`
    
    : 키와 연결된 값을 반환하거나 키가 없으면 None 혹은 기본 값을 반환
    
    → 에러가 발생하면 안 되는 경우
    
    ![image.png](attachment:2edacccf-37ed-4746-be64-bc52bd11a23a:image.png)
    
- `.keys()`
    
    : 딕셔너리 키를 모은 객체를 반환
    
    ![image.png](attachment:c9546aec-b59b-45cf-92bb-65b0288142dd:image.png)
    
- `.values()`
    
    : 딕셔너리 값을 모은 객체를 반환
    
    ![image.png](attachment:38d01fb3-19a4-43c4-97e5-a2f1c7448412:image.png)
    
- `.items()`
    
    : 딕셔너리 키 / 값 쌍을 모은 객체를 반환
    
    ![image.png](attachment:c1962f6b-5753-4b40-9929-96257ff611e9:image.png)
    
- `.pop(key[,default])`
    
    : 키를 제거하고 연결되었던 값을 반환
    
    : 키가 없으면 에러나 default를 반환
    
    ![image.png](attachment:7652eac6-53c8-432f-b17a-868aa5084f9a:image.png)
    
- `.clear()`
    
    : 딕셔너리의 모든 키 / 값 쌍을 제거
    
    ![image.png](attachment:662923f2-73eb-4f73-9f8b-d18e1e10dd39:image.png)
    
- `.setdefault(key[,default])`
    
    : 키와 연결된 값을 반환
    
    : 키가 없다면 default와 연결한 키를 딕셔너리에 추가하고 default를 반환
    
    → get 기능 + 추가
    
    ![image.png](attachment:e9ba22ac-656a-4179-9ba7-658f06149a30:image.png)
    
- `.update([other])`
    
    : other가 제공하는 키 / 값 쌍으로 딕셔너리를 갱신하고 기존 키는 덮어씀
    
    ![image.png](attachment:50e1674b-e8a5-49ba-bc58-905bbccdf37f:image.png)
    

[추가 딕셔너리 메서드 : https://docs.python.org/3.11/library/stdtypes.html#dict ]

### 세트(set)

: 고유한 항목들의 정렬되지 않은 컬렉션

: 내부적으로 해시 테이블을 사용하여 데이터를 저장함

: 항목의 고유성을 효율적으로 보장하며, 항목의 추가, 삭제, 존재 여부 확인(in 연산)이 데이터의 크기에 관계없이 매우 빠름

: 합집합(Union), 교집합(Intersection), 차집합(Difference) 등 수학적인 집합 연산을 간편하게 수행할 수 있는 것이 가장 큰 특징임

- `.add(x)`
    
    : 세트에 x를 추가
    
    ![image.png](attachment:8009cf57-7622-47ac-9daa-cb61a031e5e4:image.png)
    

![image.png](attachment:b6d2277b-4788-4d24-8f00-06bffc85fed7:image.png)

![image.png](attachment:223f90b2-297b-439c-82c0-b583bdfec291:image.png)

→ 실행 결과는 계속 바뀜

- `.update(iterable)`
    
    : 세트에 다른 iterable 요소를 추가
    
    ![image.png](attachment:74d7d208-2fe0-4155-b470-7a7886ec98ae:image.png)
    
- `.clear()`
    
    : 세트의 모든 항목을 제거
    
    ![image.png](attachment:064392d0-023a-4a9d-89e7-e9e935033fa3:image.png)
    
- `.remove(x)`
    
    : 세트에서 항목 x를 제거하고 항목 x가 없을 경우 keyError
    
    ![image.png](attachment:3909256b-ede8-4c85-b369-326ab6aaa3c4:image.png)
    
- `.pop()`
    
    : 세트에서 임의의 요소를 제거하고 반환
    
    ![image.png](attachment:03332ec6-cbd0-4766-b463-3375061ce604:image.png)
    
- `.discard(x)`
    
    : 세트 s에서 항목 x를 제거
    
    : remove와 달리 에러 없음
    
    ![image.png](attachment:b66d4142-c8ee-4ad1-b425-5df600824fa2:image.png)
    
- 세트의 집합 메서드
    
    ![image.png](attachment:676967f9-9328-43f8-bb07-f6cb7327acec:image.png)
    

![image.png](attachment:a7654392-7259-49ff-a31d-4cc3ae56d01d:image.png)

---

### 참고

### 해시 테이블(hash table)

: 키(Key)와 값(Value)을 짝지어 저장하는 자료구조

**해시 테이블의 원리**

1. 키를 해시 함수를 통해 해시 값으로 변환
2. 변환된 해시 값을 인덱스로 삼아 데이터를 저장하거나 찾음
    
    ⇒ 검색, 삽입, 삭제를 매우 빠르게 수행
    
    ![image.png](attachment:3ea17531-8a02-46f4-b074-c010d2f47142:image.png)
    

**해시(Hash)**

: 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것

: 생성된 해시 값(고유한 정수)은 해당 데이터를 식별하는 ‘지문’ 역할을 함

→ 파이썬은 이 해시 값을 이용해 해시 테이블에 데이터를 저장하는데, 이 변환을 수행하는 것이 **해시 함수**

**해시 함수(Hash Function) / 해시 알고리즘**

: 임의 길이 데이터를 입력 받아 고정 길이(정수)로 변환해 주는 함수

→ ‘정수’가 바로 해시 값

: 주로 해시 테이블을 구현할 때, 매우 빠른 검색 및 데이터 저장 위치 결정을 위해 활용

- 해시 테이블이 매우 빠른 이유?
    
    → 해시 함수는 키(Key)를 입력 받아 데이터를 저장하거나 찾을 배열의 ‘정확한 인덱스’를 즉시 계산함
    

**set의 요소 & dict의 키와 해시 테이블 관계**

- set
    - 각 요소를 해시 함수로 변환해 나온 해시 값에 맞춰 해시 테이블 내부 버킷(bucket)에 위치 시킴
    - “순서”라기보다 “버킷 위치(인덱스)”가 요소의 위치를 결정
        
        ⇒ set는 순서를 보장하지 않음
        
- dict
    - 키(Key) → 해시 함수 → 해시 값 → 해시 테이블에 저장
    - 단 set와 달리 “삽입 순서”는 유지한다는 것이 언어 사양에 따라 보장
        - 키를 추가한 순서대로 반복문 순회할 때 나오게 됨
        - 사용자에게 보여지는 키 순서는 삽입 순서가 유지되도록 설계된 것

**set의 pop 메서드 예시**

- 정수
    
    : 정수(숫자) 값은 해시 값이 숫자 자기 자신과 동일하거나 단순 계산으로 고정됨
    
    ![image.png](attachment:b2b65206-42b3-44ad-8caf-92dccff564b3:image.png)
    
- 문자열
    
    : 문자열은 해시 계산 시 파이썬의 해시 난수화(Hash Randomization)가 적용되므로, 실행마다 순서가 달라질 수 있음
    
    ![image.png](attachment:e7ac8751-15db-4d55-afd0-b793c21654c4:image.png)
    

**파이썬에서의 해시 함수**

- 정수
    
    : 같은 정수는 항상 같은 해시 값을 가짐
    
    ex) hash(1)은 여러 번 호출해도 결과가 동일
    
- 문자열
    
    : 문자열 해시 시, 파이썬 인터프리터가 시작될 때 설정되는 난수 시드(seed)가 달라질 수 있음
    
    : 보안상 이유로 해시 난수화 도입
    
    : 각 실행마다 달라질 수 있어 ‘a’의 해시 값도 매번 바뀔 수 있음
    
    ![image.png](attachment:11d801c7-cc9d-48a4-893e-d89b0a523da3:image.png)
    

**해시 난수화와 난수 시드**

: 파이썬 프로세스가 새로 시작될 때마다 해시를 계산할 때 사용하는 난수 시드가 달라짐

→ 해시 함수가 매번 바뀌는 것이 아니라 해시 계산에 쓰이는 시드 값이 실행마다 달라지는 것

: 이로 인해 동일한 데이터라도 매번 해시 값이 달라져 결과적으로 버킷 배치가 달라짐

![image.png](attachment:3c3e3393-6629-4c5d-94a1-f79a43ff3bb3:image.png)

**set의 요소 & dict의 키와 해시테이블 관계**

: set의 pop()은 “임의의 요소”를 제거하고 반환함

→ 실행할 때마다 다른 요소를 얻는다는 의미에서의 “무작위”가 아니라 “임의”라는 의미에서의 “무작위”

(By “arbitrary” the docs don’t mean “random”)

**내부적으로 해시 테이블(버킷)을 참조하기 때문에 실행 때마다 다른 요소가 먼저 나올 수 있음**

: 해시 난수화로 인해 문자열 같은 해시 값이 실행마다 달라질 수 있고, set 내부 요소의 배치가 달라질 수 있음

: 정수는 해시 값이 항상 동일하기 때문에 파이썬을 동일 프로세스에서 연속 실행할 때는 결과가 어느 정도 일정해 보이기도 하지만, 여전히 set은 순서가 없으므로 pop되는 순서는 예측이 불가

**hashable**

: hash() 함수에 넣어 해시 값을 구할 수 있는 객체를 의미

: 대부분의 불변 타입은 해시 가능

ex) int, float, str, tuple(단, 내부에 불변만 있는 경우)

: 가변형 객체(예 : list, dict, set)는 기본적으로 해시 불가능

→ 값이 변하면 해시 값도 달라질 수 있어 해시 테이블 무결성이 깨짐

![image.png](attachment:f72314d7-40f2-428e-8ccf-558dc3475ca2:image.png)

**hashable과 불변성 간의 관계**

: 해시 테이블(ex :  set, dict의 KEY)에는 hashable(해시가 가능한 객체)만 저장 가능

: 불변 객체는 생성 후 값 변경이 불가능하므로, 항상 같은 해시 값을 유지

→ 해시 테이블이 안정적으로 동작

: “hash 가능하다 ≠ 불변이다”가 절대적이지는 않지만 일반적으로 내장 자료형 기준에서는 불변이어야 해시 가능

**가변형 객체가 hashable하지 않은 이유**

- 해시 값의 불변성 : 해시 테이블은 객체의 해시 값을 이용해 데이터를 저장하고 검색할 위치(인덱스)를 결정함
- 문제 발생 : 만약 list와 같은 가변 객체를 키로 사용하고, 그 리스트의 내용을 변경하면 해시 값도 함께 변하게 됨
- 데이터 손실 : 데이터를 저장했던 인덱스와 변경 후 찾으려는 인덱스가 달라져 해당 데이터를 영원히 찾을 수 없게 됨
    
    ⇒ 해시 테이블의 안정적인 동작을 보장하기 위해 파이썬은 가변 객체의 해시 값 계산을 허용하지 않음
    

: 값이 변경될 수 있으므로, 같은 객체라도 값이 바뀌면 해시 값도 달라질 수 있음

: 해시 테이블에서는 “동일 키 → 동일 위치”로 가정하고 빠른 검색을 수행하는데 이 가정이 깨짐

ex) 리스트, 집합, 딕셔너리 자체를 set이나 dict의 키로 쓸 수 없음

![image.png](attachment:eb30945f-3b11-47e0-9ba8-ed378abb39cf:image.png)

**hashable 객체가 필요한 이유**

1. 해시 테이블 기반 자료 구조 사용
    1. set의 요소, dict의 키
    2. 중복 방지 & 빠른 조회, 검색
2. 불변성을 통한 일관된 해시 값
    1. 한 번 해시 값이 정해지면 바뀌지 않아야 해시 테이블 무결성이 유지
3. 안정성과 예측 가능성 유지
    1. 동일한 데이터는 항상 동일한 해시 값을 반환 → 로직을 단순화

*hashable : 해시 함수를 통해 고유한 해시 값을 만들 수 있고, 값이 변하지 않는 객체

### 해시 테이블 정리

: 해시 테이블은 **해시 값**을 **인덱스**로 삼아 데이터를 저장, 검색

: 파이썬의 set은 순서가 없고, pop()시 어떤 요소가 반환될 지 정해져 있지 않음

: dict는 파이썬 3.7+ 버전에서 삽입 순서가 보장되지만, 내부 구현은 여전히 해시 테이블

: 해시 함수는 정수 / 문자열 등 타입에 따라 다르게 동작하며, 문자열 해시 시 난수화로 실행마다 달라질 수 있음

: hashable(해시가 가능한 객체) 객체만 set과 dict의 키로 사용 가능하며, 일반적으로 불변 타입이 이에 해당

### 파이썬 문법 규격

- BNF_ “Backus-Naur Form”
    
    : 프로그래밍 언어의 문법을 표현하기 위한 표현법
    
- EBNF_”Extended Backus-Naur Form”
    
    : BNF를 확장한 표기법
    
    : 메타 기호를 추가하여 더 간결하고 표현력이 강해진 형태
    

![image.png](attachment:b3405d62-d34f-4828-909f-7ce83a1ed0ba:image.png)

ex) pop(key[, default])

⇒ 서로 다른 프로그래밍 언어, 데이터 형식, 프로토콜 등의 문법을 통일하여 정의하기 위해 사용함

---

### [Review_ 활동 정리]

- 딕셔너리(Dictionary)
    
    : 고유한 키-값 쌍을 저장하는 비시퀀스 컬렉션
    
    ex) {”name” : “Alice”, “age” : 25}
    
- 세트(Set)
    
    : 중복을 허용하지 않는 정렬되지 않은 컬렉션
    
    ex) {0, 1, 2}.union({1, 3}) → {0, 1, 2, 3}
    
- 해시 테이블(Hash Table)
    
    : 키를 해시 값으로 변환해 배열 인덱스로 사용해 빠른 검색, 삽입, 삭제를 지원
    
    ex) 책 제목(키) → 색인(해시 함수) → 책장 번호(인덱스)로 바로 이동
    
- hashable(해시 가능)
    
    : 내부 값이 변하지 않아 동일한 해시 값을 유지하는 객체만 dict 키, set 요소로 사용 가능
    
    ex) hash(”a”), hash((1, 2, 3))는 정상, hash([1, 2, 3])는 TypeError
    
- 집합 연산(Union / Intersection 등)
    
    : 두 세트의 합집합, 교집합, 차집합 등을 통해 중복 제거와 관계 분석 수행
    
    ex) set1.union(set2) → {0, 1, 2, 3, 4, 5, 7, 9}
    
- dict.get()
    
    : 키가 없을 때 기본값을 반환해 안전하게 조회할 수 있는 메서드
    
    ex) person.get(”country”, “Unknown”)
    
- 키(Key)
    
    : 값에 접근하기 위한 고유 식별자 - 인덱스 대신 사용되어 가독성과 검색 속도를 향상
    
    ex) phonebook[”민수”]로 번호 조회
    
- EBNF 메타기호 []
    
    : 공식 문서에서 선택적 매개변수를 나타내는 표기법(대괄호 안은 선택)
    
    ex) pop(key[, default])에서 default는 선택 가능
    
- 비시퀀스 자료 구조
    - 딕셔너리(dict) : 키-값 쌍을 저장, py 3.7+부터 삽입 순서 유지
    - 세트(set) : 중복을 허용하지 않는 집합, 빠른 멤버십 테스트와 집합 연산 제공
- 핵심 메서드 활용
    - dict.get(), update(), pop() 등으로 안전한 조회, 갱신, 삭제 수행
    - set.union(), intersection(), difference() 등올 합집합, 교집합, 차집합 계산
- 해시 테이블 & hashable
    - 해시 함수로 키를 인덱스로 변환해 O(1) 접근, 불변 객체만 키 / 요소로 사용해 무결성 유지
- EBNF 메타기호 읽기
    - pop(key[, default])에서 []는 선택 인자를 의미 → 공식 문서를 빠르게 해석
- 자료 구조 선택의 중요성
    - 구조 선택에 따라 실행 시간, 메모리, 코드 가독성이 달라짐