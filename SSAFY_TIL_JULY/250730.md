## 250730

### [Objectives_ 학습 목표]

- 객체 지향 프로그래밍(OOP)의 개념과 특징을 설명할 수 있음
- 클래스와 인스턴스의 차이를 이해하고 구분할 수 있음
- 클래스 내부에 변수와 메서드를 정의할 수 있음
- 인스턴스를 생성하고 인스턴스 변수를 활용할 수 있음
- 인스턴스 메서드, 클래스 메서드, 스태틱 메서드의 차이를 설명할 수 있음
- 클래스와 인스턴스의 이름 공간(name space)을 이해할 수 있음
- 매직 메서드와 데코레이터의 기본적인 개념을 이해할 수 있음

---

### [Build_ 이론]

### 절차 지향 프로그래밍_ Procedural Programming

: 함수와 로직 중심 작성 데이터를 순차적으로 처리

![절차 지향 사고 예시](attachment:5fbf2e64-a523-490b-842c-31692acbcf24:image.png)

절차 지향 사고 예시

→ 변수와 함수를 별개로 다룸

**절차 지향 프로그래밍의 특징**

: 입력을 받고, 처리하고, 결과를 내는 과정이 위에서 아래로 순차적으로 흐르는 형태

: 순차적인 명령어 실행

: 데이터와 함수(절차)의 분리

: 함수 호출의 흐름이 중요

→ 요리 레시피를 차례대로 따라가는 것과 비슷함(레시피 순서를 하나씩 밟아 나가는 형식)

→ 데이터를 다시 재사용하기보다는 처음부터 끝까지 실행되는 결과물이 중요

**절차 지향적 프로그래밍의 한계**

- 복잡성 증가
    - 프로그램 규모가 커질수록 데이터와 함수의 관리가 어려움
    - 전역 변수의 증가로 인한 관리의 어려움
- 유지보수 문제
    - 코드 수정 시 영향 범위 파악이 어려움
    
    ![image.png](attachment:4c18bb74-c85a-42f5-a5bd-c8645b433136:image.png)
    

### 객체 지향 프로그래밍_ Object Oriented Programming

: 클래스는 설계도, 인스턴스는 실제 물건

![객체 지향 사고 예시](attachment:38ba8077-e933-4dd4-92e4-f5504363c2ca:image.png)

객체 지향 사고 예시

→ 사람(객체) 안에 name, age와 이와 관련된 기능(메서드) 포함

**객체 지향 프로그래밍 특징**

: 프로그램을 데이터(변수)와 그 데이터를 처리하는 함수(메서드)를 하나의 단위(객체)로 묶어서 조직적으로 관리

: 데이터와 메서드의 결합

→ 주방 도구(프라이팬, 칼), 재료(야채, 고기), 행동(볶기, 썰기)를 각각 별개로 생각하지 않고, ‘볶음밥 기계’라는 객체로 만들어 놓고 그 기계가 알아서 해당 행동과 재료를 관리하는 방식

**절치 지향**

- 데이터와 해당 데이터를 처리하는 함수(절차)가 분리
- 함수 호출의 흐름이 중요
- “어떤 순서로 처리할까?”

**객체 지향**

- 데이터와 해당 데이터를 처리하는 메서드를 하나의 객체로 묶음
- 객체 간 상호작용과 메시지 전달이 중요
- “어떤 객체가 이 문제를 해결할까?”
- “이 객체는 어떤 속성과 기능을 가질까?”

**객체지향 - “데이터가 살아나다”**

: 객체 지향은 수동적인 데이터가 능동적인 객체로 변화한 것

: 절차 지향에서는 데이터가 함수의 매개변수로 전달되어 처리되는 수동적 존재였지만, 객체 지향에서는 데이터와 해당 데이터를 처리하는 메서드가 하나의 객체로 통합되어 스스로 기능을 수행하는 능동적 존재가 됨

→ 코드의 구조화와 재사용성을 높이는 동시에 실제 세계의 모델링 방식과 더 유사한 프로그래밍을 가능하게 함

**주의 사항**

⇒ **절차 지향과 객체 지향은 대조되는 개념이 아니다**

: 객체 지향은 기존 절차 지향을 기반으로 두고 보완하기 위해 객체라는 개념을 도입해 상속, 코드 재사용성, 유지보수성 등의 이점을 가지는 패러다임

### 객체와 클래스

**객체_Object**

: 실제 존재하는 사물을 추상화한 것

: ‘속성’과 ‘동작’을 가짐

ex) ‘강아지’라는 객체는 이름, 종, 나이(특징)와 짖기, 뛰기(행동) 등으로 표현할 수 있음

**클래스_Class**

: 객체를 만들기 위한 설계도

: 데이터와 기능을 함께 묶는 방법을 제공

: 파이썬에서 타입을 표현하는 방법

→ 클래스로부터 여러 개의 객체를 쉽게 만들어 낼 수 있음

![객체 예시_1](attachment:be2ca5ac-7b1c-4a24-8769-082666c95ae3:image.png)

객체 예시_1

![객체 예시_2](attachment:a1f07faa-e3f2-4736-a414-e28946cd6388:image.png)

객체 예시_2

![image.png](attachment:228f8a0b-da87-433a-9e8c-d3c0b9156322:image.png)

**객체 특징**

- 속성(Attribute) : 객체의 상태 / 데이터
- 메서드(Method) : 객체의 행동 / 기능
- 고유성 : 각 객체는 고유한 특성을 가짐 (독립적임/서로 영향을 끼치지 않음)

---

### 클래스_Class

: 하나의 구조 아나에 데이터(변수)와 기능(함수)을 함께 정의 하는 도구(설계도)

<aside>
💡

클래스 : 소나타 설계도

인스턴스 : 소나타 1, 소나타 2, …

속성(변수) : 색상, 가죽 종류, 지역, 차량 번호 …

기능(메서드) : 직진하기, 후진하기, 우회전하기, 자율주행 …

</aside>

: class 키워드

: 클래스 이름은 파스칼 케이스(Pascal Case) 방식으로 작성

![image.png](attachment:414ffae9-0b44-46e4-ae01-f56e7d4a0305:image.png)

→ 각 단어 별 첫 글자를 대문자

**클래스 예시**

: __init__ 메서드는 ‘생성자 메서드’로 불리며, 새로운 객체를 만들 때 필요한 초기값을 설정

![image.png](attachment:d2273a04-6390-4c1a-b0a7-198cb35ea3c2:image.png)

### 인스턴스_Instance

: 클래스를 통해 생성된 객체

: 같은 클래스로 여러 인스턴스를 만들 수 있으며, 각 인스턴스는 클래스 구조를 따라 동작하지만 서로 독립된 데이터를 가질 수 있음

: 클래스가 설계도라면, 인스턴스는 그 설계도로부터 실제로 만든 ‘개별 물건’

![image.png](attachment:14208cb7-533a-44c2-972b-459a5faf36da:image.png)

→ Person(”Alice”, 25)라고 하면 Person이라는 설계도로부터 이름이 Alice이고 나이가 25인 ‘사람 객체’가 탄생

### 클래스와 인스턴스

![image.png](attachment:60c4da80-8745-4a35-b6b4-6c026c7f728a:image.png)

→ 인스턴스는 앞에 클래스를 명시해줘야 함!

: 클래스를 정의한다는 것은 공통된 특성과 기능을 가진 틀을 만드는 것

: 실제 활동하는 개별 객체들은 이 틀에서 생성된 인스턴스(instance)

: 공통된 특성과 기능을 가진 틀을 만드는 것은 곧 새로운 타입을 만드는 행위

- “아이유는 인스턴스다.”라는 표현이 모호한 이유 마찬가지
- “무슨 타입의 인스턴스”인지를 알 수 없기 때문

![image.png](attachment:2c71b582-07cc-4cb3-a7af-1d710bf63f86:image.png)

→ type(iu)를 출력하면 Singer가 출력 됨. 즉, Python은 iu가 어떤 타입에 속하는지 알고 있어야 함

: 변수 name의 타입은 str 클래스다.

→ 변수 name은 str 클래스의 인스턴스이다.

![image.png](attachment:defc378a-3429-4c17-80d7-66cb5dcaf0e9:image.png)

⇒ 결국 문자열 타입의 변수는 str 클래스로 생성된 인스턴스임

![image.png](attachment:7f619678-843d-4b73-949d-094cb7030e0b:image.png)

![클래스와 인스턴스_1](attachment:b11c49f3-7c44-4849-80c4-0d810a6b61aa:image.png)

클래스와 인스턴스_1

⇒ 문자열 타입(클래스)의 객체(인스턴스)

![클래스와 인스턴스_2](attachment:e9ea164c-f836-4666-ac63-1fceb2c2674d:image.png)

클래스와 인스턴스_2

⇒ 리스트 타입(클래스)의 객체(인스턴스)

![인스턴스와 메서드_1](attachment:d88dddcc-b1ca-471d-a6cd-cc67c9ca4fcb:image.png)

인스턴스와 메서드_1

⇒ 문자열.대문자로() → 객체.행동() → 인스턴스.메서드()

![image.png](attachment:ea531930-c13d-4531-a52d-19a926a34ebf:image.png)

⇒ 리스트.정렬() → 객체.행동() → 인스턴스.메서드()

**하나의 객체(object)는 특정 클래스의 인스턴스(instance)이다.**

---

### 클래스 구성요소

**클래스 구조**

![image.png](attachment:0f76bfc4-c59a-47fd-9125-d6fc2bffbfad:image.png)

- 생성자 메서드
    - 인스턴스 생성 시 자동 호출되는 특별한 메서드
    - __init__이라는 이름의 메서드로 정의
    - 인스턴스 변수의 초기화 담당

![image.png](attachment:2e2c69fd-5a82-438f-8314-2a21786c1c84:image.png)

- 인스턴스 변수(속성)
    - 각 인스턴스별 고유한 속성
    - sefl.변수명 형태로 정의
    - 인스턴스마다 독립적인 값 유지

![image.png](attachment:f35cf385-4217-4f6a-a028-1e0ddd1d588d:image.png)

- 클래스 변수(속성)
    - 모든 인스턴스가 공유하는 속성
    - 클래스 내부에서 직접 정의

### 클래스 변수와 인스턴스 변수

: 클래스 변수와 동일한 이름으로 인스턴스 변수 생성 시 클래스 변수가 아닌 인스턴스 변수에 먼저 참조하게 됨

: class.class_variable로 클래스 변수 참조 가능

![image.png](attachment:b1fd2b49-191b-4d0f-b651-c72059066380:image.png)

### 메서드_ Method

: 클래스 내부에 정의된 함수로, 해당 객체가 어떻게 동작할 지를 정의

ex) ‘강아지’라는 객체에 ‘짖는다’는 동작을 넣고 싶다면 그 동작을 메서드로 만들어 정의할 수 있음

**인스턴스 메서드_instance method**

: 인스턴스의 상태를 조작하거나 동작을 수행함

: 인스턴스마다 독립적으로 행동할 수 있게 만드는 것

![image.png](attachment:0d01fcd3-6f44-497b-a461-ae46ee0dec8a:image.png)

: 클래스 내부에 정의되는 메서드의 기본

: 반드시 첫 번째 인자로 **인스턴스 자신(self)**을 받음

→ self는 매개변수 이름일 뿐이며 다른 이름으로 설정 가능

: 인스턴스의 속성에 접근하거나 변경 가능

**self 동작 원리**

- upper 메서드를 사용해 문자열 ‘hello’를 대문자로 변경하기

![image.png](attachment:26f31eb1-f16c-4ec1-970f-4c79a8e38ff0:image.png)

- 하지만 실제 파이썬 내부 동작은 다음과 같이 진행

![image.png](attachment:deacb60f-8d64-49f3-8c0b-1eccd825631b:image.png)

→ str 클래스가 upper 메서드를 호출했고, 그 첫번째 인자로 문자열 인스턴스가 들어감

⇒ 인스턴스 메서드의 첫번째 인자가 반드시 인스턴스 자기 자신인 이유

: `'hello'.upper()`은 `str.upper('hello')`를 객체 지향 방식의 메서드로 호출하는 표현 (단축형 호출)

→ ‘hello’라는 문자열 객체가 단순히 어딘가의 함수로 들어가는 인자로 활용되는 것이 아닌 객체 스스로 메서드를 호출하여 코드를 동작하는 객체 지향적인 표현인 것

![image.png](attachment:74e5597e-37b0-489f-acaf-c7ea7dbecc33:image.png)

**생성자 메서드_ constructor method**

: 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드

→ 인스턴스 변수들의 초기값을 설정

![image.png](attachment:be3b5c5f-aca2-4711-8645-659cf474f512:image.png)

**클래스 메서드_ class method**

: 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행함

: @classmethod 데코레이터를 사용하여 정의

: **호출 시, 첫 번째 인자로 해당 메서드를 호출하는 클래스(cls)가 전달됨**

: 클래스를 인자로 받아 클래스 속성을 변경하거나 읽는 데 사용

![image.png](attachment:174473f9-f38a-4e54-8c2d-7681cee07db4:image.png)

![cls.population += 1 == Person.population += 1](attachment:0404d824-233c-43b5-b5da-310d972e776d:image.png)

cls.population += 1 == Person.population += 1

**스태틱(정적) 메서드_static method**

: 클래스, 인스턴스와 상관없이 독립적으로 동작하는 메서드

: @staticmethod 데코레이터를 사용하여 정의

: 호출 시 자동으로 전달 받는 인자가 없음(self, cls를 받지 않음)

: 인스턴스나 클래스 속성에 직접 접근하지 않는 ‘도우미 함수’와 비슷한 역할

![image.png](attachment:1db214bc-7a97-405d-b310-41e955dc9705:image.png)

![image.png](attachment:2753aa0d-9c1b-4c0d-8172-9fc5345262f2:image.png)

**메서드 정리**

- 인스턴스 메서드
    
    : 인스턴스의 상태를 변경하거나, 해당 인스턴스의 특정 동작을 수행
    
- 클래스 메서드
    
    : 인스턴스의 상태에 의존하지 않는 기능을 정의
    
    : 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행
    
- 스태틱 메서드
    
    : 클래스 및 인스턴스와 관련이 없는 일반적인 기능을 수행
    
- 인스턴스 → 인스턴스 메서드 사용 가능
- 클래스 → 클래스 메서드, 정적 메서드 사용 가능

![image.png](attachment:a421ef5b-eeaa-4916-8344-32f3b5bde61b:image.png)

![image.png](attachment:bf11a8d2-80e4-4b1a-bd25-795f8fc3be4f:image.png)

⇒ 할 수는 있지만 써도 되는 것은 아님! (각 목적에 맞게 사용)