## 250718

---

### [ChatGPT]

⇒ **G**enerative **P**re-trained **T**ransformer

- Generative AI(생성형 AI)

: 오디오, 비디오, 이미지, 텍스트, 코드, 시뮬레이션 등의 새로운 콘텐츠를 생성하는 인공지능 모델

→ 최근 언어 및 이미지 분석에서 큰 파급력을 보임

- Pre-trained

: 거대 언어 모델(LLM) + 추가 학습 데이터 + 추가 강화 학습

- Transformer

: 문장 속의 단어 간 관계를 추적해 맥락과 의미를 학습

: 인간처럼 일관되고 연관성이 높은 언어를 구사하여 대화형 작업에 강점

### Transformer 주요 개념

- Self-Attention 매커니즘

: 입력 데이터 간의 관계와 중요도를 계산

- 병렬 처리 가능

: RNN과 달리 순차 처리가 필요 없어 속도가 빠름

- 스케일링 가능

: 대규모 데이터 및 파라미터로 확장 가능

→ GPT 모델은 특히 Transformer의 **디코더** 부분만을 사용

### Attention 매커니즘

: AI가 데이터의 **맥락과 중요도**를 이해하도록 돕는 필수 기술

: 입력 데이터의 각 요소가 출력에 얼마나 중요한지 **중요도(weight)**를 계산하는 기법

: **”중요한 것에 집중한다”**는 아이디어를 바탕으로 설계됨

- Self-Attention : 입력 데이터 내부에서 각 요소 간 중요도를 계산
- Multi-Head Attention : 다양한 관심사를 병렬로 계산하여 성능 향

---

### [Interface]

: 서로 다른 두 개의 시스템(기기, 소프트웨어 등)이 정보를 교환할 때, 그 사이에 존재하는 접점

→ 사용자가 기기를 쉽게 동작 시키거나 기계와 기계가 통신할 때 필요한 ‘약속된 방식’

- 키보드, 마우스, 모니터

→ 컴퓨터와 사람 사이의 물리적 인터페이스

- TV 리모컨

→ TV와 사람 사이의 인터페이스

- 자동차 운전대, 페달

→ 자동차의 내부 장치와 운전자 사이를 연결

- 스마트폰 터치 스크린

→ 디지털 인터페이스

### UI(User Interface)

: 사람(사용자)이 소프트웨어에 접근하는 그래픽적, 화면적 요소

- ATM의 언어 선택 화면, 브라우저의 뒤로가기 버튼, 스마트폰 앱의 아이콘 등

: 실제로는 기계와 기계, 시스템과 시스템 사이에서도 수만은 ‘인터페이스’를 통해 정보를 주고받고 있음

: 여기서는 화면(UI)이 없을 뿐, 약속된 방식으로 데이터를 주고받음

⇒ **눈에 보이지 않는 영역에서도 수많은 통신이 이루어지고 있음**

### 웹의 동작 방식

![image.png](attachment:64ba81de-b812-41a8-951a-275253762f74:image.png)

- 클라이언트(Client) : 서비스를 요청하는 쪽

→ 사용자의 웹 브라우저, 모바일 앱 등

- 서버(Server) : 요청을 받아서 처리하고, 결과를 응답해주는 쪽

→ 웹 서버, 데이터베이스 서버 

Ex)

![image.png](attachment:c4c320b3-913d-4512-ac8b-a5f01e274d24:image.png)

: 사용자가 브라우저로 특정 주소(URL)를 요청

→ 서버가 해당 페이지, 데이터 등을 보내

---

### [API(Application Programming Interface)]

: 두 소프트웨어(또는 시스템)가 서로 통신할 수 있게 하는 매커니즘

→ **’약속된 방식의 인터페이스’**로, 특정 규칙에 따라 데이터를 요청하고 응답하는 규칙을 제

- Application : 특정 기능을 수행하는 모든 소프트웨어

→ 웹, 모바일, 데스크톱 앱 등 우리가 만든 서비스나 프로그램도 모두 앱의 일종

### API의 활용 예시

**(소셜 로그인)**

![image.png](attachment:34e28f9f-620d-4ad5-80a1-c0c4e69c81c2:image.png)

: Google 로그인 계정으로 로그인을 성공했을 경우 Google API는 ChatGPT에게 로그인에 성공한 인증된 사용자 정보를 넘겨줌

: 사용자 정보를 넘겨받은 ChatGPT는 해당 정보를 활용해 회원가입 및 로그인을 진행

**(날씨 앱)**

![image.png](attachment:7b7315c2-3c87-4af0-bd83-648e8797f193:image.png)

: 소프트웨어와 소프트웨어 간 지정된 정의(형식)으로 소통하는 수단 → API

: 스마트폰 날씨 앱은 기상청에서 제공하는 API를 통해 기상청 시스템과 대화하여 매일 최신 날씨 정보를 표시할 수 있음

---

### [API Key]

: API에게 요청을 보내는 애플리케이션을 구별하기 위한 고유한 식별 문자열

→ ex) abc123xyz456… 처럼 랜덤하게 생성된 키를 서버가 발급

### API Key 활용

![image.png](attachment:f1fbbcb3-a1bf-4287-b01b-5d5bca76a4f9:image.png)

1. Client가 날씨 API 사이트에서 회원 가입
2. 날씨 사이트에서 Client에게 API Key 발급
3. Client가 요청 시 발급 받은 API Key를 요청마다 함께 보냄
4. 요청 받은 Server는 Key를 검사해 인증 또는 인증 실패 여부를 결정하여 응답

### API Key가 필요한 이유

- 보안 강화

: 무단 접근을 막고 승인된 사용자(또는 앱)만 요청할 수 있게 함

- 데이터 관리

: API 호출 횟수, 사용량 모니터링

: 일정량 이상의 사용 시 제한 또는 과금 정책 사용 가능

### API Key 사용 시 주의사항

- 공개된 곳에 노출하지 말 것
- 키가 유출될 경우 무단 사용의 위험 → 정기 갱신이 필요
- 서버-클라이언트 구조에서 키를 안전하게 저장하는 방법들 고려

![image.png](attachment:188df6c1-bb46-49c2-8138-ec99a48f5cb4:image.png)

### 토큰

: GPT와 같은 인공지능 모델에서 **텍스트 데이터를 처리하고 이해하는 기본 단위**

: 토큰은 문장에서 단어로 생각할 수 있음

- 각 토큰별로 고유한 숫자가 매겨져있음
- 영어보다 한글 문장을 표현하는데 더 많은 토큰이 사용됨

### OpenAI API 주요 파라미터

**필수 파라미터**

- model : GPT 모델 이름(ex: gpt-4o-mini)
- messages : 대화 메시지 기록

**응답 다양성 제어**

- temperature : 다음 토큰(단어) 예측의 다양성 조정(0-2)

→ 응답의 창의성과 다양성 조정

- top-p : 선택할 토큰의 확률 범위를 제한(0-1)

→ 누적 확률 기반으로 응답의 범위 제

**temperature**

: 확률 분포를 날카롭거나 평탄하게 만드는 역할

: 높은 확률은 더 높게, 낮은 확률은 더 낮게 조정

: 모든 후보 단어의 확률을 조정하여 다양한 응답을 가능하게 함

![image.png](attachment:1c35d310-2e0c-42c9-91b4-458e519e7033:image.png)

**top-p**

: 확률 분포의 범위(상위 확률의 단어들만) 제한

: 누적 확률 기준으로 단어 후보의 수를 제한

: 응답의 신뢰성과 예측 가능성을 조정

![image.png](attachment:ded30bc1-4016-4abf-a2af-38dc118a4d44:image.png)

- 낮은 temperature + 높은 top-p

: temperature가 낮아 확률 분포의 차이가 더 강조 → 높은 확률의 단어에 집중

: top-p가 높아 누적 확률 범위가 높음 → 상위 확률 단어들을 다양하게 고려

⇒ 응답이 안정적이고 예측이 가능함

ex) 기술 문서 작성, 고객 지원

- 높은 temperature + 낮은 top-p

: temperature가 높아 확률 분포의 차이가 평탄해짐 → 다양한 단어가 선택될 가능성 증가

: top-p가 낮아 누적 확률 범위가 좁음 → 선택 후보가 제한적

⇒ 창의적이고 독창적인 응답

ex) 아이디어 도출, 소설 생성

**동작 흐름 요약**

: OpenAI 클라이언트를 초기화하고 API 키로 인증

: 대화의 기본 지침(system)과 사용자 질문(user)을 **conversation_history**에 추가

: OpenAI API에 **conversation_history**를 전달하여 **응답 생성**

: 생성된 응답 출력