## 251104

### [Objectives_ 학습 목표]

- SQL의 기본 문법 구조를 이해함
- CREATE TABLE문을 사용하여 테이블을 생성할 수 있음
- INSERT문을 활용하여 테이블에 데이터를 삽입할 수 있음
- SELECT문으로 테이블에서 원하는 데이터를 조회할 수 있음
- ALTER TABLE문을 통해 테이블 구조를 수정할 수 있음
- DROP TABLE문으로 테이블을 삭제할 수 있음
- UPDATE와 DELETE문으로 데이터를 수정하거나 삭제할 수 있음
- INNER JOIN과 LEFT JOIN의 차이점을 이해하고 사용할 수 있음
- 제약 조건(CONSTRAINT)의 의미를 알고 테이블 생성 시 적용할 수 있음

---

### [Build_ 이론]

### Managing Tables

**SQL Statements 유형**

![image.png](attachment:0294b3e9-bfbc-436e-9a26-5c536b1b0b34:image.png)

### CREATE TABLE

![image.png](attachment:8bf91a67-3267-462a-b7bf-d391bd9def9f:image.png)

: 각 필드에 적용할 데이터 타입 작성

: 테이블 및 필드에 대한 제약 조건(constraints) 작성

**CREATE TABLE 활용**

- examples 테이블 생성 및 확인
    
    ![image.png](attachment:d5fffbb4-f4bc-4140-9676-10479fefeb94:image.png)
    
- PRAGMA
    - 테이블 schema(구조) 확인
        
        ![image.png](attachment:a5753877-7fd3-4adb-94e8-574b923afc67:image.png)
        
    - cid
        
        : Column ID를 의미하며 각 컬럼의 고유한 식별자를 나타내는 정수 값
        
        : 직접 사용하지 않으며 PRAGMA 명령과 같은 메타데이터 조회에서 출력 값으로 활용됨
        

**CREATE TABLE Statement 구성**

- 데이터 타입
    
    ![image.png](attachment:9ea75598-c72a-4f00-9266-4348e6a6b85d:image.png)
    
- 제약 조건
    
    ![image.png](attachment:9430d4f6-d0da-4941-b10e-38d83dce1f16:image.png)
    
- AUTOINCREMENT 키워드
    
    ![image.png](attachment:8475305c-86bc-4851-87ba-ba67634f7dd0:image.png)
    

**SQLite 데이터 타입**

- NULL
    
    : 아무런 값도 포함하지 않음을 나타냄
    
- TEXT
    
    : 문자열
    
- INTEGER
    
    : 정수
    
- BLOB
    
    : 이미지, 동영상, 문서 등의 바이너리 데이터
    
- REAL
    
    : 부동 소수점
    

**Constraints_ 제약 조건**

: 테이블의 필드에 적용되는 규칙 또는 제한 사항

→ 데이터의 무결성을 유지하고 데이터베이스의 일관성을 보장

- 대표 제약 조건 3가지
    - PRIMARY KEY
        
        : 해당 필드를 기본 키로 지정
        
        : INTEGER 타입에만 적용되며 INT, BIGINT 등과 같은 다른 정수 유형은 적용되지 않음
        
    - NOT NULL
        
        : 해당 필드에 NULL 값을 허용하지 않도록 지정
        
    - FOREIGN KEY
        
        : 다른 테이블과의 외래 키 관계를 정의
        
- AUTOINCREMENT 특징
    - 필드의 자동 증가를 나타내는 특수한 키워드
    - 주로 primary key 필드에 적용
    - INTEGER PRIMARY KEY AUTOINCREMENT가 작성된 필드는 항상 새로운 레코드에 대해 이전 최대 값보다 큰 값을 할당
    - 삭제된 값은 무시되며 재사용할 수 없게 됨

### Modifying table fields

### ALTER TABLE

**ALTER TABLE 역할**

![image.png](attachment:b7eb1c0e-2f44-46b9-a6c9-889d11895585:image.png)

**ALTER TABLE ADD COLUMN**

![image.png](attachment:5f847732-328e-4a30-9207-d9354866471f:image.png)

: ADD COLUMN 키워드 이후 추가하고자 하는 새 필드 이름과 데이터 타입 및 제약 조건 작성

: 추가하고자 하는 필드에 NOT NULL 제약 조건이 있을 경우 NULL이 아닌 기본 값 설정 필요

- ALTER TABLE ADD COLUMN 활용
    - examples 테이블에 다음 조건에 맞는 Country 필드 추가
        
        ![image.png](attachment:5f7866c3-91f7-4d23-9216-8832954cb296:image.png)
        
        : 테이블 생성 시  정의한 필드는 기본 값이 없어도 NOT NULL 제약 조건으로 생성됨
        
        : 내부적으로 Default value는 NULL로 설정됨
        
        ![image.png](attachment:83f0c6ee-e876-4495-bf6f-e444c4e3bd41:image.png)
        
    - examples 테이블에 다음 조건에 맞는 Age, Address 필드 추가
        
        ![image.png](attachment:f48d9214-0162-469e-90d3-119ab18afadb:image.png)
        
        ![image.png](attachment:4bb3cb47-9ffe-4ca2-a0c3-53c3da6841e1:image.png)
        
        : SQLite는 단일문을 사용하여 한번에 여러 필드를 추가할 수 없음
        
        : 쿼리 실행 후 “PRAGMA table_info(’examples’);”를 통해 결과 확인
        

**ALTER TABLE RENAME COLUMN**

![image.png](attachment:3a09e000-23d2-4204-9a80-f57671770281:image.png)

: RENAME COLUMN 키워드 뒤에 이름을 바꾸려는 필드의 이름을 지정하고 TO 키워드 뒤에 새 이름을 지정

- ALTER TABLE RENAME COLUMN 활용
    - examples 테이블 Address 필드의 이름을 PostCode로 변경
        
        ![image.png](attachment:ecf8120e-cf2d-4dbc-af22-e6d9b366851f:image.png)
        
        ![image.png](attachment:a6794db3-c2cd-4476-b8d4-8f53248520be:image.png)
        

**ALTER TABLE DROP COLUMN**

![image.png](attachment:82794edf-555d-48a7-8893-08e4d5f56f31:image.png)

: DROP COLUMN 키워드 뒤에 삭제할 필드 이름 지정

- ALTER TABLE DROP COLUMN 활용
    - examples 테이블의 PostCode 필드를 삭제
        
        ![image.png](attachment:94812b2e-e335-4eeb-8b23-59270ef8b28b:image.png)
        
        ![image.png](attachment:26126c78-f704-4e07-8da8-f7a4e9178cd9:image.png)
        

**ALTER TABLE RENAME TO**

![image.png](attachment:e902c61a-915f-4479-af4c-fa96ff055e5e:image.png)

: RENAME TO 키워드 뒤에 새로운 테이블 이름 지정

- ALTER TABLE RENAME TO 활용
    - examples 테이블 이름을 new_examples로 변경
        
        ![image.png](attachment:1c7dc7d8-ab09-437a-9784-1adf49681da0:image.png)
        
        ![image.png](attachment:bc28c75b-3831-47b6-8e16-a0b212ffdcb7:image.png)
        

### Delete a table

### DROP TABLE

![image.png](attachment:5b6f49ad-660a-4334-a2ee-33f36ca70338:image.png)

: DROP TABLE statement 이후 삭제할 테이블 이름 작성

**DROP TABLE 활용**

- new_examples 테이블 삭제

![image.png](attachment:a45f4fc1-07f2-4351-81b8-a03c0a27ab35:image.png)

### Modifying Data

![image.png](attachment:ff2492de-d716-4dfe-ab91-b7331f0975f9:image.png)

### INSERT

**사전 준비**

- 생성하려는 테이블과 동일한 이름을 가진 테이블이 존재하는지 확인
- 불필요한 테이블이라면 DROP TABLE 명령어로 테이블 삭제
- 정상적으로 삭제되었는지 PRAGMA 화용하여 체크

![image.png](attachment:35b5d253-4b7a-4873-8c90-c0b805194dbc:image.png)

- 실습 테이블 생성

![image.png](attachment:1970a518-402d-4360-934c-a4c3eb304831:image.png)

![image.png](attachment:7d3f6b3a-279f-40a6-a600-cc0288365d79:image.png)

: INSERT INTO 절 다음에 테이블 이름과 괄호 안에 필드 목록 작성

: VALUES 키워드 다음 괄호 안에 해당 필드에 삽입할 값 목록 작성

**INSERT 활용**

- articles 테이블에 다음과 같은 데이터 입력
    
    ![image.png](attachment:efe084e5-25b2-40b8-857f-f6562f307bff:image.png)
    
    ![image.png](attachment:ed242655-3d59-4191-af3c-4eb093e92274:image.png)
    
    : 쿼리 실행 후 “SELECT * FROM articles;”를 통해 결과 확인
    
- articles 테이블에 다음과 같은 데이터 추가 입력
    
    ![image.png](attachment:e0a9e144-2a45-49ec-96a4-c30b6d38f0ec:image.png)
    
    ![image.png](attachment:c2f2d723-e67e-4b3d-a2e6-a664328d16da:image.png)
    
    : 쿼리 실행 후 “SELECT * FROM articles;”를 통해 결과 확인
    
- DATE 함수를 사용해 articles 테이블에 다음과 같은 데이터 추가 입력
    
    ![image.png](attachment:75671926-1c71-4d55-b1db-d20da785e355:image.png)
    
    ![image.png](attachment:b3901757-9fcb-4c72-a0c1-9eb9edfac3f7:image.png)
    
    : 쿼리 실행 후 “SELECT * FROM articles;”를 통해 결과 확인
    

### Update data

### UPDATE

![image.png](attachment:e956b9bd-cd2c-413d-82f6-72a4db8ca026:image.png)

: SET 절 다음에 수정할 필드와 새 값을 지정

: WHERE 절에서 수정할 레코드를 지정하는 조건 작성

: WHERE 절을 작성하지 않으면 모든 레코드를 수정

**UPDATE 활용**

- articles 테이블 1번 레코드의 title 필드 값을 ‘update Title’로 변경
    
    ![image.png](attachment:e95c6575-c3cb-419c-9174-129e6ed3be3c:image.png)
    
    ![image.png](attachment:e0250ee3-7c03-47e1-9399-3d21f3188dff:image.png)
    
- articles 테이블 2번 레코드의 title, content 필드 값을 각각 ‘update Title’, ‘update Content’로 변경
    
    ![image.png](attachment:3dc05f6c-a9ce-4879-8773-e91d0622781f:image.png)
    
    ![image.png](attachment:041828b6-7f7f-4913-a409-d6d4065ae335:image.png)
    

### Delete data

### DELETE

![image.png](attachment:bcbdfaec-b506-43a8-a37c-5b5d90137104:image.png)

: DELETE FROM 절 다음에 테이블 이름 작성

: WHERE 절에서 삭제할 레코드를 지정하는 조건 작성

: WHERE 절을 작성하지 않으면 모든 레코드를 삭제

**DELETE 활용**

- articles 테이블의 1번 레코드 삭제
    
    ![image.png](attachment:9ddb30ce-2a83-454a-9efc-e3ca77b5c43e:image.png)
    
    ![image.png](attachment:f18dc735-3b90-4a7d-a738-b8500f512ec7:image.png)
    
    : 쿼리 실행 후  “SELECT * FROM articles;”를 통해 결과 확인
    
- articles 테이블에서 작성일이 오래된 순으로 레코드 2개 삭제
    
    ![image.png](attachment:cf9ed419-8ace-48de-9165-b57451384d5b:image.png)
    
    ![image.png](attachment:0aafcc47-ce89-4a76-9dbb-579bd14de0c7:image.png)
    
    ![image.png](attachment:5c7d6851-cc2e-4f2e-b24f-5adb2ba714e5:image.png)
    
    : 쿼리 실행 후  “SELECT * FROM articles;”를 통해 결과 확인
    

### Multi table queries

### JOIN

**관계의 필요성**

- 커뮤니티 게시판에 필요한 데이터 생각해보기
    
    ![image.png](attachment:8b556f26-c5de-4665-9e7e-cad66e450a60:image.png)
    
- ‘하석주’가 작성한 모든 게시글을 조회하기
- 어떤 문제가 있을까?
    
    → 동명이인이 있다면 혹은 특정 데이터가 수정된다면?ㄴ
    
    ![image.png](attachment:87ad067a-ae3c-4524-8ef7-6e5c5c65a28a:image.png)
    
- 테이블을 나누어서 분류하기
    
    ![image.png](attachment:0b2d9e0a-0177-4d6a-90bd-69066655a69a:image.png)
    
- articles와 users 테이블에 각각 userId, roleId 외래 키 필드 작성
    
    ![image.png](attachment:1e625600-39b5-47ef-8971-41c88536f4ba:image.png)
    
    - 관리자인 사람만 보고싶다면? → roleId가 1인 데이터 조회
    - 하석주라는 사람이 권미숙으로 개명한다면? → users에서 한 번만 변경하면 자동으로 모두 변경

**JOIN이 필요한 순간**

: 테이블을 분리하면 데이터 관리는 용이해질 수 있으나 출력 시에는 문제가 있음

: 테이블 한 개만을 출력할 수 밖에 없어 다른 테이블과 결합하여 출력하는 것이 필요해짐

→ 이때 사용하는 것이 ‘JOIN’

**테이블을 나누는 이유?**

- 중복을 줄이고, 수정, 삭제가 쉬워지도록 하기 위함(ex : 사용자 정보와 주문 정보는 분리)
- 화면에서는?
    - 사용자 이름과 주문 내용을 함께 보여줘야 하는 상황이 많음
    - 이럴 땐 다시 테이블을 묶어야 하는데 그 방법이 바로 JOIN

**사전 준비**

- 생성하는 테이블과 동일한 이름을 가진 테이블이 존재하는지 확인
- 불필요한 테이블이라면 DROP TABLE 명령어로 테이블 삭제
- 정상적으로 삭제되었는지 PRAGMA 활용하여 체크
    
    ![image.png](attachment:7bbc09c6-d35f-4762-9603-823b0e7fb86c:image.png)
    
    - 동일한 결과 확인을 위해 articles TABLE 삭제 필수!
- users 및 articles 테이블 생성
    
    ![image.png](attachment:e7423212-2dfa-4b33-9b7c-b384e53d0f39:image.png)
    
- 각 테이블에 실습 데이터 입력
    
    ![image.png](attachment:cf3b8e84-3fec-46a4-bcf9-47ca0c0d1745:image.png)
    

### INNER JOIN

![image.png](attachment:d645f410-7b1f-4d51-b226-9099400bbe43:image.png)

![image.png](attachment:3a1515ab-494f-4d45-8710-b0b810543a61:image.png)

: FROM 절 이후 메인 테이블 지정(table_a)

: INNER JOIN 절 이후 메인 테이블과 조인할 테이블을 지정(table_b)

: ON 키워드 이후 조인 조건을 작성

: 조인 조건은 table_a와 table_b 간의 레코드를 일치시키는 규칙을 지정

**INNER JOIN 예시**

- 작성자가 있는 (존재하는 회원) 모든 게시글을 작성자 정보와 함께 조회
    
    ![image.png](attachment:7347ff30-6e6f-409e-b924-638dd134263b:image.png)
    
    ![image.png](attachment:acd09775-00f2-449f-addf-eb33385e20e2:image.png)
    

**INNER JOIN 활용**

- 1번 회원(하석주)가 작성한 모든 게시글의 제목과 작성자명을 조회
    
    ![image.png](attachment:3532676b-f90d-4f14-89a6-622c302b0cc2:image.png)
    

### LEFT JOIN

![image.png](attachment:f9b1a5f9-1bdf-4479-ad19-9b09f87f747b:image.png)

![image.png](attachment:ce3dbeff-e0cf-4c1a-ba71-b039a312a06b:image.png)

: FROM 절 이후 왼쪽 테이블 지정(table_a)

: LEFT JOIN 절 이후 오른쪽 테이블 지정(table_b)

: ON 키워드 이후 조인 조건을 작성

→ 왼쪽 테이블의 각 레코드를 오른쪽 테이블의 모든 레코드와 일치시킴

**LEFT JOIN 예시**

- 모든 게시글을 작성자 정보와 함께 조회
    
    ![image.png](attachment:24232a5e-dbad-4897-be67-412019131dcc:image.png)
    

**LEFT JOIN 특징**

- 왼쪽 테이블의 모든 레코드를 표기
- 오른쪽 테이블과 매칭되는 레코드가 없으면 NULL을 표시
    - LEFT JOIN = 왼쪽 테이블 기준으로 다 보여줘!
        - 왼쪽 테이블의 모든 레코드는 무조건 출력
        - 오른쪽 테이블에 연결된 값이 없으면 NULL로 표시
    - 왜 필요할까?
        - 어떤 데이터가 없는지 확인하고 싶을 때 유용함
        - ex : 회원 중 아직 주문을 안 한 사람 찾기

**LEFT JOIN 활용**

- 게시글을 작성한 이력이 없는 회원 정보 조회
    
    ![image.png](attachment:4b1a538d-b226-45da-8579-c3b1e78b970a:image.png)
