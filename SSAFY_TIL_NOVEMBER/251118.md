## 251118

### [Objectives_ 학습 목표]

- 원시 자료형과 참조 자료형의 차이점을 설명할 수 있음
- 동등(==) 연산자와 일치(===) 연산자의 차이를 앎
- for … in과 for … of 반복문의 차이와 용도를 앎
- 함수 선언식과 표현식의 차이를 알고 함수를 정의함
- 화살표 함수 표현식을 사용하여 간결하게 함수를 정의함
- 나머지 매개변수와 전개 구문을 함수에 활용할 수 있음
- 템플릿 리터럴을 사용해 변수를 포함한 문자열을 만듦

---

### [Build_ 이론]

### 데이터 타입

**원시 자료형(Primitive type)**

- 값(value) 자체가 변수에 직접 저장되는 자료형
- 불변(immutable)이며, 변수 간 할당 시 값이 복사
- Number, String, Boolean, null, undefined

**참조 자료형(Reference type)**

- 데이터가 저장된 메모리의 주소가 변수에 저장되는 자료형
- 가변(mutable)이며, 변수 간 할당 시 주소가 복사
- Objects(Object, Array, Function)

→ 참조 자료형은 주소를 복사하므로, 복사본을 수정하면 원본의 값도 함께 변경될 수 있어 주의해야 함

→ 값이 불변이라는 것은 값의 일부를 직접 수정할 수 없다는 의미임

→ (let str = ‘ssafy’; str[0] = ‘S’;)처럼 할당하는 것은 불가능

**원시 자료형 예시**

- 변수에 할당될 때 값이 복사됨
    
    → 변수 간에 서로 영향을 미치지 않음
    
    ![image.png](attachment:df65607c-e615-4930-bd20-5131a1037339:image.png)
    

**참조 자료형 예시**

- 객체를 생성하면 객체의 메모리 주소를 변수에 할당
    
    → 변수 간에 서로 영향을 미침
    
    ![image.png](attachment:09f1706c-8c47-4c54-b6d3-7f9092ab6887:image.png)
    

### 원시 자료형

**Number**

: 정수 또는 실수형 숫자를 표현하는 자료형

: 사칙연산 및 나머지 연산 가능

: 문자열과 + 연산 시, 숫자가 문자열로 자동으로 형 변환되어 연결

: 정수와 실수 구분이 없고, 모든 숫자를 단일 타입으로 처리

![image.png](attachment:1deffe14-a876-409f-a3a6-b104148a5022:image.png)

**String**

: 텍스트 데이터를 표현하는 자료형

: ‘+’ 연산자를 사용해 문자열끼리 결합

: 뺄셈, 곱셈, 나눗셈 불가능

![image.png](attachment:99120998-52a0-4a18-8991-8bdf5b5d8bdf:image.png)

**Template literals(템플릿 리터럴)**

- 내장된 표현식을 허용하는 향상된 문자열 저장 방식
- Backtick(``)을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고, JavaScript의 변수를 문자열 안에 바로 연결할 수 있음
- 표현식은 ‘$’와 중괄호({expression})로 표기
- ES6+부터 지원

![image.png](attachment:fda586ff-7976-4494-a702-8aa6443b7db5:image.png)

**null**

: 프로그래머가 의도적으로 **‘값이 없음’**을 나타낼 때 사용

![image.png](attachment:0e3b078b-5ace-4cf6-ac79-d5cbfaf6d095:image.png)

**undefined**

: 시스템이나 JavaScript 엔진이 **‘값이 할당되지 않음**’을 나타낼 때 사용

![image.png](attachment:bc0804d2-2592-4ee1-8431-2c8de80dbbc8:image.png)

→ ‘null’의 타입은 ‘object’, ‘undefined’의 타입은 ‘undefined’이므로 타입 검사 시 주의!

→ return이 없는 함수나, 인자가 전달되지 않은 매개변수는 기본적으로 undefined가 할당됨

→ 산술 연산 시 ‘null’은 0으로 취급되지만, ‘undefined’는 계산 불가능한 NaN 값을 만듦

**Boolean**

: 참과 거짓을 나타내는 논리적인 자료형

: 조건문 또는 반복문에서 Boolean이 아닌 데이터 타입은 “자동 형변환 규칙”에 따라 true 또는 false로 변환됨

- 자동 형 변환
    
    ![image.png](attachment:0af4bc2e-edc1-4bf4-9975-94c9c141fdc4:image.png)
    

### 연산자

**할당 연산자**

: 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 할당하는 연산자

: 단축 연산자 지원

![image.png](attachment:28a46cd1-8194-499e-b0a4-ec41b22f29d1:image.png)

**증가 & 감소 연산자**

- 증가 연산자(’++’)
    
    : 피연산자를 증가(1을 더함)시키고 연산자의 위치에 따라 증가하기 전이나 후의 값을 반환
    
- 감소 연산자(’—’)
    
    : 피연산자를 감수(1을 뺌)시키고 연산자의 위치에 따라 감소하기 전이나 후의 값을 반환
    

→ 코드의 가독성을 위해 a += 1, a -= 1과 같이 더 명시적인 표현을 권장

![image.png](attachment:0e3141f5-dc1d-4c5f-8c1b-4768a554c7e8:image.png)

**비교 연산자**

: 피연산자들(숫자, 문자, Boolean 등)을 비교하고 결과 값을 boolean으로 반환하는 연산자

![image.png](attachment:a931fe01-2987-48ca-b4c6-bc5a76904771:image.png)

**동등 연산자(==)**

: 두 연산자가 같은 값으로 평가되는지 비교한 후 boolean 값을 반환

: ‘암묵적 타입 변환’을 통해 타입을 일치시킨 후 같은 값인지 비교

: 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별

![image.png](attachment:b0407f41-6506-4f48-8207-7419d393fcfc:image.png)

→ 0 == flase, ‘’ == []가 true가 되는 등, 직관과 다른 암묵적 타입 변환이 일어나므로 주의!

→ 내용이 같아도 다른 객체이면 false임, [1] == [1]은 false이므로 주의!

**일치 연산자(===)**

: 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환

: 같은 객체를 가리키거나 같은 타입이면서 같은 값인지를 비교

: 엄격한 비교가 이루어지며, 암묵적 타입 변환이 발생하지 않음

: 특별한 경우를 제외하고는, 예측하지 못한 결과를 방지하기 위해 일치 연산자(===) 사용을 권장

![image.png](attachment:a0779ea2-ffe5-4706-9829-64c7997d5b4d:image.png)

**논리 연산자**

- and 연산 : &&
- or 연산 : ||
- not 연산 : !
- 단축 평가 지원

![image.png](attachment:ccfc2e84-46f7-4b23-a3a6-44332f330a74:image.png)

### 조건문_ if

: 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단

![image.png](attachment:6e7062e6-effa-4484-b2a1-a4f1d2cc1aa1:image.png)

**삼항 연산자**

: 간단한 조건부 로직을 간결하게 표현할 때 유용

: 복잡한 로직이나 대다수의 경우에는 가독성이 떨어질 수 있으므로 적절한 상황에서만 사용할 것

- condition
    
    : 평가할 조건(true 또는 false로 평가)
    
- expression1
    
    : 조건이 true일 경우 반환할 값 또는 표현식
    
- expression2
    
    : 조건이 false일 경우 반환할 값 또는 표현식
    
    ![image.png](attachment:f283f937-d877-4eed-846f-189f88eb9c6a:image.png)
    
    → condition ? expression1 : expression2
    

### 반복문

**while**

: 조건문이 참이면 문장을 계속해서 수행

![image.png](attachment:1573c159-026b-466f-92fb-09e017fee8b0:image.png)

**for**

: 특정한 조건이 거짓으로 판별될 때까지 반복

![image.png](attachment:ae07dea3-0c65-4f90-aa7d-0bec03776897:image.png)

- for 동작 원리
    
    ![image.png](attachment:2eaa8804-267c-41d0-ba08-ebe8c3ebdca7:image.png)
    

**for … in**

: 객체의 열거 가능한(enumerable) 속성(property)의 키(key)에 대해 반복

![image.png](attachment:8d486615-ab30-461e-854c-c40fe2412c60:image.png)

**for … of**

: 반복 가능한(iterable) 객체(배열, 문자열 등)의 값(value)에 대해 반복함

![image.png](attachment:bae1834b-036d-48c7-923b-327032cb8f48:image.png)

**for … in과 for … of**

- for … in
    
    : 배열과 객체
    
    ![image.png](attachment:d95d3561-1c03-464a-baf3-7f3bd8962fd1:image.png)
    
- for … of
    
    : 배열과 객체
    
    ![image.png](attachment:26af3275-b866-4afe-aaf8-2b37c3a0f83a:image.png)
    
- 배열 반복과 for … in
    - 객체의 관점에서 보면, 배열의 인덱스도 “정수 형태의 이름을 가진 열거 가능한 속성”
    - for … in은 정수가 아닌 이름과 속성을 포함하여 열거 가능한 모든 속성르 반환
    - 내부적으로 for … in은 배열의 반복자가 아닌 속성 열거를 사용하기 때문에 특정 순서에 따라 인덱스를 반환하는 것을 보장할 수 없음
    
    → for … in은 인덱스의 순서가 중요한 배열에서는 사용하지 않음
    
    → 배열에서는 for문, for … of를 사용
    
    - 객체 관점에서 배열의 인덱스는 정수 이름을 가진 속성이기 때문에 인덱스가 출력됨(순서 보장X)
        
        ![image.png](attachment:485617f7-0a42-4566-8a3c-20e3bce5a703:image.png)
        
    
    → for … in은 배열을 값이 아닌 인덱스를, 숫자도 아닌 ‘문자열’로 반환하므로 주의!
    
    → 배열의 프로토타입에 추가된 속성까지 순회할 수 있어, 예기치 않은 버그를 유발할 수도 있음
    
- 반복문 사용 시 const 사용 여부
    - for문
        
        :  for (let i = 0; i < arr.length; i++) {…}의 경우에는 최초 정의한 i를 “재할당”하면서 사용하기 때문에 const를 사용하면 에러 발생
        
    - for … in, for … of
        
        : 재할당이 아니라, 매 반복마다 다른 속성 이름이 변수에 저장되는 것이므로 const를 사용해도 에러가 발생하지 않음
        
        : 단, const 특징에 따라 블록 내부에서 변수를 수정할 수 없음
        

![image.png](attachment:951340dd-9529-431f-8e74-4b6aa105d4eb:image.png)

### 함수

**Function**

: 참조 자료형에 속하며 모든 함수는 Function object

**함수 구조**

![image.png](attachment:506a5930-14b4-491a-9824-9bf2208ab535:image.png)

- function 키워드
- 함수의 이름
- 함수의 매개변수
- 함수의 body를 구성하는 statements
    
    → return문이 없거나 return 뒤에 값이 없으면 함수는 undefined를 반환함
    

**함수 정의 2가지 방법**

1. 선언식(function declaration)
    
    ![image.png](attachment:91f40c99-409e-4815-b4ae-856f197e60df:image.png)
    
    ![image.png](attachment:37d77ac3-bebf-41cc-9497-d572be28bc5e:image.png)
    
2. 표현식(function expression)
    
    ![image.png](attachment:94b5500e-85f9-46b9-ad36-c3341177b834:image.png)
    
    ![image.png](attachment:4688c2f5-d96a-499c-9f21-c14f184cfc2b:image.png)
    

**함수 선언식 특징**

- 호이스팅 됨
- 코드의 구조와 가독성 면에서는 표현식에 비해 장점이 있음
    
    ![image.png](attachment:48c653cf-e275-496c-a3f7-1608a42ad9a4:image.png)
    
    - 호이스팅
        
        : 자바스크립트 엔진이 코드 실행 전 변수와 함수 선언을 스코프 최상단으로 끌어올리는 동작 방식
        
        : 선언식으로 된 함수는 선언 전에 호출하는 것이 가능해짐
        

**함수 표현식 특징**

- 호이스팅되지 않음
    
    → 변수 선언만 호이스팅되고 함수 할당은 실행 시점에 이루어짐
    
- 함수 이름이 없는 ‘익명 함수’를 사용할 수 있음
    
    ![image.png](attachment:126b9405-ac65-4708-a511-e0f9eb02d64e:image.png)
    

**함수 표현식 사용을 권장하는 이유**

- 예측 가능성
    
    : 호이스팅의 영향을 받지 않아 코드 실행 흐름을 더 명확하게 예측할 수 있음
    
- 유연성
    
    : 변수에 할당되므로 함수를 값으로 다루기 쉬움
    
- 스코프 관리
    
    : 블록 스코프를 가지는 let이나 const와 함께 사용하여 더 엄격한 스코프 관리가 가능
    

### 매개변수

**기본 함수 매개변수(Default function parameter)**

: 함수 호출 시 인자를 전달하지 않거나 undefined를 전달할 경우, 지정된 기본값으로 매개변수를 초기화

![image.png](attachment:b68c5a74-de36-4d47-a751-916b7004bd94:image.png)

**나머지 매개변수(Rest paramenter)**

: 정해지지 않은 개수의 인자들을 배열로 모아서 받는 방법

: 작성 규칙

- 함수 정의 시 나머지 매개변수는 하나만 작성할 수 있음
- 나머지 매개변수는 함수 정의에서 매개변수 마지막에 위치해야 함
    
    ![image.png](attachment:827354b3-131c-4d89-81b4-110f12cdfb50:image.png)
    

**매개변수와 인자 개수가 불일치 할 때**

- 매개변수 개수 > 인자 개수
    
    → 누락된 인자는 undefined로 할당
    
    ![image.png](attachment:63fc63be-c830-4b0a-81e8-d1dc8f68ac01:image.png)
    
- 매개변수 개수 < 인자 개수
    
    → 초과 입력한 인자는 사용하지 않음
    
    ![image.png](attachment:61149807-7c06-4de6-8d56-39d225515df6:image.png)
    

### Spread syntax

**spread syntax ‘…’**

- 전개 구문
- 배열이나 문자열처럼 반복 가능한(iterable) 항목들을 개별 요소로 펼치는 것
- 전개 대상에 따라 역할이 다름
    
    → 배열이나 객체의 요소를 개별적인 값으로 분리하거나 다른 배열이나 객체의 요소를 현재 배열이나 객체에 추가하는 등
    

**전개 구문 활용처**

1. 함수와의 사용
    1. 함수 호출 시 인자 확장
        
        ![image.png](attachment:5dabc451-72a1-468e-9857-e2e71beb8ecc:image.png)
        
    2. 나머지 매개변수(압축)
        
        ![image.png](attachment:9b94b713-b8f2-4d29-9e01-fe67210d45a6:image.png)
        
2. 객체와의 사용(객체 파트에서 진행)
3. 배열과의 활용(배열 파트에서 진행)

### 화살표 함수 표현식_ Arrow function expressions

: 함수 표현식의 간결한 표현법

![image.png](attachment:705d3e17-7911-4ab6-9562-220a88dfdc7b:image.png)

**화살표 함수 작성 과정**

1. function 키워드 제거 후 매개변수와 중괄호 사이에 화살표(⇒) 작성
    
    ![image.png](attachment:71eea461-6cf7-4bbd-86a9-30399a84e896:image.png)
    
2. 함수의 매개변수가 하나 뿐이라면, 매개변수의 ‘()’ 제거 가능(단, 생략하지 않는 것을 권장함)
    
    ![image.png](attachment:7fdad273-bdd3-43e4-a702-9f3adf8db56a:image.png)
    
3. 함수 본문의 표현식이 한 줄이라면, ‘{}’와 ‘return’ 제거 가능
    
    ![image.png](attachment:96c75950-5f37-416e-a6e3-9193ab6788d5:image.png)
    

---

### 참고

**NaN을 반환하는 예시**

1. 숫자로서 읽을 수 없음(Number(undefined))
2. 결과가 허수인 수학 계산식(Math.sqrt(-1))
3. 피연산자가 NaN(7 ** NaN)
4. 정의할 수 없는 계산식(0 * Infinity)
5. 문자열을 포함하면서 덧셈이 아닌 계산식(’가’ / 3)

→ NaN은 자기 자신과 비교해도 False가 나오는 유일한 값임(NaN === NaN // False)

→ NaN은 ‘숫자가 아님’이라는 뜻이지만, 타입을 확인하면 ‘number’가 반환됨

**null & undefined_ ‘값이 없음’에 대한 표현이 2가지인 이유**

1. 역사적 맥락
    1. JavaScript가 처음 만들어질 때, null은 ‘객체가 없음’을 나타내기 위해 도입
    2. undefined는 나중에 추가되어 ‘값이 할당되지 않음’을 나타내게 됨