## 251119

### [Objectives_ 학습 목표]

- 객체의 메서드 안에서 this를 사용해 속성에 접근함
- 화살표 함수에서 this가 상위 스코프를 참조함을 앎
- 구조 분해 할당을 사용해 객체의 속성을 변수로 할당함
- JSON.stringify와 JSON.parse로 객체와 JSON을 변환함
- 콜백 함수를 이해하고 다른 함수의 인자로 전달할 수 있음
- forEach와 map 메서드의 차이를 알고 배열을 순회함
- 전개 구문을 이용하여 원본 배열을 수정하지 않고 합침

---

### [Build_ 이론]

### 객체_ Object

: 키로 구분된 데이터 집합을 저장하는 자료형(data collection)

### 구조 및 속성

**객체 구조**

- 중괄호(’{}’)를 이용해 작성
- 중괄호 안에는 key : value 쌍으로 구성된 속성(property)를 여러 개 작성 가능
- key는 문자형만 허용
- value는 모든 자료형 허용

![image.png](attachment:994ef056-aa8a-466f-920a-2ddd993f8973:image.png)

**속성 참조**

- 점(’.’) 표기법 또는 대괄호(’[]’) 표기법으로 객체 속성에 접근
- key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능
    
    ![image.png](attachment:d798fc1c-8c8c-4316-ad81-33638f8ec40d:image.png)
    

**’in’ 연산자**

- 속성이 객체에 존재하는지 여부를 확인
- 객체의 키나 배열의 인덱스 존재 여부를 확인하는 연산자
    
    ![image.png](attachment:904b0978-a9cb-4319-b3dd-efe2cde28973:image.png)
    
    - 객체에서 값의 포함 여부를 확인하려면 ‘in’ 연산자 대신 ‘hasOwnProperty()’ 메서드를 사용하는 것이 올바름
    - 프로토타입 체인을 따라 상속된 속성까지 확인하므로, 의도치 않게 true가 나올 수 있어 주의해야함

### 메서드_ Method

![image.png](attachment:53fbc0e9-6b3f-49ae-b5c1-ff9b7ab3c000:image.png)

: 객체 속성에 정의된 함수

: object.method() 방식으로 호출

: 메서드는 객체가 ‘행동’할 수 있게 함

**Method 기본 문법**

- 메서드도 값이 함수인 속성

![image.png](attachment:bc577855-bc65-44ee-bd6f-d640ac5113e2:image.png)

- 메서드와 일반 함수의 차이?
    
    → 메서드는 자신이 속한 객체의 다른 속성들에 접근할 수 있음
    
    → 이를 위한 방법이 **this**
    

### this

: 함수나 메서드를 호출한 객체를 가리키는 키워드

: ‘this’ 키워드를 사용해 객체에 대한 특정하 작업을 수행할 수 있음

**Method & this 사용 예시**

![image.png](attachment:58876fad-1fba-4dcd-898b-1419bda74138:image.png)

**JavaScript에서 this는 함수를 “호출하는 방법”에 따라 가리키는 대상이 달라짐**

![image.png](attachment:816a75da-68c8-425c-b5a9-16722f489fed:image.png)

**단순 호출 this**

- 가리키는 대상 ⇒ 전역 객체
    
    ![image.png](attachment:9862483a-0c42-4cc4-83bc-c85c5258b504:image.png)
    

**메서드 호출 시 this**

- 가리키는 대상 ⇒ 메서드를 호출한 객체
    
    ![image.png](attachment:cb836c09-fd1d-4e2d-a226-7e0270caa8ef:image.png)
    

**중첩된 함수에서의 this 문제점**

- forEach의 인자로 전달된 콜백 함수는 일반 함수로 호출되므로, this는 전역 객체를 가리킴
    
    ![image.png](attachment:c96b5c58-22ba-4976-9fe2-00d89cb8a497:image.png)
    
- 해결책
    - 화살표 함수는 자신만의 this를 가지지 않음
    - 외부 함수(myFunc)에서의 this 값을 가져옴
        
        ![image.png](attachment:c7ff0298-d08a-49f3-ad92-2dd32d818811:image.png)
        

**JavaScript ‘this’ 정리**

- JavaScript의 함수는 호출될 때 this를 암묵적으로 전달 받음
- JavaScript에서 this는 함수가 “호출되는 방식”에 따라 결정되는 현재 객체를 나타냄
- Python의 self와 Java의 this가 선언 시점에 이미 값이 정해지는 것과 달리 JavaScript의 this는 함수가 호출될 때 동적으로 결정
- 장점
    
    : 함수(메서드)를 하나만 만들어 여러 객체가 공유하여 각자 자신의 데이터로 동작하게 할 수 있음
    
- 단점
    
    : 이런 유연함이 실수로 이어질 수도 있음
    

### 추가 객체 문법

**단축 속성**

: 키 이름과 값으로 쓰이는 변수의 이름이 같은 경우 단축 구문을 사용할 수 있음

![image.png](attachment:d3f19a7b-e1f9-42fc-a8ba-af52233d6d99:image.png)

**단축 메서드**

: 메서드 선언 시 function 키워드 생략 가능

![image.png](attachment:6d3be8dd-ef67-486b-a43a-d9a44c1de82c:image.png)

**계산된 속성(computed property name)**

: 키가 대괄호([])로 둘러싸여 있는 속성

→ 고정된 값이 아닌 변수 값을 사용할 수 있음

![image.png](attachment:393a520b-76ba-4452-9598-2c71820217b7:image.png)

- 대괄호 안의 표현식이 너무 복잡해지면, 어떤 키가 생성될 지 파악하기 어려워 가독성이 떨어질 수 있음
- 동적으로 키를 만들다 보면 의도치 않게 같은 이름의 키가 생성되어, 기존 값이 덮어써질 위험이 있음

**구조 분해 할당(destructing assignment)**

: 배열 또는 객체를 분해하여 객체 속성을 변수에 쉽게 할당할 수 있는 문법

![image.png](attachment:569a1b36-eb88-4f1b-9c1c-40fe751c0010:image.png)

: ‘함수의 매개변수’로 객체 구조 분해 할당 활용 가능

![image.png](attachment:f58859f4-6973-42fb-b865-795e5ee80aca:image.png)

**객체와 전개 구문(Spread Syntax, …)**

- 객체 복사
    
    : 객체 내부에서 객체 전개
    
- 얕은 복사에 활용 가능
    
    ![image.png](attachment:d882c3d0-76b9-44ab-bd6f-46bddaf8f76e:image.png)
    

**유용한 객체 메서드**

- Object.keys()
    
    : Object의 Key 값들을 리스트로 반환
    
- Object.values()
    
    : Object의 Value 값들을 리스트로 반환
    
- Object.entries()
    
    : Object의 Key와 Value 값들을 한 쌍으로 묶은 리스트로 반환
    
    ![image.png](attachment:bf17186e-eebd-4fb5-8be5-b99e9e4f8f7f:image.png)
    

**Optional chaining(’?.’)**

: 속성이 없는 중첩 객체에 접근하려 할 때 에러 발생 없이 안전하게 접근하는 방법

: 만약 참조 대상이 null 또는 undefined라면 에러가 발생하는 것 대신 평가를 멈추고 undefined를 반환

![image.png](attachment:5497f7a3-26f8-4706-8929-4cca6a754540:image.png)

- 장점
    - 참조가 누락될 가능성이 있는 경우 연결된 속성으로 접근할 때 더 짧고 간단한 표현식을 작성할 수 있음
    - 어떤 속성이 필요한지에 대한 보증이 확실하지 않은 경우에 객체의 내용을 보다 편리하게 탐색할 수 있음
    - 만약 Optional chaining을 사용하지 않는다면 다음과 같이 ‘&&’ 연산자를 사용해야 함
        
        ![image.png](attachment:b9da95eb-6d21-47a9-8853-e82534fb728d:image.png)
        
- 주의사항
    - Optional chaining은 존재하지 않아도 괜찮은 대상에만 사용해야 함(남용X)
        - 왼쪽 평가대상이 없어도 괜찮은 경우에만 선택적으로 사용
        - 중첩 객체를 에러 없이 접근하는 것이 사용 목적이기 때문
        
        ![image.png](attachment:6721479f-caf6-422d-bae5-7550af5f3129:image.png)
        
    - Optional chaining 앞의 변수는 반드시 선언되어 있어야 함
        
        ![image.png](attachment:5c69f211-190c-45ea-bb13-6ad04c691f66:image.png)
        
- 정리
    - obj?.prop
        
        : obj가 존재하면 obj.prop을 반환하고, 그렇지 않으면 undefined를 반환
        
    - obj?.[prop]
        
        : obj가 존재하면 obj[prop]을 반환하고, 그렇지 않으면 undefined를 반환
        
    - obj?.method()
        
        : obj가 존재하면 obj.method()를 호출하고, 그렇지 않으면 undefined를 반환
        
    
    → null과 undefined일 때만 동작함
    
    → 체인 중간이 null인 경우 그 뒤의 코드는 실행되지 않음 → ‘단락 평가’
    

### JSON_ JavaScript Object Notation

: Key-Value 형태로 이루어진 자료 표기법

: JavaScript의 Object와 유사한 구조를 가지고 있지만 JSON은 일정한 형식을 가진 “문자열”임

: JavaScript에서 JSON을 사용하기 위해서는 Object 자료형으로 변경해야 함

: 특정 언어에 종속되지 않는 데이터 형식으로, API 통신 등에서 널리 사용됨

**Object → JSON**

: JSON.stringfy()를 사용해 객체를 문자열로 변환

![image.png](attachment:5ecf31c4-1f76-4f81-a609-9218347f0c73:image.png)

**JSON → Object**

: JSON.parse()를 사용해 문자열을 객체로 변환

![image.png](attachment:ae22913c-2c91-4ac4-aba4-c27a25c8a225:image.png)

### 배열_ Array

: 순서가 있는 데이터 집합을 저장하는 자료 구조

: 객체는 키(Key)로 데이터를 관리하지만, 순서가 중요하지 않음

: ‘첫 번째’, ‘두 번째’처럼 순서가 중요한 데이터 묶음이 필요할 때 사용하는 것이 바로 “순서가 있는 컬렉션, 배열(Array)”임

: 배열의 인덱스는 숫자로만 이루어져 있어, “키 자체가 데이터의 의미를 설명해주지 못하고”, 특정 값을 찾기 위해서는 배열의 모든 요소를 “처음부터 순서대로 확인”해야 하는 단점이 있음

**배열 구조**

: 대괄호(’[]’)를 이용해 작성

: 요소의 자료형은 제약 없음

: length 속성을 사용해 배열에 담긴 요소 개수 확인 가능

![image.png](attachment:f906420e-6cdb-4717-b38b-d0481dc79aa1:image.png)

### 배열 메서드

**push()**

: 배열 끝에 요소를 추가

: 원본 배열을 직접 추가

: 반환 값 - 추가된 후의 새로운 배열의 길이

![image.png](attachment:34e9860b-130f-4d69-92ac-37bedd50d87b:image.png)

**pop()**

: 배열 끝 요소를 제거

: 원본 배열을 직접 수정

: 반환 값 - 제거한 요소

![image.png](attachment:7e692ffc-cf83-4137-8064-706067080b77:image.png)

**unshift()**

: 배열 앞에 요소를 추가

: 원본 배열을 직접 수정

: 반환 값 - 추가된 후의 새로운 배열의 길이

: 배열의 모든 요소를 뒤로 한 칸씩 밀어야 하므로, 배열이 클수록 성능이 저하(가급적 사용 X)

![image.png](attachment:4d250eca-c340-4766-af18-74673b1ce943:image.png)

**shift()**

: 배열 앞 요소를 제거하고, 제거한 요소를 반환

: 원본 배열을 직접 수정

: 반환 값 - 제거한 요소