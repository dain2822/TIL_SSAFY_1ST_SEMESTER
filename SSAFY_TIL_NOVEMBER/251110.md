## 251110

### [Objectives_ 학습 목표]

- N : M 관계가 필요한 상황을 파악하고, Django에서 이를 어떻게 구현하는지 이해함
- ManyToManyField의 기본 동작과 주요 속성들을 설명할 수 있음
- ‘through’를 활용한 중개 모델 설계법을 습득함
- 좋아요 기능 구현을 통해 관계 설정과 역참조 충돌 해결법을 배움
- Django 모델 설계 시 실무적인 관계 구성 능력을 향상시킴

---

### [Build_ 이론]

### Many to many relationships_ 다대다 관계

**⇒ N : M or M : N**

: 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우

: 영화와 배우처럼 한쪽의 여러 개가 다른 쪽의 여러 개와 연결되는 복잡한 관계를 말함

: 다대다 관계를 설정하면, 한 영화에 여러 배우를 추가하거나, 한 배우가 출연한 모든 영화를 쉽게 찾아낼 수 있음

**M : N 관계의 역할과 필요성 이해하기**

- ‘병원 진료 시스템 모델 관계’를 직접 만들어 보기
    - 환자와 의사 2개의 모델을 사용하여 모델 구조 구상
- 기존의 N : 1 구조로 환자와 의사 테이블을 구성했을 때 어떤 한계가 있는지 확인
- N : M 관계는 어떻게 데이터베이스에서 관리하는지 확인

### N : 1의 한계

**의사와 환자 간 모델 관계 설정**

- 한 명의 의사에게 여러 환자가 예약할 수 있도록 models 클래스 정의
    - Patient(환자) 모델에 Doctor 모델을 참조하도록 정의
- Migration까지 진행하여 데이터베이스에 적용
    
    ![image.png](attachment:1264ec0c-90f9-4734-bde1-f75804ef9594:image.png)
    

**의사와 환자 데이터 생성**

- Django shell을 활용하여 2명의 의사를 생성
    
    ![image.png](attachment:aa37d3ab-4474-432a-acf2-d7a8cae2009f:image.png)
    
- Django shell을 활용하여 2명의 환자를 생성하고 환자는 서로 다른 의사에게 예약
    
    ![image.png](attachment:41897b09-5ee4-476e-a904-9bdbf09abe24:image.png)
    

**N : 1의 한계 상황**

- 1번 환자(Carol)가 두 의사 모두에게 진료를 받고자 하면 환자 테이블에 1번 환자 데이터가 중복으로 입력될 수 밖에 없음
    
    ![image.png](attachment:6357e73d-b557-4d23-b2d3-be0a550f4b89:image.png)
    
- 환자가 진료가 받을 의사  정보를 동시에 저장을 시도했을 때는 에러가 발생함
    
    ![image.png](attachment:165f5e1f-4c18-49b7-b3c6-61b54f17e232:image.png)
    
- 동일한 환자지만 다른 의사에게도 진료를 받기 위해 새로운 예약 데이터를 만들어야 하며 이때 동일한 환자 정보를 또 작성하여 저장됨
    
    → 데이터의 중복이 발생하면 나중에 환자의 정보가 바뀌었을 때, 모든 예약 정보를 하나씩 찾아 고쳐야 하는 문제가 발생하고, 실수로 하나라도 누락한다면 데이터의 일관성이 깨지게 됨
    
- 외래 키 컬럼에 ‘1, 2’ 형태로 저장하는 것은 DB 타입 문제로 불가능
    
    → 제 1정규형을 만족하지 못하기 때문에 사용이 불가함
    
- 의사의 정보도 외래 키로 참조하고, 환자의 정보도 외래 키로 참조하는 별개의 테이블을 만든다면 위에 언급된 문제를 해결할 수 있게 됨
    
    → 즉, “예약 테이블을 따로 만들자”
    

### 중개 모델

: 다대다 관계에서 두 모델을 연결하는 역할을 하는, 특별한 기능을 가진 모델

: 의사와 환자가 ‘예약’이라는 관계로 연결될 때, 단순히 ‘의사 A와 환자 B가 연결됐다’는 사실 외에 ‘언제 예약했는지’, ‘예약의 상태는 무엇인지’ 같은 정보를 함께 저장하는 모델임

: 중개 모델을 사용하면 Doctor 모델이나 Patient 모델에 없는 예약 행위 자체에 대한 상세한 정보를 담을 수 있어 복잡한 현실 세계의 관계를 더욱 정교하게 표현할 수 있음

**예약 모델 생성**

- 환자 모델의 외래 키를 삭제하고 별도의 예약 모델을 새로 생성
- 예약 모델은 의사와 환자에 각각 N : 1 관계를 가짐
    
    ![image.png](attachment:e3de1acb-3b0d-4f32-bd5f-4453e7dfc683:image.png)
    

**예약 데이터 생성**

- 데이터베이스 초기화 후 Migration 진행 및 shell 실행
- 의사와 환자 데이터 생성 후 예약 정보 추가하기
    
    ![image.png](attachment:7d130c9b-e4d6-4b4c-9563-b0e7a0ac0df1:image.png)
    

**예약 정보 조회**

- 의사와 환자가 예약 모델을 통해 각각 본인의 진료 내역 확인
    - 각각의 의사 혹은 환자 데이터에서 중개 테이블의 역참조를 통해 예약 내역을 확인할 수 있음ㄴ
    
    ![image.png](attachment:8debdb10-e85a-491b-8d30-fcb988bc3288:image.png)
    

**추가 예약 생성**

- 1번 의사에게 새로운 환자 예약 생성
    
    ![image.png](attachment:e1127a23-473b-4070-929d-f94635a575ea:image.png)
    

**예약 정보 조회**

- 1번 의사의 전체 예약 정보 조회
    - 예약 테이블의 역참조를 활용해서 어떤 예약이 있는지 확인할 수 있음
    
    ![image.png](attachment:f8fa4ba4-7a35-4561-adaf-0e5fe3e4c69b:image.png)
    
- 다대다 관계(Many to many relationship)의 경우 중개 테이블을 생성해서 데이터를 효율적으로 관리할 수 있음
- Django에서는 ‘ManyToManyField’를 통해 두 모델 간의 중간 테이블(중개 모델)이 자동으로 만들어짐

### ManyToManyField()

: M : N 관계 설정 모델 필드

: Django는 자동으로 중간 테이블(중개 모델)을 생성하여 각 모델 간의 관계를 관리함

: 모델 클래스 내부에 필드로 정의하며, 어느 모델에 정의해도 관계는 동일하게 유지됨

: ManyToManyField의 필드명은 다대다 관계를 나타내기 위해 복수형으로 작성을 권장함

: ManyToManyField의 필수 인자는 관계를 가지는 모델 클래스를 작성함

**ManyToManyField 조작**

- .add() 메서드
    
    : 중개 테이블에 새로운 데이터를 추가할 때 사용
    
    : 인자로 연결할 대상 모델의 인스턴스를 넣어서 사용
    
    ![image.png](attachment:96e52038-5af1-4664-aa3d-1c54f6b0a290:image.png)
    
- .remove() 메서드
    
    : 중개 테이블에 있는 데이터를 삭제할 때 사용
    
    : 인자로 전달한 인스턴스를 중개 테이블에서 제거하며, 대상 객체 자체는 삭제되지 않음
    
    ![image.png](attachment:798eba60-e80f-440b-8790-da5768a72895:image.png)
    

**Django ManyToManyField 실습**

- 환자 모델에 ManyToManyField 작성
    
    : 의사 모델에 작성해도 상관 없으며 참조/역참조 관계만 잘 기억할 것
    
    → 환자 모델은 의사 모델을 참조하며, 의사 모델은 역참조를 통해 환자 모델에 접근
    
    ![image.png](attachment:8a49a9cc-ff8b-484d-8610-df97af7f30a8:image.png)
    
- 데이터 베이스 초기화 후 Migration 진행 및 shell 실행
- 생성된 중개 테이블 hospitals_patient_doctors 확인
    
    : 중개 테이블 이름은 ‘앱이름_모델클래스명_필드명’으로 생성됨
    
    ※ 필드가 아닌 테이블이 생성됨
    
    ![image.png](attachment:8903d14f-0e69-47a0-b7e8-89e6cc1ba865:image.png)
    
- 의사 1명과 환자 2명에 대한 데이터 생성
    
    ![image.png](attachment:843dc035-ea7d-4a30-9067-839511fd4b89:image.png)
    
- 환자 1의 예약에 의사 1을 추가하고 예약 내역 조회하기
    - 환자의 경우 클래스 내부에 필드를 가지고 있어 참조로 조회
    - 의사의 경우 역참조를 통해 환자 데이터 조회
    
    ![image.png](attachment:8e81850e-ab3a-4c8e-9bb6-d2775da67f0b:image.png)
    
- 의사 1이 환자 2에 대한 예약을 추가하고 예약 내역 조회하기
    - 의사는 역참조 매니저를 통해 환자를 추가할 수 있음
    
    ![image.png](attachment:3fd9e377-d32e-4875-9d4e-72578b696266:image.png)
    
- 중개 테이블(hospitals_patient_doctors)에서 예약 현황 확인
    - 환자와 의사 정보가 외래키로 저장되어 있음을 확인
    - 데이터의 중복 없이 정보를 효율적으로 저장하고 있음
    
    ![image.png](attachment:e20e0d4c-cfb8-4939-b4ac-56aecb7f7050:image.png)
    
- 예약 취소하기(삭제)
- 이전에는 Reservation을 찾아서 지워야 했다면, 이제는 .remove()로 삭제 가능
    
    ![image.png](attachment:fc78eefb-8d74-456b-b720-b9db648fd970:image.png)
    

**기본 ManyToManyField의 한계**

- 기본 ManyToManyField로 생성된 예약 중개 테이블은 의사와 환자의 외래키 정보만 저장하고 있음
- 만약 예약 중개 테이블에 병의 증상, 예약 일정, 방문 횟수에 대한 추가 정보가 필요한 경우, 기본 ManyToManyField를 그대로 사용할 수 없음
- 추가 정보를 저장하기 위해서는 사용자가 직접 중개 테이블을 정의해야 함
    - 사용자가 직접 중개 테이블을 정의하면, .add(), .remove()에 메서드를 사용할 수 없음
- ManyToManyField에 ‘through’ 속성을 통해 사용자가 작성한 중개 테이블을 등록하면 추가 정보 저장 및 .add(), .remove() 메서드를 그대로 활용할 수 있게 됨

### ‘through’ argument

: 중개 테이블에 ‘추가 데이터’를 사용해 M : N 관계를 형성하려는 경우에 사용

**’through’ 속성 실습**

- Reservation Class 재작성 및 through 설정
    - 예약 정보에 ‘증상(symptom)’과 ‘예약일(reserved_at)’이라는 추가 필드가 생김
    
    ![image.png](attachment:6393df32-901d-4614-928d-381f29b28967:image.png)
    
- 데이터베이스 초기화 후 Migration 진행 및 shell 실행
- 의사 1명과 환자 2명 생성

![image.png](attachment:ce23a7b7-20db-4604-a9bc-fac536778c63:image.png)

![image.png](attachment:135c7465-262b-4f4d-875e-cad15527ae03:image.png)

- 예약 생성 방법_ 1
    
    : Reservation class를 통한 예약 생성
    
    ![image.png](attachment:ea29f2e3-504d-4868-aa80-1af22cac44f4:image.png)
    
- 예약 생성 방법_ 2
    
    : Patient 또는 Doctor의 인스턴스를 통한 예약 생성(through_defaults)
    
    : .add() 메서드의 through_defaults 인자에 {필드명:값} 형태로 전달하면 중개 모델의 해당 필드에 값이 저장됨
    
    ![image.png](attachment:6354469d-0afe-4c65-a14f-d69b812ae6b2:image.png)
    
- 중개 테이블(hospitals_reservation)에 생성된 예약 정보 확인
    - 두 방법 모두 중개 테이블에 잘 저장되었음을 확인
    
    ![image.png](attachment:0f212e50-fc77-48bc-a726-4ac4e1f8d842:image.png)
    
- 생성과 마찬가지로 의사와 환자 모두 각각 예약 삭제 가능
- 직접 중개 테이블의 인스턴스를 활용한 삭제
    
    ![image.png](attachment:2ec17dfd-4482-4798-8a1e-fa141d9b23cf:image.png)
    
    → 중개 테이블을 통한 삭제는 delete 메서드 사용
    
- 의사 데이터를 통해 환자와의 예약 삭제
    
    ![image.png](attachment:17333830-ed83-4bd5-8abf-49d8f2cf4d61:image.png)
    
    → 환자 데이터를 통해서도 동일하게 예약 삭제 가능
    

**M : N 관계 주요 사항 정리**

- M : N 관계로 맺어진 두 테이블에는 물리적인 변화가 없음
- ManyToManyField는 중개 테이블을 자동으로 생성
- ManyToManyField는 M : N 관계를 맺는 두 모델 어디에 위치해도 상관 없음
    - 대신 필드 작성 위치에 따라 참조와 역참조 방향을 주의할 것
- N : 1은 완전한 종속의 관계였지만 M : N은 종속적인 관계가 아니며 ‘의사에게 진찰받는 환자’ & ‘환자를 진찰하는 의사’ 이렇게 2가지 형태 모두 표현 가능

**ManyToManyField 특징**

**ManyToManyField(to, **options)**

: M : N 관계 설정 시 사용하는 모델 필드

: 어느 모델에서든 관련 객체에 접근할 수 있는 양방향 관계

: 동일한 관계는 한 번만 저장되며 중복되지 않음

**ManyToManyField의 대표 인자 3가지**

1. related_name
    
    : 역참조 이름을 변경할 때 설정하는 인자
    
2. symmetrical
    
    : 관계 설정 시 대칭에 대한 설정을 하는 인자
    
3. through
    
    : 직접 생성한 중개 테이블을 등록하는 인자
    

**’related_name’ argument**

: 역참조 시 사용하는 manager name을 변경

- 기본 값인 ‘역참조모델명_set’을 다른 이름으로 변경할 때 사용
- 이름을 변경하면 더 이상 기본 값(’역참조모델명_set’)을 사용할 수 없음

![image.png](attachment:c7fd4e38-ee4c-4459-a303-37e6087e2cbc:image.png)

**‘symmetrical’ argument**

: 관계 설정 시 대칭 유무 설정

: ManyToManyField가 동일한 모델을 가리키는 정의에서만 사용

: 기본 값 - True

![image.png](attachment:5811abb2-ffdd-4e7e-804f-90e0068988f4:image.png)

- source 모델 : 관계를 시작하는 모델
- target 모델 : 관계의 대상이 되는 모델
- symmetrical 값이 True인 경우
    - source 모델의 인스턴스가 target 모델의 인스턴스를 참조하면 자동으로 target 모델 인스턴스도 source 모델 인스턴스를 자동으로 참조하도록 함(대칭)
    
    → 즉, 내가 당신의 친구라면 자동으로 당신도 내 친구가 됨
    
- symmetrical 값이 False인 경우
    
    → True와 반대(대칭되지 않음)
    

: 사용하고자 하는 중개 모델을 지정

: 일반적으로 ‘추가 데이터를 M : N 관계와 연결하려는 경우’에 활용

![image.png](attachment:d6de23df-858b-4a99-ae50-f2184b3e25b4:image.png)

### 모델 관계 설정

**다대다 관계 설정_ Many to many relationships**

: 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우

→ 양쪽 모두에서 N : 1 관계를 가짐

**좋아요 기능의 모델 관계 설정**

- Article(M) - User(N)
    - 게시글은 좋아요가 없을 수도 있고, 여러 개 존재할 수도 있음
    - 사용자도 게시글에 좋아요를 한 번도 누르지 않았을 수도 있고, 여러 개의 게시글에 좋아요를 누를 수 있음
- Article 클래스에 ManyToManyField 작성
    - 필드명은 직관적이고 복수형으로 작성
    
    ![image.png](attachment:48ce2ae0-8942-4385-97fd-fb01124c0b98:image.png)
    
- Migration 진행 시 에러 발생 확인
    - 유저가 게시글을 역참조 할 때 역참조 이름에 대한 충돌이 발생하고 있음
    
    ![image.png](attachment:16b312e5-4286-48db-b9fc-b7a42ed49c0d:image.png)
    

**역참조 매니저 충돌**

- 게시글의 작성자 저장 위해 설정한 ForeignKey의 역참조
    - ‘유저가 작성한 게시글’을 확인하기 위해서는 ‘article_set’를 사용해야 함
    - user.article_set.all()
- 좋아요 기능을 위해 작성한 ManyToManyField의 역참조
    - ‘유저가 좋아요 한 게시글’을 확인하기 위해서는 ‘article_set’을 사용해야 함
    - user.article_set.all()
- ‘article_set’의 역참조 이름이 겹치게 되어 충돌이 발생하고 있음
- User와 Article 모델 사이에 ForeignKey(작성자)와 ManyToManyField(좋아요) 두 관계가 공존하면서 ‘article_set’이라는 역참조 이름이 충돌하여 어떤 데이터에 접근해야 하는지 알 수 없게 됨
- ‘user가 작성한 글(user.article_set)’과 user가 좋아요를 누른 글(user.article_set)’을 구분할 수 있도록 코드 수정이 필요함
    
    → 두 관계 중 하나에 related_name을 설정해야 하는데 일반적으로 ManyToManyField쪽에 related_name을 추가하는 것을 권장
    

**M : N 관계를 바꾸는 것이 더 좋은 이유 2가지**

1. ‘소유’ 관계의 기본값 유지
    - ForeignKey(1:N) 관계는 보통 ‘소유’나 ‘소속’의 의미를 가짐(ex : 게시글의 소유자는 유저)
    - Django의 기본 역참조 이름인 ‘article_set’은 ‘User가 소유한 Article의 집합’이라는 매우 직관적인 의미로 해석됨
    - 가장 중요하고 대표적인 관계의 기본값을 그대로 유지하는 것이 코드의 예측 가능성을 높임
2. ‘행위’ 관계의 명시적 표현
    - ManyToManyField(M:N) 관계는 보통 ‘참여’나 ‘행위’의 의미를 가짐(ex : 유저가 게시글에 ‘좋아요를 누르는’ 행위)
    - 이 관계에 related_name=’like_articles’처럼 행위의 의미가 드러나는 구체적인 이름을 붙여주면, 코드의 가독성이 크게 향상됨

**충돌 해결하기**

- user.article_set.all()
    
    : “이 유저가 작성한 모든 글” (소유 관계, 기본)
    
- user.like_articles.all()
    
    : “이 유저가 좋아요를 누른 모든 글” (행위 관계, 명시적)
    

⇒ 핵심적인 ‘소유’ 관계(N:1)는 기본값을 유지하고, 부가적인  ‘행위’ 관계(M:N)에 구체적인 이름을 붙여주는 것으로 설계하기

- related_name 작성 후 Migrations 재진행
    
    ![image.png](attachment:dfd22c41-7487-487b-9c85-4ab52891e1c0:image.png)
    
- 생성된 중개 테이블 확인
    
    ![image.png](attachment:f913cbd9-55cb-4345-bddb-309c72cbd686:image.png)
    

**User - Article간 사용 가능한 전체 related manager**

- article.user
    
    : 게시글을 작성한 유저 - N:1
    
- user.article_set
    
    : 유저가 작성한 게시글(역참조) - N:1
    
- article.like_users
    
    : 게시글을 좋아요 한 유저 - M:N
    
- user.like_articles
    
    : 유저가 좋아요 한 게시글(역참조) - M:N
    

### 기능 구현

**좋아요 기능 구현**

- 좋아요 기능을 담당할 URL 등록
    - 어떤 게시글에 좋아요가 눌렸는지 정보를 전달하기 위해 ‘게시글 pk’ 정보를 varialble routing으로 추가
    
    ![image.png](attachment:f594cc5a-4bf7-479d-8270-3f2500430460:image.png)
    
- view 함수 구현
    - 사용자가 게시글의 좋아요 목록에 있으면 좋아요 취소(사용자 정보 삭제)
    - 사용자가 게시글의 좋아요 목록에 없으면 좋아요 추가(사용자 정보 추가)
    
    ![image.png](attachment:4569669a-38f1-4fff-b17e-bdb469883629:image.png)
    
- index 템플릿에서 각 게시글에 좋아요 버튼 출력
    - 좋아요 버튼의 value도 현재 상태에 따라 다르게 출력하도록 코드 작성
    
    ![image.png](attachment:7bffd6b9-8290-4c57-9dcf-1b8f14bfd0fc:image.png)
    
- 좋아요 버튼 출력 및 동작 확인
    - 좋아요 버튼을 누를 때마다 버튼의 텍스트가 변경되는지 확인
    
    ![image.png](attachment:25c9aeb3-94c8-45c9-b818-0a8a0c0715c8:image.png)
    
- 좋아요 버튼 클릭 후 테이블 확인
    
    ![image.png](attachment:f22b9e00-9a3d-4b34-b1a1-5680c10f7217:image.png)