## 251105

### [Objectives_ 학습 목표]

- Django의 Many to One 모델 관계를 이해하고 정의할 수 있음
- ForeignKey를 활용한 관계형 모델 구축 방법을 실습할 수 있음
- Django shell을 이용해 댓글 데이터를 생성하고 관계를 확인할 수 있음
- CREATE/READ/DELETE 기능을 사용해 댓글 기능을 Django 프로젝트에 구현할 수 있음
- 역참조를 통해 관계 모델에서 데이터를 효율적으로 조회할 수 있음
- admin 페이지에서 댓글 관리를 수행할 수 있음
- for-empty 문법을 활용해 사용자 경험을 개선할 수 있음

---

### [Build_ 이론]

### 모델 관계

**관계_ Relationship**

: 데이터베이스 내 여러 테이블 간의 논리적인 연결 관계를 나타냄

: 데이터베이스에 ‘강사’, ‘학생’ 두 테이블이 있을 때 ‘이삼성 강사가 김싸피 학생을 가르치고 있다.’는 정보를 저장하려면 두 테이블 간의 관계(relationship)를 설정해야 함

→ 한 테이블에 다른 테이블의 기본 키(Primary Key)를 저장하며, 이처럼 다른 테이블의 기본 키를 참조하는 속성을 외래 키(Foreign Key)라고 함

→ 외래 키는 두 테이블 간의 논리적인 연결 고리 역할을 하며, 이를 통해 관계형 데이터베이스에서 연관된 데이터를 효율적으로 관리할 수 있음

**관계의 종류**

- 1 : 1 (One to One) 관계
    
    : 한 테이블의 레코드는 다른 테이블의 한 레코드와 연결됨
    
    ex) 한 사람당 하나의 주민등록번호
    
- N : 1 (Many to One) 관계
    
    : 여러 개의 레코드가 하나의 레코드와 연결됨
    
    ex) 여러 교육생(N)을 한 강사(1)가 가르침
    
- N : M (Many to Many) 관계
    
    : 여러 레코드가 여러 레코드와 상호 연결됨
    
    : 보통 중간 테이블(ex : 수강신청)을 사용해 구현됨
    
    ex) 여러 학생(N)이 여러 과목(M)을 수강함
    

![image.png](attachment:03cc0817-e790-44d6-9875-ca5809d6aaa5:image.png)

**Many to one realtionships_ N:1 or 1:N**

: 한 테이블의 0개 이상의 레코드가 다른 테이블의 레코드 한 개와 관련된 관계

**Many to one relationships 예시**

- SSAFY Track : Student
    
    → 1 : N
    
    : 하나의 트랙에는 여러 명의 교육생이 포함됨
    
    : 한 명의 교육생은 트랙이 중복되어서는 안 됨
    

- Order : Customer
    
    → N : 1
    
    : 한 명의 고객이 여러 주문 가능
    
    : 하나의 주문을 여러 명의 고객이 낼 수 없음
    

- Account : Bank
    
    → N : 1
    
    : 하나의 계좌는 한 은행에만 소속되어 있음
    
    : 한 은행은 여러 개의 계좌를 가질 수 있음
    

- Country : City
    
    → N : 1
    
    : 하나의 국가에는 여러 도시를 가짐
    
    : 한 도시가 중복된 국가에 포함되지 않음
    

- Baseball Team : Member
    
    → 1 : N
    
    : 한 팀에 여러 명의 선수가 소속됨
    
    : 한 선수가 다른 야구 팀에 소속될 수 없음
    

- Movie : Actor
    
    → N : M
    
    : 영화에 여러 배우들이 출연 가능함
    
    : 배우도 여러 영화에 출연 가능함
    
- Comment : Article
    
    → N : 1
    
    : 하나의 게시글에는 여러 개의 댓글이 달림
    
    : 단, 게시글에 댓글이 없는 경우도 존재함
    
    : 댓글이 소속된 게시글이 없는 경우는 없음
    
    ⇒ 0개 이상의 댓글은 1개의 게시글에 작성될 수 있음
    

**테이블 관계 설정**

: 관계 설정을 위한 Foreign Key(외래 키, FK)를 N : 1에서 1을 담당하는 테이블에 위치하면 안 됨

- Article Table에 Foreign Key 컬럼을 위치시키면 중복 데이터로 인해 낭비가 발생함
    
    ![image.png](attachment:14dd88d3-cf63-44be-a024-b20e344931ab:image.png)
    
    → 댓글 생성마다 Comment의 정보와 함께 Article 정보(id, title, content, …)가 매번 중복 저장됨
    

: 관계 설정을 위한 Foreign Key(외래 키, FK)의 위치는 바로 N : 1에서 N을 담당하는 테이블에 위치

- Comment가 생성되면 Article의 정보만 저장하면 됨
    
    ![image.png](attachment:f9eb4023-5761-4e47-a49e-c1644259b056:image.png)
    
    → 외래 키 컬럼에 저장되는 데이터는 참조하는 데이터를 대표하는 Primary Key(PK) 정보를 저장함
    

### 댓글 모델 정의

**ForeignKey(to, on_delete)**

: 한 모델이 다른 모델을 참조하는 관계를 설정하는 필드

: N : 1 관계 표현할 때 사용

: 데이터베이스에서 외래 키로 구현됨

- to 속성
    
    : 참조하는 모델 class 이름(N : 1에서 N이 아닌 1의 class 정보)
    
- on_delete 속성
    
    : 외래 키가 참조하는 객체(1)가 사라졌을 때, 외래 키를 가진 객체(N)를 어떻게 처리할 지를 정의하는 설정(데이터 무결성)
    

→ to와 on_delete 속성은 ForeignKey 설정에 필수 요소

**on_delete 속성 종류**

- CASCADE
    
    : 참조된 객체(부모 객체)가 삭제될 때 이를 참조하는 모든 객체도 삭제되도록 지정
    
    ex) 게시글이 삭제되면 해당 게시글의 모든 댓글을 삭제
    
- PROTECT
    
    : 삭제하려는 부모 객체에 자식 객체가 존재한다면 해당 부모 객체를 삭제하지 못하도록 지정
    
    ex) 게시글을 삭제할 때 해당 게시글에 댓글이 존재하면 게시글 삭제 불가
    
- SET_NULL
    
    : 부모 객체가 삭제되면, 해당 필드에 값이 NULL이 저장되도록 지정
    
    : 단, 해당 ForeignKey필드 설정이 null = True가 설정되어야 함
    

**댓글 모델 정의하기**

: ForeignKey 클래스의 인스턴스 이름은 참조하는 모델 클래스 이름의 단수형으로 작성하는 것을 권장

![image.png](attachment:70288df1-d44f-4019-aab1-a5c5d0023573:image.png)

- 단수형으로 이름을 권장하는 이유
    - 단일 객체를 참조하므로, 속성명을 단수명으로 작성하면 의미가 명확해짐
    - 코드 작성시 문맥이 자연스러움

**Migration 이후 댓글 테이블 확인**

- 만들어지는 필드 이름 규칙
    
    : ‘작성한 외래 키 필드명’ + ‘_’ + ‘id’
    
- 댓글 테이블의 article_id 외래 키 필드 확인
    
    : bigint 자료형 확인
    

→ 참조하는 클래스 이름의 소문자(단수형)로 작성하는 것이 권장되었던 이유

![image.png](attachment:b96ce4c1-afe3-47b1-85d1-5394bb3ca38b:image.png)

→ 외래 키는 models.py의 클래스 내에 ForeignKey 필드를 작성하는 순서와 관계없이 테이블의 마지막 필드로 생성됨

- bigint 자료형
    
    : 64비트 정수형으로 약 9경까지 저장할 수 있음
    
    : 숫자의 고갈이 없어 Primary Key(PK)를 선언할 때 해당 자료형을 사용함
    
    : 외래 키는 이러한 PK 정보를 저장하기 때문에 동일하게 해당 자료형 사용
    

### 댓글 생성 연습

**댓글 생성 연습 준비하기**

- 연습을 위한 shell 환경에서 진행
- ipython 설치 필요 `$ pip install ipython`
- django shell 시작 후 댓글 작성을 위한 게시글을 하나 작성

![image.png](attachment:9da12abf-c01a-4fa3-a459-a2320819e3b2:image.png)

**댓글 생성 연습**

- 댓글 생성 후 바로 저장 확인
    
    ![image.png](attachment:fa76a8a4-0912-4bd9-9f99-ae18a5f757fa:image.png)
    
    → 현재 어떤 게시글이 작성되는 댓글인지 저장된 댓글 데이터에 게시태
    
- 게시글 정보를 가져와 댓글 저장
    
    ![image.png](attachment:26391eda-7857-4035-8fda-c65c2089248e:image.png)
    
    - article_id에 직접 PK를 넣는 것을 권장하지 않는 이유
        
        : 직접 객체를 할당하는 경우는 저장될 객체 타입을 에러 발생 유무를 통해 명확히 검증할 수 있음
        
        : 직접 PK를 입력하는 경우에는 숫자를 저장하기 때문에 잘못된 객체의 PK 값이 저장될 수 있음
        
        ex) comment.article_id = [book.pk](http://book.pk)    # 잘못된 정보지만 에러 발생 X
        
- comment 인스턴스를 통한 article 값 참조하기
    
    ![image.png](attachment:b1abd07b-98c1-4148-a346-368033d4cd6a:image.png)
    
    → article_pk는 존재하지 않는 필드이기 때문에 사용 불가
    
- comment를 통한 article 객체의 데이터 참조하기
    
    ![image.png](attachment:fc8b3bde-2089-48f6-9f9c-47bb3fbe60b8:image.png)
    
- 두 번째 댓글 생성 및 데이터 확인
    
    ![image.png](attachment:82c3976d-345d-44fe-8c6b-aef8a1eabc20:image.png)
    

### 관계 모델 참조

**참조의 정의**

: 직접 대상의 정보를 저장하고 필요할 때 활용하는 것

→ 마치 “내가 친구의 전화 번호를 저장”하는 것과 같음

→ 내가 전화 번호를 가지고 있어 언제든지 친구에게 전화나 문자를 할 수 있음

→ 댓글(Comment)에는 게시글(Article) 정보를 저장하는 ForeignKey 필드인 article이 존재하며, 해당 필드를 통해 게시글 정보에 쉽게 접근할 수 있음

⇒ 댓글(Comment)은 게시글(Article)을 참조한다고 말함

ex) 댓글의 게시글 내용에 접근 : `comment.article.content`

**특정 게시글(Article)의 댓글(Comment) 정보 조회하기**

- QuerySet API의 .all() 사용하기 X
    - 특정 게시글(Article)의 댓글(Comment)들이 아닌 모든 댓글 정보를 가져오게 됨
        
        ![image.png](attachment:a7b48008-30d5-4ac9-a87f-58a7ff731776:image.png)
        
- QuerySet API의 .filter() 사용하기
    - 특정 게시글(Article) 정보를 조회 후 댓글(Comment)에서 filter를 활용해 댓글 조회 가능
        
        ![image.png](attachment:8ed7414f-a607-4547-bbaa-fe3d571f4305:image.png)
        

### 역참조

: 누가 나를 참조하는지 거꾸로 조회하는 것

→ 마치 “내 번호를 저장한 사람들이 누구인지 찾는 것”과 비슷함

→ 직접적으로 정보를 가지고 있지 않고 반대로 확인해야 하기 때문에 참조하는 것을 거꾸로 찾아야하며 이를 역참조라고 부름

→ 게시글(Article) 입장에서는 연결된 댓글(Comment) 정보를 담는 필드가 존재하지 않음

→ 해당 글을 참조하고 있는 댓글(Comment)들을 역으로 찾아야 하며 Django에서는 이런 관계를 자동으로 추적해서 해당 게시글(Article)에 달린 댓글(Comment)를 쉽게 찾아올 수 있도록 역참조 기능을 제공함

**역참조 기본 구조**

![image.png](attachment:c2bb9716-1ea1-4e96-a9d4-4d5a9429f28e:image.png)

1. 모델 인스턴스(article)
    
    : models.py에 정의된 모델 클래스로 생성된 실제 데이터를 의미
    
    → ‘article.title’과 같이 속성에 접근 가능하며 속성을 수정할 수 있음
    
    : 역참조에서는 참조 가능한 필드가 없는 모델 클래스의 인스턴스를 사용하면 됨
    
    → Article(1) : Comment(N) ⇒ Article에 참조 필드가 없어서 Article의 인스턴스를 사용
    
    ⇒ 특정 게시글에 작성된 댓글 전체를 조회하는 요청
    
2. related manage(역참조 이름 / comment_set)
    
    : related manager라고 부르며 N : 1 혹은 N : M관계에서 역참조 시에 사용하는 매니저를 의미
    
    : ‘objects’ 매니저를 통해 QuerySet API를 사용했던 것처럼 related manager를 통해 QuerySet API를 사용할 수 있게 됨
    
    ⇒ 특정 게시글에 작성된 댓글 전체를 조회하는 요청
    
3. QuerySet API(all())
    
    : 데이터를 가져오기 위한 쿼리 결과 집합을 만드는 인터페이스
    
    : SQL 쿼리를 직접 쓰지 않고도 DB를 사용할 수 있음
    
    ⇒ 특정 게시글에 작성된 댓글 전체를 조회하는 요청
    

**related manager (역참조 이름) 이름 규칙**

: 모델 클래스명 + _set이 기본 값이며 Django에서 자동으로 생성해줌

: 관계를 직접 정의하지 않은 모델에서 연결된 객체들을 조회할 수 있게 함

: 특정 댓글의 게시글 참조(Comment → Article)

→ comment.article

: 특정 게시글의 댓글 목록 역참조(Article → Comment)

→ article.comment_set.all()

**related manager 연습**

- django shell 실행
    
    ![image.png](attachment:84760316-0481-45dc-bc5b-4ea17f130cb5:image.png)
    
- 1번 게시글 조회
    
    ![image.png](attachment:d7833202-bcae-4a9b-8237-3530f4401fe9:image.png)
    
- 1번 게시글에 작성된 모든 댓글 조회하기(역참조)
    
    ![image.png](attachment:7bf28382-4d66-4212-af6b-635027746533:image.png)
    
- 1번 게시글에 작성된 모든 댓글 내용 출력하기
    
    ![image.png](attachment:d5e3525d-984e-4dc3-b14f-33f85f96a49b:image.png)
    

### 댓글 CREATE

**댓글 CREATE 구현**

- 사용자로부터 댓글 데이터를 입력받기 위한 CommentForm 정의
    
    ![image.png](attachment:52862327-afe0-4314-b4bf-0fd03cbccf2c:image.png)
    
- 댓글이 작성되는 곳은 게시글 상세(detail) 페이지 하단 detail view 함수에서 CommentForm을 detail 페이지에서 사용할 수 있게 context로 전달
    
    ![image.png](attachment:617db22d-7ac6-411a-9a96-b2510b1671f8:image.png)
    
- 댓글이 작성되는 곳은 게시글 상세(detail) 페이지 하단 detail view 함수에서 넘어오는 CommentForm을 사용하여 detail 페이지에 렌더링
    
    ![image.png](attachment:bf9f15ae-7541-451d-ad1c-c97609ad9d69:image.png)
    
- Comment 클래스의 외래 키 필드 article 또한 데이터 입력이 필요한 필드이기 때문에 출력되는 것
- 외래 키 필드 데이터는 사용자로부터 입력받는 값이 아닌 view함수 내에서 다른 방법으로 전달받아 저장되어야 함
    
    ![image.png](attachment:97fd0454-e859-46e4-b056-ee9be9780bd6:image.png)
    
    - 게시글을 유저가 직접 선택하면 생기는 일
        - 댓글을 작성할 수 없도록 설정된 게시글을 선택해서 댓글을 추가할 수 있게 됨
        - 댓글을 작성하는 게시글을 자세히 확인할 수 없어 엉뚱한 게시글에 댓글을 달 수 있음
- CommentForm의 출력 필드 조정하여 외래 키(Foreign Key) 필드가 출력되지 않도록 함
    
    ![image.png](attachment:88a49087-3243-475d-bcc4-883887645cd9:image.png)
    
    - fields 설정을 tuple로 진행 시 요소가 하나일 때 마지막 콤마(,)를 반드시 작성해야 함
- 출력에서 제외된 외래 키 데이터는 어디서 받아와야 할까?
    
    → detail 페이지의 URL에 게시글 정보가 존재
    
    - path(’<int:pk>/’, views.detail, name=’detail’)
    - 해당 게시글의 pk 값이 variable routing으로 전달되고 있음
    
    → 댓글의 외래 키 데이터에 필요한 정보가 바로 게시글의 pk 값
    
    - 댓글 작성 시 해당 pk 값을 이용하여 게시글 데이터를 가져와 사용
- 댓글 저장 로직은 detail 함수가 아닌 개별 함수로 작성
-