## 251103

### [Objectives_ 학습 목표]

- 데이터베이스의 개념과 등장 배경을 이해함
- 관계형 데이터베이스(RDB)의 구조와 테이블 간의 관계를 설명할 수 있음
- SQL의 기본 구조와 문법을 이해함
- SELECT, FROM, WHERE, ORDER BY문을 활용해 데이터를 조회할 수 있음
- DISTINCT, LIMIT, LIKE 등의 키워드를 사용하여 원하는 조건으로 데이터를 필터링할 수 있음
- GROUP BY와 HAVING을 활용한 집계 데이터를 조회할 수 있음
- SQL 실행 순서를 이해하고 각 절의 역할을 구분할 수 있음

---

### [Build_ 이론]

### Database

: 체계적으로 정리된 데이터의 모음

**Data**

: 저장이나 처리를 위해 변환된 정보

: 우리가 표현한 정보들을 컴퓨터가 다룰 수 있도록 구조화한 것이 데이터

: 데이터는 분석, 계산, 저장을 위해 정보를 구체적인 형태로 정리한 것이라 할 수 있음

**증가하는 데이터 사용량**

- 배달의 민족 : 2022년 한 해 동안 11억 1100만 건 이상의 주문을 처리
- 유튜브 : 1분마다 500시간 이상의 새로운 동영상이 업로드
- 넷플릭스 : 구독자 3억 돌파(2024), 2025년 상반기 동안 전 세계 시청 시간 약 950억 시간
- IBM : 전세계 모든 데이터의 약 90%는 2015년 이후 생산된 것이라 발표

**데이터 센터의 성장**

- 네이버 : 제 2 데이터 센터에 6,500억 원을 투자(2020)
- 카카오 : 제 1 데이터 센터와 제 2 데이터 센터에 1.5조 원을 투자(2022)

**데이터를 저장하고 잘 관리하여 활용할 수 있는 기술이 중요해짐**

![image.png](attachment:e55a0042-9dea-4c94-a2a7-faa336f7c78b:image.png)

1. 파일(File) 이용
    
    : 어디에서나 쉽게 사용 가능
    
    : 데이터를 구조적으로 관리하기 어려움
    
    ![image.png](attachment:8ddef7a0-7d89-4bb5-b710-3f30d9dee01d:image.png)
    
2. 스프레드 시트(Spread sheet) 이용
    
    : 테이블의 열과 행을 사용해 데이터를 구조적으로 관리 가능
    
    ![image.png](attachment:36153c63-d4e1-45ed-b42e-ec3960763baa:image.png)
    
    - 스프레드 시트의 한계
        - 크기
            
            : 일반적으로 약 100만 행까지만 저장 가능
            
        - 보안
            
            : 단순히 파일이나 링크 소유 여부에 따른 단순한 접근 권한 기능 제공
            
        - 정확성
            
            : 만약 공식적으로 “강원”의 지명이 “강언”으로 바뀌었다고 가정하면?
            
            → 이 변경으로 인해 테이블 모든 위치에서 해당 값을 업데이트 해야함
            
            → 만약 데이터가 여러 시트에 분산되어 있다면 변경에 누락이 생기거나 추가 문제가 발생할 수 있음
            

**데이터 베이스의 역할**

**: C**reate **R**ead **U**pdate **D**elete

: 데이터를 저장(구조적 저장)하고 조작(CRUD)

### Relational Database_ 관계형 데이터 베이스

: 데이터 간에 관계가 있는 데이터 항목들의 모음

: 테이블, 행, 열의 정보를 구조화하는 방식

: 서로 관련된 데이터 포인터를 저장하고 이에 대한 엑세스를 제공

![image.png](attachment:c51bc57e-0389-4d2d-a941-03912674ae0f:image.png)

**데이터 베이스의 역할**

**⇒ “관계”**

: 여러 테이블 간의 (논리적) 연력

: 데이터를 각각의 테이블에 나눠 저장하되, 공통된 키 값을 통해 서로 연결하여 필요할 때 함께 조회하거나 조작할 수 있도록 함

**관계로 할 수 있는 것**

: 이 관계로 인해 두 테이블을 사용하여 데이터를 다양한 형식으로 조회할 수 있음

- 특정 날짜에 구매한 모든 고객 조회
- 지난 달에 배송일이 지연된 고객 조회 등

![image.png](attachment:27317f6c-c251-42c7-9942-60fa3828e27a:image.png)

**관계형 데이터베이스 예시**

- 다음과 같이 고객 데이터가 테이블에 저장되어 있다고 가정
- 고객 데이터 간 비교를 위해서는 어떤 값을 활용해야 할까?
    - 이름? 주소? 만약 동명이인이나 같은 주소지가 있다면?
    
    ![image.png](attachment:3c43a9ae-b9f4-4cbf-97b0-827bf7444b4b:image.png)
    
    - 각 데이터에 고유한 식별 값을 부여하기(기본 키, Primary Key)
    
    ![image.png](attachment:003e6b6b-623f-4d00-8bff-40645079b04e:image.png)
    
- 다음과 같이 각 고객이 주문한 주문 데이터가 테이블에 저장되어 있다고 가정
- 누가 어떤 주문을 했는지 어떻게 식별할 수 있을까?
    - 고객 이름? 마찬가지로 동명이인이 있다면?
    
    ![image.png](attachment:18f271d4-db14-406d-b940-9b005e030028:image.png)
    
    - 주문 정보에 고객의 고유한 식별 값을 저장하기(외래 키, Foreign Key)
    
    ![image.png](attachment:92e5ac04-224f-4618-8cb4-c69cf192b755:image.png)
    

**관계형 데이터베이스 관련 키워드**

1. Table(aka Relation)
    
    : 데이터를 기록하는 곳
    
    ![image.png](attachment:29d7a8da-a67a-401c-9669-2b872447e815:image.png)
    
2. Field(aka Column, Attribute)
    
    : 각 필드에는 고유한 데이터 형식(타입)이 지정됨
    
    ![image.png](attachment:db213a3a-9cc3-493b-bdd0-8f952d1df03d:image.png)
    
3. Record(aka Row, Tuple)
    
    : 각 레코드에는 구체적인 데이터 값이 저장됨
    
    ![image.png](attachment:fe6ac5a0-7a07-4143-be58-80267dd72683:image.png)
    
4. Database(aka Schema)
    
    : 테이블의 집합
    
    ![image.png](attachment:8e6a34e4-8d51-4096-8cca-f081c0c54dd9:image.png)
    
5. Primary Key(기본 키, PK)
    
    : 각 레코드의 고유한 값
    
    : 관계형 데이터베이스에서 레코드의 식별자로 활용
    
    ![image.png](attachment:7e2bff98-5401-48a1-b0fd-1bc3a8422e17:image.png)
    
6. Foreign Key(외래 키, FK)
    
    : 테이블의 필드 중 다른 테이블의 레코드를 식별할 수 있는 키
    
    : 다른 테이블의 기본 키를 참조
    
    : 각 레코드에서 서로 다른 테이블 간의 관계를 만드는 데 사용
    
    ![image.png](attachment:613f716c-7b77-4e23-bca3-04c404b4767e:image.png)
    

### RDBMS

**DBMS_ Database Management System**

: 데이터 베이스를 관리하는 소프트웨어 프로그램

: DBMS는 컴퓨터 안에서 ‘정리된 서류함’ 역할을 함

→ 데이터를 일정한 규칙으로 저장하고, 필요할 때 쉽게 꺼내거나 바꿀 수 있도록 도와주는 도구

: 데이터 저장 및 관리를 용이하게 하는 시스템

: 데이터 베이스와 사용자 간의 인터페이스 역할

: 사용자가 데이터 구성, 업데이트, 모니터링, 백업, 복구 등을 할 수 있도록 도움

**RDBMS_ Relational Database Management System**

: 관계형 데이터 베이스 관리 소프트웨어 프로그램

: 데이터를 여러 테이블에 나누어 저장하되, 공통된 키를 통해 서로 ‘관계’를 맺고 함께 사용할 수 있게 해주는 시스템

- RDBMS 서비스 종류
    - SQLite
    - MySQL
    - PostgreSQL
    - Oracle Database
    - …

**SQLite**

: 경량의 오픈 소스 데이터베이스 관리 시스템

: 설치 없이 가볍게 실행 가능해 모바일 앱이나 소규모 프로그램에 적합

: 컴퓨터나 모바일 기기에 내장되어 간단하고 효율적인 데이터 저장 및 관리를 제공

**데이터베이스 정리**

- Table은 데이터가 기록되는 곳
- Table에는 행에서 고유하게 식별 가능한 기본 키라는 속성이 있으며, 외래 키를 사용하여 각 행에서 서로 다른 테이블 간의 관계를 만들 수 있음
- 데이터는 기본 키 또는 외래 키를 통해 결합(join)될 수 있는 여러 테이블에 걸쳐 구조화 됨

### SQL_ Structure Query Language

: 테이블의 형태로 구조화된 관계형 데이터 베이스에게 요청을 질의(요청)

**SQL Syntax**

![image.png](attachment:04ce692d-5a0a-428f-a0e0-8df5237a9dd9:image.png)

1. SQL 키워드는 대소문자를 구분하지 않음
    
    → 하지만 대분자로 작성하는 것을 권장(명시적 구분)
    
2. 각 SQL Statements의 끝에는 세미콜론(’;’)이 필요
    
    : 세미콜론은 각 SQL Statements을 구분하는 방법(명령어의 마침표)
    

**SQL Statements**

: SQL을 구성하는 가장 기본적인 코드 블록

- SQL Statements의 예시
    
    ![image.png](attachment:6e23407f-da79-488d-97d0-2bb26d2c7c3b:image.png)
    
    : 해당 예시 코드는 SELECT Statement라 부름
    
    : Statement는 SELECT, FROM 2개의 keyword로 구성
    
- 수행 목적에 따른 SQL Statements 4가지 유형
    - DDL(Data Definition Language)
        
        : 데이터의 기본 구조 및 형식 변경
        
        : CREATE, DROP, ALTER
        
    - DQL(Data Query Language)
        
        : 데이터 검색
        
        : SELECT
        
    - DML(Data Manipulation Language)
        
        : 데이터 조작(추가, 수정, 삭제)
        
        : INSERT, UPDATE, DELETE
        
    - DCL(Data Control Language)
        
        : 데이터 및 작업에 대한 사용자 권한 제어
        
        : COMMIT, ROLLBACK, GRANT, REVOKE
        

### SELECT

![image.png](attachment:41609b81-e5b8-425a-a866-237b96bb34f6:image.png)

: SELECT 키워드 이후 데이터를 선택하려는 필드를 하나 이상 지정

: FROM 키워드 이후 데이터를 선택하려는 테이블의 이름을 지

- SELECT 활용
    - 테이블 employees에서 LastName 필드의 모든 데이터를 조회
        
        ![image.png](attachment:27920172-b47b-45b5-afbe-0c3504f8484a:image.png)
        
    - 테이블 employees에서 LastName, FirstName 필드의 모든 데이터를 조회
        
        ![image.png](attachment:cc7fb33e-c24b-4e6c-b3c7-0551ff796628:image.png)
        
    - 테이블 employees에서 모든 필드 데이터를 조회
        
        ![image.png](attachment:0843d0c7-77e7-4d9f-ae9b-a2b037ba6d32:image.png)
        
    - 테이블 employees에서 FirstName 필드의 모든 데이터를 조회
        
        (단, 조회 시 FirstName이 아닌 ‘이름’으로 출력될 수 있도록 변경)
        
        ![image.png](attachment:bae4027e-c555-4532-844a-27a1ec087cc1:image.png)
        
    - 테이블 tracks에서 Name, Milliseconds 필드의 모든 데이터 조회
        
        (단, Milliseconds 필드는 60000으로 나눠 분 단위 값으로 출력)
        
        ![image.png](attachment:eccf3889-a8b6-4b44-aeee-e1a2c3538263:image.png)
        

**SELECT 정리**

- 테이블의 데이터를 조회 및 반환
- ‘*’(asterisk)를 사용하여 모든 필드 선택

### Sorting data

### ORDER BY

![image.png](attachment:eeae8be1-7abc-4f06-8812-4862cd0965b7:image.png)

: FROM clause(절) 뒤에 위치

: 하나 이상의 컬럼을 기준으로 결과를 오름차순(ASC, 기본 값), 내림차순(DESC)으로 정렬

**ORDER BY 활용**

- 테이블 employees에서 FirstName 필드의 모든 데이터를 오름차순으로 조회
    
    ![image.png](attachment:f842f0ac-a79e-4e40-af1f-5db8fa1dac8b:image.png)
    
- 테이블 employees에서 FirstName 필드의 모든 데이터를 내림차순으로 조회
    
    ![image.png](attachment:2cb224da-e14e-40a0-8a45-994f22a964bc:image.png)
    
- 테이블 customers에서 Country 필드를 기준으로 내림차순 정렬한 다음 City 필드 기준으로 오름차순 정렬하여 조회
    
    ![image.png](attachment:96e5d345-63d3-4108-8fa7-1a4abadfdb90:image.png)
    
- 테이블 tracks에서 Milliseconds 필드를 기준으로 내림차순 정렬한 다음 Name, Milliseconds 필드의 모든 데이터를 조회(단, Milliseconds 필드는 60,000으로 나눠 분 단위 값으로 출력)
    
    ![image.png](attachment:fdbd462c-8abb-4380-a4ad-b10a6ac5a902:image.png)
    

**정렬에서의 NULL**

: NULL 값이 존재할 경우 오름차순 정렬 시 결과에 NULL이 먼저 출력

![image.png](attachment:b6eb5139-b76f-40bf-8afa-c4986c802a61:image.png)

**SELECT statement 실행 순서**

![image.png](attachment:87100112-ad6a-4a25-8dfd-be68aae7f548:image.png)

1. 테이블에서(FROM)
2. 조회하여(SELECT)
3. 정렬(ORDER BY)

### Filtering data

**Filtering data 관련 Keywords**

- Clause : SQL 문장에서 특정 기능을 수행하도록 지정하는 문장 구성 요소
    - DISTINCT
    - WHERE
    - LIMIT
- Operator : SQL에서 조건을 비교하거나 데이터를 선택하기 위해 사용하는 명령 기호 또는 키워드
    - BETWEEN
    - IN
    - LIKE
    - Comparison
    - Logical

### **DISTINCT**

![image.png](attachment:7186d5db-b1e6-4abf-8bcc-bd5f553247c1:image.png)

: SELECT 키워드 바로 뒤에 작성

: SELECT DISTINCT 키워드 다음에 고유한 값을 선택하려는 하나 이상의 필드를 지정

**DISTINCT 활용 전**

: 테이블 customers에서 Country 필드의 모든 데이터를 오름차순 조회

![image.png](attachment:a85a0d22-1fca-4ce3-8649-0c334a8ac5e7:image.png)

**DISTINCT 활용**

: 테이블 customers에서 Country 필드의 모든 데이터를 중복 없이 오름차순 조회

![image.png](attachment:e56d8d41-8e29-4bfd-aa77-fd1a740f5dd7:image.png)

### WHERE

![image.png](attachment:805c6070-5d57-46de-9bc2-dbf9b1e6542c:image.png)

: FROM clause 뒤에 위치

: search_condition은 비교 연산자 및 논리 연산자(AND, OR, NOT 등)를 사용하는 구문이 사용됨

**WHERE 활용**

- 테이블 customers에서 City 필드의 값이 ‘Prague’인 데이터의 LastName, FirstName, City 조회
    
    ![image.png](attachment:d867c8a7-3732-4f9e-ac53-f20988854deb:image.png)
    
- 테이블 customers에서 City 필드 값이 ‘Prague’가 아닌 데이터의 LastName, FirstName, City 조회
    
    ![image.png](attachment:d1ef20a4-cb8a-4d1b-af8d-3ca292c9dd6d:image.png)
    
- 테이블 customers에서 Company 필드 값이 NULL이고 Country 필드 값이 ‘USA’인 데이터의 LastName, FirstName, Company, Country 조회
    
    ![image.png](attachment:0bd38772-855f-4611-bbf3-3c9a75eff9cb:image.png)
    
- 테이블 customers에서 Company 필드 값이 NULL이거나 Country 필드 값이 ‘USA’인 데이터의 LastName, FirstName, Company, Country 조회
    
    ![image.png](attachment:b161888b-9994-47c6-bd55-6a01a8c0c4c4:image.png)
    
- 테이블 tracks에서 Bytes 필드 값이 10,000이상 500,000 이하인 데이터의 Name, Bytes 조회
    
    ![image.png](attachment:fd90f7f8-e8f4-4ef5-af11-f86de434b376:image.png)
    
- 테이블 tracks에서 Bytes 필드 값이 10,000 이상 500,000 이하인 데이터의 Name, Bytes를 Bytes 기준으로 오름차순 조회
    
    ![image.png](attachment:b3efd3d7-bd67-4df8-92e5-ae3d21794c37:image.png)
    
- 테이블 customers에서 Country 필드 값이 ‘Canada’ 또는 ‘Germany’ 또는 ‘France’인 데이터의 LastName, FirstName, Country 조회
    
    ![image.png](attachment:b11977ca-ab81-46b2-859a-73e9e48cc780:image.png)
    
- 테이블 customers에서 Country 필드 값이 ‘Canada’ 또는 ‘Germany’ 또는 ‘France’가 아닌 데이터의 LastName, FirstName, Country 조회
    
    ![image.png](attachment:13fdae10-dff0-477f-bd2c-4cfedc7a8715:image.png)
    
- 테이블 customers에서 LastName 필드 값이 ‘son’으로 끝나는 데이터의 LastName, FirstName 조회
    
    ![image.png](attachment:861fcca3-8c7a-4df7-8252-03058c2894bc:image.png)
    
- 테이블 customers에서 FirstName 필드 값이 4자리면서 ‘a’로 끝나는 데이터의 LastName, FirstName 조회
    
    ![image.png](attachment:768c2f1b-2f25-42dc-9d88-429926c79806:image.png)
    

### Operators

**Comparison Operators**

: 비교 연산자

![image.png](attachment:fae95999-092a-4572-a805-69c2c89ff929:image.png)

: IS, LIKE(값이 특정 패턴에 일치하는 지 확인_ Wildcards와 함께 사용), IN(값이 특정 목록 안에 있는지 확인)

: BETWEEN … AND

**Logical Operators**

: 논리 연산자

: AND(&&), OR(||), NOT(!)

**Wildcard Characters**

- %
    
    : 0개 이상의 문자열과 일치하는 지 확인
    
- _
    
    : 단일 문자와 일치하는 지 확인
    

### LIMIT

![image.png](attachment:356cba97-45ec-40fd-a676-a8b4b8fe793c:image.png)

: 하나 또는 두 개의 인자를 사용(0 또는 양의 정수)

: row_count는 조회하는 최대 레코드 수를 지정

**LIMIT & OFFSET 예시**

![image.png](attachment:06540b89-412f-46dc-8deb-cb2a47d95edb:image.png)

**LIMIT 활용**

- 테이블 tracks에서 TrackId, Name, Bytes 필드 데이터를 Bytes 기준 내림차순으로 7개만 조회
    
    ![image.png](attachment:f9dade1c-91be-47dc-a8d5-38235f838ce8:image.png)
    
- 테이블 tracks에서 TrackId, Name, Bytes 필드 데이터를 Bytes 기준 내림차순으로 4번째부터 7번째 데이터만 조회
    
    ![image.png](attachment:ce4134e6-f6c3-4ac0-8288-73410a45e9cf:image.png)
    

### Grouping Data

### GROUP BY

![image.png](attachment:de516944-72f7-48ef-abe2-91868d2cb95f:image.png)

: FROM 및 WHERE 절 뒤에 배치

: GROUP BY 절 뒤에 그룹화 할 필드 목록을 작성

**집계 함수_ Aggregation Functions**

: 값에 대한 계산을 수행하고 단일한 값을 반환하는 함수

: SUM, AVG, MAX, MIN, COUNT

**GROUP BY 예시**

1. Country 필드를 그룹화

![image.png](attachment:d10283a4-74cb-4792-9b71-7a2386a6a85d:image.png)

1. COUNT 함수는 그룹별로 묶은 총 수를 반환

![image.png](attachment:d7b51599-5f65-456b-a811-f052f650e675:image.png)

**GROUP BY 활용**

- 테이블 tracks에서 Composer 필드를 그룹화하여 각 그룹에 대한 Bytes의 평균 값을 내림차순 조회
    
    ![image.png](attachment:d54cac2b-9779-4cba-9f68-02ccc3d26365:image.png)
    
    ![image.png](attachment:c5b03488-d4f0-460f-aa47-af100d68bd72:image.png)
    
- 테이블 tracks에서 Composer 필드를 그룹화하여 각 그룹에 대한 Milliseconds의 평균 값이 10 미만인 데이터 조회(단, Milliseconds 필드는 60,000으로 나눠 분 단위 값의 평균으로 계산)
    
    ![image.png](attachment:cc862d26-7542-4d4b-8bfd-e9c5d7a905ef:image.png)
    

### HAVING clause

: 집계 항목에 대한 세부 조건을 지정

: 주로 GROUP BY와 함께 사용되며 GROUP BY가 없다면 WHERE처럼 동작

**WHERE과 HAVING의 비교**

- WHERE
    - 목적 : 개별 행에 대한 조건을 지정하여 데이터를 필터링
    - 적용 시점 : FROM과 JOIN 등의 단계 이후, GROUP BY 이전에 적용
    - 사용 예 : 특정 조건을 만족하는 행 만을 대상으로 집계나 정렬 등의 작업을 수행할 때 사용
        
        ![image.png](attachment:42740ae8-9f7f-4b7b-a147-e4040911f8b9:image.png)
        
- HAVING
    - 목적 : GROUP BY에 의해 그룹화된 결과에 대해 조건을 지정하여 그룹을 필터링
    - 적용 시점 : 그룹핑 및 집계 함수 적용 후에 조건을 평가
    - 사용 예 : 그룹별 집계 결과에 조건을 걸어 특정 그룹만을 선택할 때 사용
        
        ![image.png](attachment:6fcb3dc1-7b4b-43b5-8908-c187e9e11922:image.png)
        

**SELECT Statement 실행 순서**

![image.png](attachment:eae30f4f-e42f-4a5d-924c-2ee8b38b86e9:image.png)

1. 테이블에서(FROM)
2. 특정 조건에 맞추어(WHERE)
3. 그룹화하고(GROUP BY)
4. 만약 그룹 중 조건이 있다면 맞추고(HAVING)
5. 조회하여(SELECT)
6. 정렬하고(ORDER BY)
7. 특정 위치의 값을 가져옴(LIMIT)
