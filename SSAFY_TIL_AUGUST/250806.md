## 250806

### [Objectives_ 학습 목표]

- 2차원 리스트를 선언하고 활용할 수 있음
- 2차원 리스트의 순회 방법을 이해하고 활용할 수 있음

---

### [Build_ 이론]

### 2차원 배열

: 1차원 List를 묶어놓은 List

: 2차원 이상의 다차원 List는 차원에 따라 Index를 선언

: 2차원 List의 선언 → 세로 길이(행의 개수), 가로 길이(열의 개수)를 필요로 함

: Python에서는 데이터 초기화를 통해 변수 선언과 초기화가 가능

![image.png](attachment:0472429a-a8e5-45a0-b1e3-ac432c7eef7d:image.png)

**입력을 2차원 배열에 저장하기**

```python
N = int(input))
arr = [list(map(int, input().split())) for _ in range(N)]
```

![image.png](attachment:73e0caf5-bbaa-470b-b66e-336aa27fe0f1:image.png)

```python
N = int(input)
arr = [list(map(int, input())) for _ in range(N)]
```

![image.png](attachment:a1727dd1-3b27-4500-a607-0cf7a3640a72:image.png)

![image.png](attachment:480c768f-7fba-4038-b7f4-52c3e21cc8af:image.png)

![image.png](attachment:fdcbc8ff-1121-4afe-8e95-b094c893c0c8:image.png)

**0으로 채워진 3*4 배열 만들기**

![image.png](attachment:c001f8c0-f6d5-43a1-842c-e4d5242caf6e:image.png)

```python
arr = [[0] * 4 for _ in range(3)]
```

**배열 순회**

: n * m 배열의 n*m 개의 모든 원소를 빠짐없이 조사하는 방법

- 행 우선 조회

![image.png](attachment:95cd9708-9619-4a7b-86fd-a20e75452a56:image.png)

```python
# i행의 좌표
# j열의 좌표

for i in range(n):
		for j in range(m):
				f(array[i][j])   # 필요한 연산 수행
```

ex) N*M 배열의 크기와 저장된 값이 주어질 때 합을 구하는 방법

![image.png](attachment:d8486acb-f5ea-4da3-8a25-683e3f0055a8:image.png)

```python
N, M = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

s = 0

for i in range(N):
		for j in range(M):
				s += arr[i][j]
```

- 열 우선 순회

![image.png](attachment:12928c2c-b6d0-43d8-96a8-437702fb6951:image.png)

```python
# i행의 좌표
# j열의 좌표

for j in range(m):
		for i in range(n):
				f(array[i][j])   # 필요한 연산 수행
```

- 지그재그 순회

![image.png](attachment:2320c7f1-cd84-4c1c-ba77-6ea7c46afb8d:image.png)

```python
# i행의 좌표
# j열의 좌표

for i in range(n):
		for j in range(m):
				f(array[i][j + (m-1-2*j) * (i%2)])
```

### 델타

**델타를 활용한 2차원 배열 탐색**

- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
- 인덱스 (i, j)인 칸의 상하좌우 칸 (ni, nj)

![image.png](attachment:2592e49f-2a81-4afa-999c-94e96d541cc9:image.png)

```
di[] <- [0, 1, 0, -1]   # 방향별로 더할 값
dj[] <- [1, 0, -1, 0]

for k : 0 -> 3
		ni <- i + di[k]
		nj <- j + dj[k]
```

```
arr[0...N-1][0...N-1]   # N*N 배열
di[] <- [0, 1, 0, -1]
dj[] <- [1, 0, -1, 0]
for i : 0 -> N-1
		for j : 0 -> N-1
				for d  in range(4):
						ni <- i + di[d]
						nj <- j + dj[d]
						if 0 <= ni < N and 0 <= nj < N   # 유효한 인덱스면
								f(arr[ni][nj])
```

```python
for i in range(N):
		for j in range(N):
				for di, dj in [[0,1], [1,0], [0,-1], [-1,0]]:
						ni, nj = i+di, j+dj
				...
```

ex) N*N 배열에서 각 원소를 중심으로, 상하좌우 k칸의 합계 중 최대값(k = 2)

![image.png](attachment:24371a98-862f-433c-8e4b-85d679a66830:image.png)

```python
max_v = 0
for i in range(N):
		for j in range(N):
				s = arr[i][j]   # i, j를 중심으로
				for di, dj in [[0,1], [1,0], [0,-1], [-1,0]]:   # 각 방향
						for c in range(1, k+1):   # 거리별
								ni, nj  = i+di*c, j+dj*c
								if 0 <= ni < N and 0 <= nj < N:
										s += arr[ni][nj]
				if max_v < s:
						max_v = s
```

**전치 행렬**

![image.png](attachment:b6296594-5dae-40b6-a00a-6c97bb6dce71:image.png)

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]   # 3*3 행렬

for i in range(3):
		for j in range(3):   # for j in range(i):인 경우 if문 필요 없음
				if i < j:
						arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```

**i, j의 크기에 따라 접근하는 원소 비교(N*N)**

![image.png](attachment:51bca071-7c0f-499f-bd41-af265667ecbd:image.png)

![image.png](attachment:cc0371b7-16f5-4d29-aac8-21b54b9f114d:image.png)

![image.png](attachment:7d990dbb-2cd0-48cd-b9a3-1fc8b2cc9ce1:image.png)

![image.png](attachment:d544b185-8117-4cec-a239-03c9dc21a0e2:image.png)

```python
for i in range(N):
		for j in range(N):
				if ~~~:
```

```python
for i in range(N):
		f(arr[i][i])
```

```python
for i in range(N):
		f(arr[i][N-1-i])
```