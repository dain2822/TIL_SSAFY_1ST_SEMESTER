## 250820

### [Objectives_ 학습 목표]

- 큐 자료구조의 개념과 기본 연산을 설명할 수 있음
- 선형 큐에 대해 설명하고 이를 구현할 수 있음
- 원형 큐에 대해 설명하고 이를 구현할 수 있음
- 리스트의 특성을 사용한 큐에 대해 설명하고 이를 구현할 수 있음
- 연결 큐에 대해 설명하고 이를 구현할 수 있음
- 큐 라이브러리를 활용하여 구현할 수 있음
- 큐를 활용한 자료구조인 우선순위 큐의 개념과 알고리즘을 설명할 수 있음
- 큐의 활용인 버퍼에 대해 이해함
- 큐를 활용한 그래프 탐색 방법인 너비 우선 탐색 알고리즘에 대해 설명할 수 있음

---

### 큐_ Queue

: 먼저 들어온 데이터가 먼저 나가는 **선형 자료구조**

: 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조로 큐의 뒤에서는 삽입만 하고, 앞에서는 삭제만 이루어지는 구조임

**선입선출_ FIFO; First In First Out**

: 가장 먼저 넣은 자료가 가장 먼저 나오는 것

ex) 큐에 1, 2, 3을 차례대로 넣으면 꺼낼 때도 1, 2, 3이 순서대로 나오게 됨

큐의 또 다른 예로는 서비스 대기 행렬이 있음

![image.png](attachment:c1b7996e-6b78-4c11-9871-50931d795eed:image.png)

### 큐의 기본 연산

- enqueue(item)  (삽입)
    
    : 큐의 뒤쪽(rear, 다음)에 원소를 삽입하는 연산
    
- dequeue()   (삭제)
    
    : 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
    
- create_queue()
    
    : 공백 상태의 큐를 생성하는 연산
    
- is_empty()
    
    : 큐가 공백 상태인 지를 확인하는 연산
    
- is_full()
    
    : 큐가 포화 상태인 지를 확인하는 연산
    
- qpeek()
    
    : 큐의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산
    

**큐의 연산 과정**

- 1단계 공백 큐 생성: create_queue()

![image.png](attachment:14c37464-c53b-4217-a040-c23d6d77749c:image.png)

- 2단계 원소 A 삽입 : enqueue(A)

![image.png](attachment:09ad8cc1-d9d4-4b21-be73-4606355e3e5e:image.png)

- 3단계 원소 B 삽입 : enqueue(B)

![image.png](attachment:a3434a2d-2f47-4a2f-aab4-9bf440250d31:image.png)

- 4단계 원소 반환 / 삭제 : dequeue()

![image.png](attachment:58f771ec-aad2-4ff9-a25a-d700de46c1ef:image.png)

- 5단계 원소 C 삽입 : enqueue(C)

![image.png](attachment:48e4b9cc-c76c-4f85-b856-e68fa96d270c:d541a23c-ae43-4b45-9c0c-7fa70c30d256.png)

- 6단계 원소 반환 / 삭제 : dequeue()

![image.png](attachment:f90bb2c1-61fb-44fd-9386-0a60b4bb025f:image.png)

- 7단계 원소 반환 / 삭제 : dequeue()

![image.png](attachment:100e5827-aa6f-4767-b737-2629fff979f1:image.png)

---

### 선형 큐_ Linear Queue

: 데이터를 일렬로 저장하며, 앞에서 꺼내고 뒤에서 넣는 기본 큐 구조

**구현**

- 배열이나 연결형 리스트로 구현할 수 있음
- 큐의 크기는 배열의 크기와 같음
- front : 가장 최근에 삭제된 원소의 인덱스
- rear : 마지막으로 저장된 원소의 인덱스

**상태 표현**

- 초기 상태 : front = rear = -1
- 공백 상태 : front == rear
- 포화 상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)

**선형 큐의 구현**

1. 초기 공백 큐 생성 : create_queue()
    1. 크기 n인 1차원 배열 생성
    2. front와 rear를 -1로 초기화
    
    ```python
    # create_queue()에 해당
    q = [0] * n
    front = -1
    rear = -1
    ```
    
2. 삽입 : enqueue(item)
    
    : 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
    
    1. raer 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 지정
    2. 그 인덱스에 해당하는 배열 원소 Q[rear]에 item을 저장
    
    ```python
    enqueue(item):
    		global rear
    		if is_full() : print("Queue_Full")
    		else:
    				rear <- rear + 1;
    				q[rear] <- item;
    ```
    
3. 삭제
    
    : 가장 앞에 있는 원소를 삭제하기 위해
    
    1. front 값을 하나 증가시켜 큐에 남아있는 첫 번째 원소 이동
    2. 새로운 첫 번째 원소를 리턴함으로써 삭제와 동일한 기능을 함
    
    ```python
    dequeue()
    		if (is_empty()) then queue_empty();
    		else
    				front <- front + 1;
    				return Q[front];
    ```
    
4. 공백 상태 및 포화 상태 검사 : is_empty(), is_full()
    1. 공백 상태 : front == rear
    2. 포화 상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)
    
    ```python
    is_empty():
    		return front == rear
    is_full():
    		return rear == len(q) - 1
    ```
    
5. 검색 : qpeek()
    1. 가장 앞에 있는 원소를 검색하여 반환하는 연산
    2. 현재 front의 한 자리 뒤(front + 1)에 있는 원소, 즉 큐의 첫 번째에 있는 원소를 반환
    
    ```python
    def qpeek():
    		if is_empty():  print("Queue_Empty")
    		else: return q[front+1]
    ```
    

---

### 원형 큐_ Circular Queue

: 선형 큐의 공간 낭비를 막기 위해 처음과 끝이 연결된 구조

**선형 큐 이용 시의 문제점**

- 잘못된 포화 상태 인식

![image.png](attachment:1e2f8479-9b36-4fba-9778-08bce89eb6d5:image.png)

→ 선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우 배열의 앞부분에 활용할 수 있는 공간이 있음에도 불구하고, rear = n-1인 상태 즉, 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게됨

**해결 방법**

- 매 연산이 이루어질 때마다 저장된 원소들을 배열의 앞부분으로 모두 이동
    
    → 원소 이동에 많은 시간이 소요되어 큐의 효율성이 급격히 떨어짐
    
    ![image.png](attachment:e502a898-e0cc-4863-ad85-02bfb73e91bf:image.png)
    
- 1차원 배열 사용
    
    → 논리적으로는 배열이 처음과 끝이 연결되어 원형 상태를 이룬다고 가정하고 사용함
    

![image.png](attachment:d08ebc11-984d-4601-b4e1-41f49e2e13b6:image.png)

**원형 큐의 구조**

- 초기 공백 상태
    
    : front = rear = 0
    
- Index의 순환
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킴
    - 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동해야 함
    - 이를 위해 나머지 연산자 mod를 사용
- front 변수
    
    : 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
    

**선형 큐와 원형 큐 비교**

![image.png](attachment:85054dea-7acc-4cef-82df-57fa87a6c4b3:image.png)

**원형 큐의 연산 과정**

- 1단계 create_queue()
    
    ![image.png](attachment:13d8b995-2c98-4c1a-afbb-2bdbb8cf3545:image.png)
    

- 3단계 enqueue(B);

![image.png](attachment:96961acc-9509-4879-a5dd-9f59d3ea24c1:image.png)

- 5단계 enqueue(C);

![image.png](attachment:5c228cda-8804-4f38-84de-75b950d6d378:image.png)

- 2단계 enqueue(A);
    
    ![image.png](attachment:86bfe180-5e46-4249-a4e8-d3b8d39ff37b:image.png)
    
- 4단계 dequeue();

![image.png](attachment:dbadd432-5b5c-49aa-a2af-78323c1b6d1c:image.png)

- 6단계 enqueue(D);

![image.png](attachment:ff3510c9-ce2c-45c4-ab30-f87267ef1647:image.png)

**원형 큐의 구현**

1. 초기 공백 큐 생성
    1. 크기 n인 1차원 배열 생성
    2. front와 rear를 0으로 초기화
    
    ```python
    cq = [0] * n
    front = rear = 0
    ```
    
2. 삽입 : enqueue(item)
    
    : 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
    
    1. rear 값을 조정하여 새로운 원소를 삽입할 자리를 지정
        - rear ← (rear+1) mod n;
    2. 인덱스에 해당하는 배열원소 cQ[rear]에 item을 저장
    
    ```python
    def enqueue(item):
    		global rear
    		if is_full():
    				print("Queue_Full")
    		else:
    				rear = (rear + 1) % len(cq)
    				cq[rear] = item
    ```
    
3. 삭제 : dequeue()
    
    : 가장 앞에 있는 원소를 삭제하기 위해
    
    1. front 값을 조정하여 삭제할 자리 조정
    2. 새로운 front 원소를 리턴함으로써 삭제와 동일한 기능을 함
    
    ```python
    def dequeue():
    		global front
    		if is_empty():
    				print("Queue_Empty")
    		else:
    				front = (front + 1) % len(cq)
    				return cq[front]
    ```
    
4. 공백 상태 및 포화 상태 검사 : is_empty(), is_full()
    1. 공백 상태 : front == rear
    2. 포화 상태 : 삽입할 rear의 다음 위치 == 현재 front
        
        : (rear + 1) mod n == front
        
    
    ```python
    def is_empty():
    		return front == rear
    def is_full():
    		return (rear+1) % len(cq) == front
    ```
    

---

### 연결 큐_ Linked Queue

: 연결 리스트를 이용해 구현한 큐

**연결 큐의 구조**

- 단순 연결 리스트(Linked List)를 이용한 큐
    - 큐의 원소 : 단순 연결 리스트의 노드
    - 큐의 원소 순서 : 노드의 연결 순서 / 링크로 연결되어 있음
    - front : 첫 번째 노드를 가리키는 링크
    - rear : 마지막 노드를 가리키는 링크
- 상태 표현
    - 초기 상태 : front = rear = null
    - 공백 상태 : front = rear = null

![image.png](attachment:c06f9d7e-5a90-4fd0-bbb7-64940616a8f9:image.png)

**연결 큐의 연산 과정**

- 1단계 공백 큐 생성 : createLinkedQueue();
    
    ![image.png](attachment:bf1c9875-0123-44dc-ba06-0814243014b1:image.png)
    

- 2단계 원소 A 삽입 : enqueue(A);
    
    ![image.png](attachment:961dcea6-5089-45f2-aa45-2a859e55c974:image.png)
    

- 3단계 원소 B 삽입 : enqueue(B);
    
    ![image.png](attachment:9c9808b5-ff13-4902-b09a-9d7eb3874222:image.png)
    

- 4단계 원소 삭제 : dequeue();
    
    ![image.png](attachment:54749bfa-3a60-4630-88f7-2dd9061ce568:image.png)
    

- 5단계 원소 C 삽입 : enqueue(C);
    
    ![image.png](attachment:552ca0ae-0808-499d-877a-21f1d646e0e6:image.png)
    

- 6단계 원소 삭제 : dequeue();
    
    ![image.png](attachment:ebbd391f-3d07-4486-b3e0-80e7764c7cc8:image.png)
    

- 7단계 원소 삭제 : dequeue();
    
    ![image.png](attachment:fbb06dc0-2688-492a-b1bd-4ac0a7ec4507:image.png)
    

**deque(덱)**

: 컨테이너 자료형 중 하나로 양쪽 끝에서 빠르게 추가와 삭제를 할 수 있는 리스트류 컨테이너

→ 연결 리스트를 직접 만들지 않아도 됨

**deque의 연산**

- append(x) : 오른쪽에 x 추가
- popleft() : 왼쪽에서 요소를 제거하고 반환 / 요소가 없으면 IndexError

```python
from collections import deque

q = deque()
q.append(1)    # enqueue()
t = q.popleft()    # dequeue()
```

**연결 큐의 구현 예시**

```python
class Node:
		def __init__(self, item, n = None):
				self.item = item
				self.next = n
				
def enqueue(item):    # 연결 큐의 삽입 연산
		global front, rear
		newNode = Node(item)    # 새로운 노드 생성
		if front == None:    # 큐가 비어있다면
				front = newNode
		else:
				rear.next = newNode
		rear = new Node
		
def is_empty():
		return front == None

def dequeue():    # 연결 큐의 삭제 연산
		global front, rear
		if is_empty():
				print("Queue_Empty")
				return None
		item = front.item
		front = front.next
		if front == None:
				rear = None
		return item
		
def qpeek():
		return front.item
		
def print_q():
		f = front
		s = ""
		while f:
				s += f.item + ""
				f = f.next
		return s
		
front = None
rear = None
```

---

### 우선순위 큐_ Priority Queue

: 우선순위를 가진 항목들을 저장하는 큐

: FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 됨

: 우선순위 큐의 적용 분야로 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 태스크 스케줄링이 있음

**우선순위 큐의 연산**

- 삽입 : enqueue
- 삭제 : dequeue

![image.png](attachment:5da13852-d96f-4457-bfca-166098cac949:image.png)

**배열을 이용한 우선순위 큐**

- 배열을 이용하여 자료를 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조임
- 가장 앞에 최고 우선순위 원소가 위치

→ 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생하여 소요되는 시간이나 메모리 낭비가 큼

---

### 버퍼_ Buffer

: 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역

→ 버퍼를 채우는 것을 **버퍼링**이라고 함

**버퍼의 자료 구조**

- 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용됨
- 순서대로 입력 / 출력 / 전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용됨

**버퍼의 예시 : 키보드 버퍼**

![image.png](attachment:c0563511-d974-49df-9778-fa11b151c66e:e1e52447-8022-4494-b20b-b52096c0cf45.png)

![image.png](attachment:4082b10e-d2cb-46f1-966c-16642fd1a9e3:image.png)

![image.png](attachment:ab678a0a-5219-4943-9f04-d063a78aa526:image.png)

![image.png](attachment:7a8c25cf-fdd8-4703-8d02-ab69afce8d9c:image.png)

---

![image.png](attachment:aec2fbc4-c459-4df9-8ffb-b2b6f3f5242d:image.png)

![image.png](attachment:25b0a5da-4a9c-4534-af1f-6a999e376c4c:image.png)

**출력 결과**

![image.png](attachment:3b2383f8-eb80-458f-9529-1cc0a5b4e4ba:image.png)

![image.png](attachment:927f079e-b090-4e62-b86a-7cde3c640455:image.png)

**출력 결과**

