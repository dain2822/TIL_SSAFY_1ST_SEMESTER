---

## 250805

---

### [Objectives_학습 목표]

- 카운팅 정렬의 정렬 방식을 설명할 수 있음
- 완전 검색의 개념을 설명할 수 있음
- 탐욕 알고리즘에 대해 설명할 수 있음

---

### [Build_ 이론]

### 카운팅 정렬_ Counting Sort

: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식

: 시간 복잡도 → O(n + k) _ n은 리스트 길이, k는 정수의 최대값

**카운팅 정렬 제한 사항**

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    
    : 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
    
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

**카운팅 정렬 과정 예시**

- 1단계
    
    ![image.png](attachment:ac9783c2-ec0c-4ca8-a245-8de98641edad:image.png)
    
    → DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장함
    
- 2단계
    
    ![image.png](attachment:e2288ba7-9e9c-446f-af7b-06ffa3a39fce:image.png)
    
    → 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정함
    
- 3단계
    
    ![image.png](attachment:77a55053-b138-4342-8adc-0e27a5e9b471:image.png)
    
    → DATA의 마지막 원소 1의 발생 횟수 COUNTS[1]을 감소시키고 TEMP에 1을 삽입함
    
    ![image.png](attachment:fa92d65c-c81d-4e54-9fa7-479ec342e6b4:image.png)
    
    → COUNTS[4]를 감소시키고 TEMP에 4를 삽입함
    
    ![image.png](attachment:964cfc69-89bf-4a0c-ae3c-88eb1a0322d9:image.png)
    
    → COUNTS[2]를 감소시키고 TEMP에 2를 삽입함
    
    ![image.png](attachment:4876bd9e-d022-41df-92f7-904cfed15acf:image.png)
    
    → COUNTS[1]을 감소시키고 TEMP에 1을 삽입함
    
    ![image.png](attachment:dad9dac4-653e-4c7b-bfe4-6baa8ddc50bb:image.png)
    
    → COUNTS[3]을 감소시키고 TEMP에 3을 삽입함
    
    ![image.png](attachment:51b1e553-730c-4c70-9a76-b6d374af7f8d:image.png)
    
    → COUNTS[1]을 감소시키고 TEMP에 1을 삽입함
    
    ![image.png](attachment:a9403eb8-eb46-4648-9b40-d21379bd2a27:image.png)
    
    → COUNTS[4]를 감소시키고 TEMP에 4를 삽입함
    
    ![image.png](attachment:94bcdf06-b499-44d0-87db-f65d9bdad5d0:image.png)
    
    → COUNTS[0]을 감소시키고 TEMP에 0을 삽입함
    

**카운팅 정렬 알고리즘**

```python
def counting_sort(DTAT,TEMP, k):
# DATA[] : 입력 배열(원소는 0이상 k이하의 정수)
# TEMP[] : 정렬된 배열
# COUNTS[] : 카운트 배열

	COUNTS = [0] * (k+1)
	
	for i in range(len(DATA)):   # DATA[i] 발생 횟수 기록
			COUNTS[DATA[i]] += 1
	
	for i in range(1, k+1):   # COUNTS 값 조정(누적)
			COUNTS[i] += COUNTS[i-1]
	
	for i in range(len(DATA)-1, -1, -1):   # 3단계
			COUNTS[DATA[i]] -= 1
			TEMP[COUNTS[DATA[i]]] = DATA[i]
```

**정렬 알고리즘 비교**

![image.png](attachment:90bda8be-1644-4521-81f3-9cdc5f86d453:image.png)

### 완전 검색_ Exaustive Search

: 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

→ Brute-force 혹은 generate-and-test 기법이라고도 불림

→ 모든 경우의 수를 테스트한 후, 최종 해법을 도출하는 방법으로 일반적으로 경우의 수가 상대적으로 작을 때 유용함

**완전 검색의 필요성**

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적음
- 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

**완전 검색을 활용한 Baby-gin 접근**

- 고려할 수 있는 모든 경우의 수 생성

![image.png](attachment:d9d46f41-1cb8-4cf2-b7c1-ba0077a24aa6:image.png)

- 해답 테스트

![image.png](attachment:467fbb71-88a2-4e7f-a382-253b0480135b:image.png)

### 순열_ Permutation

: 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

: 서로 다른 n개 중 r개를 택하는 순열 → $nPr$

: $nPr = n * (n-1) * (n-2) * … * (n-r+1)$

→ $nPn = n!$ 으로 표기하며 $Factorial$이라 부름

→ $n! = n * (n-1) * (n-2) * … * 2 * 1$

**단순하게 순열을 생성하는 방법**

→ {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수

→ 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 이용하여 구현

```python
for i1 in range(1, 4):
		for i2 in range(1, 4):
				if i2 != i1:
						for i3 in range(1, 4):
								if i3 != i1 and i3 != i2:
										print(i1, i2, i3)
```

### 탐욕 알고리즘_ Greedy

: 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 방식

**탐욕 알고리즘 특징**

- 최적해를 구하는데 사용되는 근시안적인 방법
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근임

**탐욕 알고리즘 과정**

1. 해 선택
    
    → 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가
    
2. 실행 가능성 검사
    
    → 새로운 부분 해 집합이 실행 가능한 지를 확인
    
    → 즉, 문제의 제약 조건을 위반하지 않는지 검사함
    
3. 해 검사
    
    → 새로운 부분 해 집합이 문제의 해가 되는지 확인
    
    → 아직 전체 문제의 해가 완성되지 않았다면 1. 해 선택부터 다시 시작
    

**탐욕 알고리즘 예시_ 거스름돈 줄이기**

> “어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?”
> 
1. 해 선택
    1. 가장 좋은 해를 선택
    2. 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들기 때문에 현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
2. 실행 가능성 검사
    1. 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인
    2. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고 1. 해 선택으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가
3. 해 검사
    1. 거스름돈을 확인해서 액수에 모자라면 다시 1. 해 선택으로 돌아가서 거스름돈에 추가할 동전을 고름

**탐욕 알고리즘을 활용한 Baby-gin 접근**

![image.png](attachment:5222319c-0a8a-47d1-8596-a444bfd4ed76:image.png)

![image.png](attachment:a3ee1e5d-dfa6-457e-bb8a-50b952f4081a:image.png)

```python
num = 456789   # Baby Gin을 확인할 6자리 수
c = [0] * 12   # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6):
		c[num % 10] += 1
		num //= 10
		
i = 0
tri = run = 0
while i < 10:
		if c[i] >= 3:   # triplete 조사 후 데이터 삭제
				c[i] -= 3
				tri += 1
		if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:   # run 조사 후 데이터 삭제
				c[i] -= 1
				c[i+1] -= 1
				c[i+2] -= 1
				run += 1
				continue
		i += 1
if run + tri == 2:
		print("Baby Gin")
else:
		print("Lose")
```

**주의_ Baby-gin 문제에서 자주 실수하는 오답**

: 입력받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run 및 triplet을 확인하는 방법을 고려할 수도 있음

ex) [6, 4, 4, 5, 4, 4]

: 정렬하여 [4, 4, 4, 4, 5, 6]을 얻어내면 쉽게 baby-gin을 확인할 수 있음

ex) [1, 2, 3, 1, 2, 3]

: 정렬하면 [1, 1, 2, 2, 3, 3]로서, 오히려 baby-gin 확인을 실패할 수 있음