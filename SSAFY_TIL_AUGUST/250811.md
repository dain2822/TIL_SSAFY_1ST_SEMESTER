## 250811

### [Objectives_ 학습 목표]

- 문자열을 조작하는 방법을 이해하고 이를 활용할 수 있음
- 패턴 매칭에 대해 이해하고 설명할 수 있음

---

### [Build_ 이론]

### 연산

**문자열 뒤집기**

- 문자열을 역순으로 재정의

```python
s = 'Reverse this strings'    # 'sgnirts siht esreveR'
s = s[::-1]
```

- 리스트로 변환 후 다시 문자열로 변환

```python
s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)
```

**회문**

: ‘기러기’, ‘토마토’, ‘스위스’와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말

→ 문자열 길이의 반만 비교하면 됨

![image.png](attachment:526b0bbf-ed4d-4d15-ad01-ababb0068743:image.png)

```python
is_palindrome(txt):
    for i : 0 -> len(txt)//2 - 1
		    if txt[i] != txt[len(txt) - 1 - i]
				    return False
		return True
```

**문자열 비교**

- == 연산자와 is 연산자
    
    : ==는 값(value)이 같은 지를 비교
    
    : is는 객체의 정체성(identity), 즉 같은 객체(메모리 주소)인지 비교함
    
    : == 연산자는 내부적으로 특수 메서드 __eq__()를 호출함
    
    ```python
    s1 = 'abc'
    s2 = 'abc'
    s3 = 'abc'
    s4 = s1
    s5 = s1[:2] + 'c'
    
    print(s1 == s2)    # True
    print(s1 is s2)    # True
    print(s4 == s5)    # True
    print(s4 is s5)    # False
    ```
    
    ```python
    a = [1, 2, 3]
    b = [1, 2, 3]
    
    print(a == b)    # True(값이 같음)
    print(a is b)    # False(다른 객체임)
    ```
    

**C와 Java에서의 문자열 비교**

- C
    
    : strcmp() 함수를 사용해 문자열의 내용을 비교함
    
- Java
    
    : == 연산자는 객체의 주소(참조)를 비교함(Python의 is 연산자 역할)
    
    : equals() 메소드는 객체의 내용을 비교함(Python의 == 역할)
    

**사전 순서 비교**

- 비교 연산자 < 사용
    
    : 유니코드를 비교함
    
    ```python
    def my_strcmp(s1, s2):
    		if s1 < s2:
    				reutnr -1    # s1이 s2보다 사전 순서상 앞서는 경우
    		elif s1 > s2:
    		    return 1    # s1이 s2보다 사전 순서상 나중인 경우
    		else:
    				return 0    # s1과 s2 문자열의 내용이 같은 경우
    ```
    
    - 문자열에 대한 < 연산은 유니코드 값에 대한 비교임
    
    → ‘Apple’ < ‘apple’도 True이고 ‘Zebra’ < ‘apple’도 True
    

**문자열 숫자를 숫자로 변환**

```python
a = int('123')
b = float('3.14')
c = int('A0', 16)    # 문자열 'A0'를 16진법으로 해석해서 변환
```

```python
a = str(123)
b = str(3.14)
```

---

### 패턴 매칭

### 고지식한 알고리즘(Brute Force)

- 단순한 방법
    
    : 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식
    
    ![image.png](attachment:8e4ddf19-2573-4226-bcfc-bcd3594e4411:image.png)
    
- 구현
    
    : 본문의 비교 위치 i, 패턴에서의 비교 위치 j
    
    → 일치하면 i, j 증가, 실패하면 i는 이전 시작 위치 다음으로, j는 맨 앞으로 초기화
    
    ![image.png](attachment:7d8e3a14-8fab-44d4-a4d4-e5481f6e8a04:image.png)
    

```python
def brute_force(p, t):    # p : 찾을 패턴, t : 본문 문자열 / 패턴 있으면 인덱스, 없으면 -1 리턴
		i = 0    # t의 인덱스
		j = 0    # p의 인덱스
		M = len(p)
		N = len(t)
		while j < M and i < N:
				if t[i] != p[j]:    # 다른 글자인 경우
						i = i - j
						j = -1
				i = i + 1
				j = j + 1
		if j == M : return i - M    # 검색 성공
		else: return -1    # 검색 실패
```

**시간 복잡도**

- 최악의 경우 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 됨
- 길이가 10,000인 문자열에서 길이 80인 패턴을 찾는 경우
    
    : 최악의 경우 약 10,000 * 80 = 800,000 번의 비교가 필요함
    

### KMP 알고리즘

- 연구자인 Knuth, Morris, Pratt 세 사람의 이름에서 유래
- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
    - 불일치가 발생한 글자의 앞 부분에 어떤 문자가 있는 지를 미리 알고 있게 됨
    - 조건에 따라, 불일치가 발생한 앞 부분에 대해 다시 비교하지 않을 수 있음
    - 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 전처리가 필요함
- 시간 복잡도
    - 패턴의 길이가 M일 때 전처리에 걸리는 시간은 $O(M)$임
    - 텍스트의 길이가 N일 때 검색은 최악의 경우 $O(N)$임
    - 결과적으로 $O(M+N)$이 됨
    - 만약 M이 고정된 값으로 매우 짧다면 평균적으로 $Θ(N)$이 됨

ex) 텍스트에서 abcdabc까지는 매치되고, e에서 실패한 상황

→ 패턴의 맨 앞의 abc와 실패 직전의 abc는 동일함을 이용할 수 있음

![image.png](attachment:fd3d9067-5628-427c-aa48-5c095779401f:image.png)

**LPS(Longest Prefix which is also Suffix) 배열**

: 접두사이자 접미사인 문자열의 최대 길이

: 일치하지 않을 때 비교할 인덱스

: 구현에 따라 next, pi 배열로도 불림

![image.png](attachment:638adcf4-3017-4643-9e78-39b06e11879e:image.png)

### 보이어-무어(Boyer-Moore) 알고리즘

- 상용 소프트웨어에서 채택하고 있는 알고리즘
- 실제 검색에서 매우 빠른 성능을 보임
    
    : 패턴 오른쪽 끝에 있는 문자가 불일치 하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 패턴의 길이만큼이 됨
    
    ![image.png](attachment:a0e4f7a8-9806-422c-90d9-e25e22c5e4dc:image.png)
    

**불일치 문자 휴리스틱(Bad-Character Heuristic)**

: 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우

→ 불일치 문자 오른쪽에서 일치한 부분을 고려해 점프함

![image.png](attachment:4db2394b-4b50-4abf-a3db-4027730e673c:image.png)

**Skip 배열**

![image.png](attachment:c2f06338-c933-4825-872e-1bb82a4c428b:image.png)

**문자열 매칭 알고리즘 비교**

- 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
- 고지식한 패턴 검색 알고리즘_ 수행 시간 : O(mn)
- 카프-라빈 알고리즘_ 수행 시간 : Θ(n)
- KMP 알고리즘_ 수행 시간 : Θ(n)
- 보이어-무어 알고리즘
    - 앞의 두 매칭 알고리즘들은 텍스트 문자열의 문자를 적어도 한 번씩 훑기 때문에 최선의 경우에도 Ω(n)임
    - 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 됨
    - 패턴의 오른쪽부터 비교함
    - 완전한 보이어-무어 알고리즘은 일치 접미부 휴리스틱을 함께 사용함
    - 최악의 경우 O(mn)이지만 일반적으로 Θ(n)보다 시간이 덜 소요됨
    - grep, VS Code, JVM 등에서 사용됨

### 문자열 암호화

**시저 암호(Caesar cipher)**

: 줄리어스 시저가 사용했다고 하는 암호

ex) 1만큼 평행한 암호화

![image.png](attachment:d185d38b-e038-47c1-ab9c-db0a1b88fc3c:image.png)

→ 1만큼 평행했을 때 1을 키 값이라고 함

![image.png](attachment:2a4a6299-6633-4e0c-b6c0-dc6fa16d04e2:image.png)

**문자 변환표를 이용한 암호화(단일 치환 암호화)**

: 단순한 카이사르 암호화보다 훨씬 강력한 암호화 기법

→ 알파벳 하나를 다른 고정된 알파벳으로 바꾸는 방법

![image.png](attachment:b3eb633b-a3d9-4406-8297-649793ae2da4:image.png)

**단일 치환 암호화의 복호화**

: 모든 키의 조합이 필요함

: 키의 총 수

→ 26 * 25 * 24 * 23 * … * 1 = 26! = 403,291,461,126,605,635,584,000,000

: 빈도 분석 공격 가능

→ 가장 많이 쓰이는 글자 E, T, A 등 임

→ 암호문에서 자주 나오는 문자를 추정해 대응시키면 해독이 가능함

**문자열 압축**

- Run-length encoding 알고리즘
    - 같은 값이 몇 번 반복되는가를 나타내는 방식
    - 이미지 파일 포맷 중 BMP 파일의 압축 방법 중 하나로 사용함
    
    ![image.png](attachment:aabebc76-4f3b-4701-9708-0b7636e57635:image.png)
    
- 허프만 코딩 알고리즘
    - 더 효율적이고 일반적인 압축 방법
    - 자주 나오는 문자는 짧은 코드, 드물게 나오는 문자는 긴 이진 코드를 부여해 결과적으로 전체 데이터의 평균 비트 수를 최소화하는 알고리즘