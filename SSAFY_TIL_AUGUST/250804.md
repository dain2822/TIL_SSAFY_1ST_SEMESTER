---

## 250804

---

### [Objectives_학습 목표]

- 알고리즘의 개념을 이해하고 설명할 수 있음
- 리스트의 개념과 필요성을 이해하고 설명할 수 있음
- 1차원 리스트를 활용할 수 있음
- 정렬의 개념에 대해 설명할 수 있음
- 버블 정렬의 정렬 방식을 설명할 수 있음

---

### [Build_ 이론]

### 알고리즘_Algorithm

: 문제를 해결하기 위한 절차나 방법

- 의사코드(슈도코드, Pseudocode)와 순서도
    
    : 컴퓨터 분야에서 알고리즘을 표현하는 방법
    

![image.png](attachment:a2392396-c140-4c34-baa6-157c3ea618b7:image.png)

![image.png](attachment:dc2296f7-8819-414d-8ce2-8977a2178e30:image.png)

- 좋은 알고리즘이란?
    - 정확성 - 얼마나 정확하게 동작하는가
    - 작업량 - 얼마나 적은 연산으로 원하는 결과를 얻어내는가
    - 메모리 사용량 - 얼마나 적은 메모리를 사용하는가
    - 단순성 - 얼마나 단순한가
    - 최적성 - 더 이상 개선할 여지없이 최적화되었는가
- 주어진 문제를 해결하기 위해 여러 개의 다양한 알고리즘이 가능
    - 어떤 알고리즘을 사용해야 하는가를 고려해야 함
- 알고리즘의 성능 분석 필요
    - 많은 문제에서 성능 분석의 기준으로 알고리즘의 작업량을 비교함

![알고리즘 성능 비교 예시_ 1부터 100까지 합을 구하는 문제](attachment:e3b5e84b-3e04-4735-b096-fd083d2bd7ba:image.png)

알고리즘 성능 비교 예시_ 1부터 100까지 합을 구하는 문제

![알고리즘 성능 비교 예시_ 1부터 n까지 합을 구하는 문제](attachment:07ba9e87-2e1b-4de1-afcd-f2058ca1d34d:image.png)

알고리즘 성능 비교 예시_ 1부터 n까지 합을 구하는 문제

### 알고리즘의 시간 복잡도

: 알고리즘의 작업량을 표현할 때 시간 복잡도로 표현함

: 시간 복잡도(Time Complexity)

→ 실제 걸리는 시간을 측정

→ 실행되는 명령문의 개수를 계산

: 빅-오 표기법(Big-O Notation)을 언급하는 경우가 많음

→ 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

→ 계수(Coefficient)는 생략하여 표신

![image.png](attachment:b28423c6-bc03-498b-8527-9f04a25ab2e4:image.png)

![image.png](attachment:ca2597a3-64a5-4305-a05a-b8bdab19c043:image.png)

![image.png](attachment:3daa4bb0-2597-4f3e-8cf1-8574cf12e3aa:image.png)

---

### 배열_ Array

: 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조

![6개의 변수를 배열로 바꾸어 사용하는 예시](attachment:045e0ad4-0c68-42e4-9b46-274d53a23692:image.png)

6개의 변수를 배열로 바꾸어 사용하는 예시

**배열의 필요성**

- 프로그램 내에서 여러 개의 변수가 필요할 때
    - 다른 변수명을 이용하여 자료에 접근하는 것은 매우 비효율적일 수 있음
- 배열을 사용하면 하나의 선언을 통해 둘 이상의 변수를 선언
- 단순히 다수의 변수 선언을 의미하는 것은 아님
    - 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있음

**1차원 배열**

![image.png](attachment:8e7a7317-7836-4588-848d-848b68e18600:image.png)

![image.png](attachment:38869e42-edff-4e3c-bf47-2898f5b0986b:image.png)

![image.png](attachment:b0eeac84-b2a4-4836-be47-5573d0511e5b:image.png)

**입력 받은 정수를 1차원 배열에 저장하는 방법**

→ 첫 줄에 양수의 개수 N이 주어짐(5≤N≤1,000)

→ 다음 줄에 빈칸으로 구분된 N개의 양수 Ai가 주어짐(1≤Ai≤1,000,000)

![image.png](attachment:a754fcf3-416b-4cff-b508-5c2dbe746259:image.png)

![image.png](attachment:e0efe0fb-816e-42a6-94eb-6f215b2b1823:image.png)

**배열 원소의 합 s 계산하기**

![image.png](attachment:973c5186-4411-49e2-bfbe-e89e25d04b72:image.png)

**배열 원소 중 최댓값 max_v 찾기**

![image.png](attachment:008c385a-e533-4f17-a606-a588d08b94fc:image.png)

**배열 원소 중 최댓값의 인덱스 max_idx 찾기**

![image.png](attachment:8872606f-9942-420f-9da0-7fd88927f11e:image.png)

**배열 원소 중 최댓값의 인덱스 max_idx 찾기**

![image.png](attachment:5b33f460-e844-4edb-8020-19600889354e:image.png)

**최댓값이 여러 개인 경우 마지막 인덱스 max_idx 찾기**

![image.png](attachment:d4973b5f-4a12-4f1f-8681-1d86a7d99226:image.png)

![image.png](attachment:2831d7ba-cc5f-4915-8823-49dc4a26797a:image.png)

**찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1을 idx에 넣기**

![image.png](attachment:69c14fae-864f-441e-a012-a0566f311b64:image.png)

---

### 정렬_Sort

: 2개 이상의 자료를 키(특정 기준)에 의해 작은 값부터 큰 값(오름차순 : ascending), 또는 그 반대의 순서대로(내림차순 : descending) 재배열하는 알고리즘

### 버블 정렬_ Bubble Sort

: 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨
- 시간 복잡도 : O(n^2)
    - 1 Pass
    
    ![image.png](attachment:321579dd-cb44-4fa3-88dd-8fa327ff9bb0:image.png)
    
    - 2 Pass
    
    ![image.png](attachment:9c81e838-56fe-411c-aa7c-21680c5287d4:image.png)
    
    - 3 Pass
    
    ![image.png](attachment:dc797e7b-8fce-4266-8f07-ead0def1147f:image.png)
    
    - 4 Pass
    
    ![image.png](attachment:fc62907a-8d4d-48d8-ba75-b319a08765dd:image.png)
    
    - 정렬 끝
    
    ![image.png](attachment:9a7d0761-3047-4225-ac56-070d788fed6a:image.png)
    
    **버블 정렬 의사코드(pseudocode) 구현**
    
    ![image.png](attachment:1dc70ea3-647f-4871-b0ab-18332056c617:image.png)
    
    **버블 정렬 코드 구현**
    
    ![image.png](attachment:e0cd1c61-5e13-4804-8c43-2f6facf15853:image.png)
    

### 카운팅 정렬_ Counting Sort

: 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식

: 시간 복잡도 → O(n+k) _ n은 리스트 길이, k는 정수의 최댓값

**카운팅 정렬 제한 사항**

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    
    : 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
    
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
    - 1 Pass : DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장
    
    ![image.png](attachment:4bfd9c5e-b42b-4f0e-b579-ee74ffb036da:image.png)
    
    - 2 Pass : 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정
    
    ![image.png](attachment:ae122508-d0e4-47bb-a14c-e33610c117ba:image.png)
    
    - 3 Pass : DATA의 마지막 원소 1의 발생 횟수 COUNTS[1]을 감소시키고 TEMP에 1을 삽입함
    
    ![image.png](attachment:2bc9c174-0bd1-4afa-b03c-37b112eca79a:image.png)
    
    - 3 Pass : COUNTS[4]를 감소시키고 TEMP에 4를 삽입함
    
    ![image.png](attachment:287f86a0-59c9-4fbc-b973-9b5e0ac79d6b:512e104a-348b-4384-8bbf-35884e8ef952.png)
    
    - 3 Pass : COUNTS[2]를 감소시키고 TEMP에 2를 삽입함
    
    ![image.png](attachment:dc8730f0-9f76-4603-abfb-99fe62223557:47c7ba70-3c57-45f5-b098-20b46d5edc35.png)