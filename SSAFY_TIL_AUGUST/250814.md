## 250814

### [Objectives_ 학습 목표]

- 스택을 활용한 계산기 프로그램을 만들 수 있음
- 백트래킹 기법과 그 활용 예를 설명할 수 있음
- 분할 정복 알고리즘을 이해하고 활용할 수 있음

---

### Stack 계산기

### 후위 표기법 변환

**문자열로 된 계산식**

- Stack을 이용하여 값을 계산할 수 있음
- 문자열 수식 계산의 일반적인 방법
    1. 중위 표기법의 수식을 후위 표기법으로 변경(stack 이용)
    2. 후위 표기법의 수식을 stack을 이용하여 계산

**중위 표기법의 후위 표기법 변환 방법1**

1. 수식의 각 연산자에 대해 우선순위에 따라 괄호를 사용하여 다시 표현함
2. 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킴
3. 괄호를 제거
    
    ex)
    
    1. ((A * B) - (C / D))
    2. ((A B) * (C D)/)-
    3. AB*CD/-

**중위 표기법의 후위 표기법 변환 방법2(stack 이용)**

1. 입력 받은 중위 표기법에서 토큰을 읽음
2. 토큰이 피연산자면 토큰을 출력
3. 토큰이 연산자(괄호 포함)일 때
    1. 토큰이 스택의 top에 저장되어 있는 연산자보다 우선순위가 높으면 스택에 push
    2. 그렇지 않으면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push
    3. 만약 top에 연산자가 없으면 push함
4. 토큰이 오른쪽 괄호 ‘)’이면 스택 top에 왼쪽 괄호 ‘(’가 올 때까지 스택에 pop 연산을 수행하고 pop한 연산자를 출력함. 왼쪽 괄호를 만나면 pop만 하고 출력하지 않음
5. 중위 표기법에 더 읽을 것이 없다면 중지하고, 더 읽을 것이 있다면 1부터 다시 반복
6. 스택에 남아 있는 연산자를 모두 pop하여 출력
    - 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 괄호는 우선 순위가 가장 낮음

![image.png](attachment:50819d36-6ceb-4d1f-b075-a43defc04919:image.png)

![표기법 변환 개요 1](attachment:68fb8523-a478-40a8-9518-890cb51f69bc:image.png)

표기법 변환 개요 1

![표기법 변환 개요 2](attachment:59952940-d219-4c02-ab58-0dd090d0695d:image.png)

표기법 변환 개요 2

![표기법 변환 개요 3](attachment:3f483698-cd5a-48b9-b516-8c0fa83fb88d:image.png)

표기법 변환 개요 3

![표기법 변환 개요 4](attachment:ab98061a-40ce-4756-a31f-62f29267a5ca:image.png)

표기법 변환 개요 4

![표기법 변환 개요 5](attachment:87f84cc3-dcc7-4370-a750-d59c9083c6a2:image.png)

표기법 변환 개요 5

![표기법 변환 개요 6](attachment:a487bf59-47bf-4269-80b3-4d8ff1815685:image.png)

표기법 변환 개요 6

![표기법 변환 개요 7](attachment:2a853234-b454-4f66-a3da-10547dc6edb9:image.png)

표기법 변환 개요 7

![표기법 변환 개요 8](attachment:aa2b2842-2338-4e7f-a8fc-6a1c2f13b33f:image.png)

표기법 변환 개요 8

![표기법 변환 개요 9](attachment:ef1b2dcd-2e0a-4bb0-967b-adbf3f3faca7:image.png)

표기법 변환 개요 9

![표기법 변환 개요 10](attachment:62ca62c9-085f-4ae4-9b26-64ca5b0fc43a:image.png)

표기법 변환 개요 10

![표기법 변환 개요 11](attachment:74b897a9-d024-4ead-8f6e-d05fca357d4c:image.png)

표기법 변환 개요 11

![표기법 변환 개요 12](attachment:5c75f19b-c431-42d7-8721-8ffc84093ae2:image.png)

표기법 변환 개요 12

![표기법 변환 개요 13](attachment:600b0b71-ce82-4843-9a0c-b541772a5511:image.png)

표기법 변환 개요 13

![표기법 변환 개요 14](attachment:61a23c78-a122-4f59-92c4-1425e9e7547d:image.png)

표기법 변환 개요 14

![표기법 변환 개요 15](attachment:62e43b41-01e4-4acc-9fb0-65f7b8416a93:image.png)

표기법 변환 개요 15

### 후위 표기법 연산

**후위 표기법 식을 Stack을 이용한 계산**

1. 피연산자를 만나면 스택에 push함
2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산 결과를 다시 스택에 push함
3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력

![연산과정 1](attachment:cd403079-ff53-4960-8bd7-2d126f75d7a9:image.png)

연산과정 1

![연산과정 2](attachment:de4d18e0-6e8a-4268-a254-1d8c8562f9e3:image.png)

연산과정 2

![연산과정 3](attachment:095e4ec5-3d55-491e-aea0-aea88545afbd:image.png)

연산과정 3

![연산과정 4](attachment:60830323-4ae7-4e69-83ea-1c6b2add7ac1:image.png)

연산과정 4

![연산과정 5](attachment:7195ed81-e017-457c-a07a-40e210715f1b:image.png)

연산과정 5

![연산과정 6](attachment:3adc92ca-fe10-402a-8960-b7f37028f06b:image.png)

연산과정 6

![연산과정 7](attachment:7ecab3e8-0889-48ba-92bf-09428fac2f30:image.png)

연산과정 7

---

### Stack 응용

### Backtracking

: 후보해를 구성해 나가다가, 더 이상 해가 될 수 없다고 판단되면 되돌아가서(backtrack) 다른 경로를 시도하는 방법

- 문제 해결을 위한 탐색 알고리즘의 하나
- 가능성이 없는 경로는 더 이상 탐색하지 않고 되돌아가면 해결책을 찾는 방식
- 최적화(optimization) 문제와 결정(decision) 문제에 적용
- 적용 예
    - N-Queens 문제
    - 미로 찾기
    - 순열 / 조합 생성
    - 부분 집합 탐색
    - 스도쿠 풀이 등
    
    *결정 문제 : 문제의 조건을 만족하는 해가 존재하는 지의 여부를 ‘yes’ 또는 ‘no’가 답하는 문제
    

**Backtracking과 DFS와의 차이**

- Prunning(가지치기) 유무
    
    : Backtracking은 어떤 node에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않고 시도를 줄임
    
- 조기 경로 차단
    
    : DFS는 모든 경로를 추적하지만, Backtracking은 불필요한 경로를 조기에 차단함
    
- 경우의 수가 많은 경우
    
    : 예를 들어 N!인 경우의 수를 가진 문제에 대해 DFS를 가하면 처리가 불가능함
    
    : Backtracking을 적용하면 일반적으로 경우의 수가 줄어들지만, 최악의 경우 지수함수 시간(Exponential Time)을 요하므로 처리가 불가능함
    

**Backtracking 기법**

- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 이동
- 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해답의 가능성이 있으면 유망하다고 함
- 가지치기(prunng) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음

**Backtacking 진행 절차**

1. 상태 공간 트리의 DFS 실시
2. 각 node가 유망한가 점검
3. 만일 그 node가 유망하지 않으면, 해당 node의 부모 node로 돌아감
4. 돌아간 node에서 검색을 계속함

**미로 찾기 알고리즘**

![image.png](attachment:9401dec4-922d-4918-92ad-410af7e35857:image.png)

![image.png](attachment:b8f35fef-c595-4757-8876-ff9afb906c9c:image.png)

→ Stack을 이용하여 지나온 경로를 역으로 되돌아 감

![image.png](attachment:954d5de5-5588-418e-9826-996f68568598:image.png)

→ 가능한 경로 찾기

**일반 Backtracking 알고리즘**

```python
def checknode(v):    # node
		if promising(v):
				if there is a solution at v:
						write the solution
				else:
						for u in each child of v:
								checknode(u)
```

**n-Queen 문제**

![image.png](attachment:913a99c1-8c1d-4a38-80d9-d89db2ccf99e:image.png)

![image.png](attachment:4ed897d8-5721-4fc6-811c-26f4c4efa8c1:image.png)

**상대 공간 트리**

![image.png](attachment:cbaa7cfb-3539-4b8f-8300-940cbf3378c5:b92753f3-ab6b-4860-a48d-84ec0972c159.png)