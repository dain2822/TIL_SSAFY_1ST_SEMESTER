---

## 250819

---

### [Objectives_ 학습 목표]

- 스택을 활용한 계산기 프로그램을 만들 수 있음
- 백트래킹 기법과 그 활용 예를 설명할 수 있음
- 분할 정복 알고리즘을 이해하고 활용할 수 있음

---

### [Build_ 이론]

### 부분 집합_ powerset

: 어떤 집합의 공집합과 자기 자신을 포함한 모든 부분

→ 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 수는 $2**n$개

### Backtracking 기법으로 powerset 만들기

- N개의 원소가 들어있는 집합의 2**n개의 부분집합을 \
    - True 또는 False값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법 이용
- 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값

![image.png](attachment:23d8516c-246d-41f9-b79d-c44f485ec20b:image.png)

**각 원소가 부분집합에 포함되었는 지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법**

```python
bit = [0, 0, 0, 0]
for i in range(2):
		bit[0] = i    # 0번째 원소
		for j in range(2):
				bit[1] = j    # 1번째 원소
				for k in range(2):
						bit[2] = k    # 2번째 원소
								for l in range(2):
										bit[3] = l    # 3번째 원소
										print(bit)    # 생성된 부분집합 출력
```

**{1, 2, 3}의 부분집합 표현**

![image.png](attachment:626fab90-a4fa-44e5-b51b-0eac2ad6c55d:image.png)

**Backtracking과 부분집합**

![image.png](attachment:18f0766d-8940-4de2-b907-50a9b3a2b0e0:image.png)

**Powerset을 구하는 Backtracking 알고리즘 1**

```python
def backtrack(a, k, n):    # a : 주어진 배열, k : 결정할 원소, n : 원소 개수
		c = [0] * MAXCANDIDATES
		
		if k == n:
				process_solution(a, k)    # 답이면 원하는 작업을 함
		else:
				ncandidates = construct_candidates(a, k, n, c)
				for i in range(ncandidates):
						a[k] = c[i]
						backtrack(a, k + 1, n)
```

**Powerset을 구하는 Backtracking 알고리즘 2**

```python
def construct_candidates(a, k, n, c):
		c[0] = True
		c[1] = False
		return 2

def process_solution(a, k):
		for i in range(k):
				if a[i]:
						print(num[i], end = ' ')
		print()
```

**Powerset을 구하는 Backtracking 알고리즘 3**

```python
MAXCANDIDATES = 2
NMAX = 4
a = [0] * NMAX
num = [1, 2, 3, 4]
backtrack(a, 0, 3)
```

---

### 순열1

**단순하게 순열을 생성하는 방법**

```python
for i1 in range(1, 4):
		for i2 in range(1, 4):
				if i2 != i1:
						for i3 in range(1, 4):
								if i3 != i1 and i3 != i2:
										print(i1, i2, i3)
```

→ 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop를 이용하여 표현할 수 있음

**Backtracking과 순열**

![image.png](attachment:5d86275f-0ac6-4e66-a988-b7f578b08044:image.png)

**Backtracking을 이용하여 {1, 2, 3, … , NMAX}에 대한 순열 구하기1**

```python
def backtrack(a, k, n):
		c = [0] * MAXCANDIDATES
		
		if k == n:
				for i in range(0, k):
						print(a[i], end = ' ')
				print()
		else:
				ncandidates = construct_candidates(a, k, n, c)
				for i in range(ncandidates):
						a[k] = c[i]
						backtrack(a, k + 1, n)
```

**Backtracking을 이용하여 {1, 2, 3, … , NMAX}에 대한 순열 구하기2**

```python
def construct_candidates(a, k, n, c):
		in_perm = [False] * (NMAX + 1)
		
		for i in range(k):
				in_perm[a[i]] = True
				
		ncandidates = 0
		for i in range(1, NMAX + 1):
				if in_perm[i] == False:
						c[ncandidates] = i
						ncandidates += 1
		return ncandidates
```

**Backtracking을 이용하여 {1, 2, 3, … , NMAX}에 대한 순열 구하기3**

```python
MAXCANDIDATES = 3
NMAX = 3
a = [0] * NMAX
backtrack(a, 0, 3)
```

---

### 가지치기

**부분집합의 합**

- 집합 {1, 2, 3}의 원소에 대해 각 부분집합에서의 포함 여부를 트리로 표현

![image.png](attachment:02dd60fb-185b-4b70-91f4-bae1cb70071c:image.png)

- I원소의 포함 여부를 결정하면 i까지의 부분집합의 합 $Si$를 결정할 수 있음
- $S(i-1$)이 찾고자 하는 부분집합의 합보다 크면 남은 원소를 고려할 필요가 없음

![image.png](attachment:0417be9f-f012-4cd0-bf2a-d5380f869b26:image.png)

- A[i] 원소를 부분집합의 원소로 고려하는 재귀 함수(A는 서로 다른 자연수의 집합)

![image.png](attachment:18c8dfc1-6286-4567-bb39-08a4cbf77734:image.png)

```python
# i-1 원소까지 고려한 합 s, 찾으려는 합 t

f(i, N, s, t)
		if s == t    # i-1 원소까지의 합이 찾는 값인 경우
				...
		elif i == N    # 모든 원소에 대한 고려가 끝난 경우
				...
		elif s > t    # 남은 원소를 고려할 필요가 없는 경우
				...
		else    # 남은 원소가 있고 s < t인 경우
				subset[i] = 1
				f(i+1, N, s+A[i], t)    # i원소 포함
				subset[i] = 0
				f(i+1, N, s, t)    # i원소 미포함
```

- 추가 고려 사항

![image.png](attachment:3fcc8084-b75e-42d4-b80a-170f39d1d28b:image.png)

---

### 순열2

**A[1, 2, 3]의 모든 원소를 사용한 순열**

- 3개의 칸에 넣을 수 있는 수를 나열
- 123, 132, 231, 213, 312, 321 → 총 6가지의 경우

![image.png](attachment:f7cbe160-609d-4368-afa2-2a8246d64cbb:image.png)

**자리 교환으로 순열 생성 1**

![image.png](attachment:def2c9d5-f07a-454b-ac5d-0f1bbc771375:image.png)

**자리 교환으로 순열 생성 2**

![image.png](attachment:80f1aa6e-f521-4b8b-9c57-d6f77d484f74:image.png)

---

### 분할 정복

**설계 전략**

- 분할(Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복(Conquer) : 나눈 작은 문제를 각각 해결함
- 통합(Combine) : (필요하다면) 해결된 해답을 모음

**거듭 제곱(Exponentitation)**

- $O(n)$

![image.png](attachment:43bdf276-a29b-44af-8047-1c76b15a4a03:image.png)

**분할 정복 기반 알고리즘**

- $O(log2n)$

![image.png](attachment:47e9ee98-b93c-4399-b81d-d39759b97374:image.png)

![image.png](attachment:19a9a8b2-d017-4d97-950c-115a03d47882:image.png)

```python
def power(base, exponent):
		if exponent == 0:
				return 1
				
		if exponent % 2 == 0:
				new_base = power(base, exponent // 2)
				return new_base * new_base
		else:
				new_base = power(base, (exponent-1) // 2)
				return (new_base * new_base) * base
```
