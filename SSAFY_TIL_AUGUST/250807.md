---

## 250807

---

### [Objectives_ 학습 목표]

- 부분 집합을 구하는 알고리즘을 이해하고 활용할 수 있음
- 검색의 개념을 설명할 수 있음
- 인덱스 개념을 이해하고 활용할 수 있음
- 셀렉션 알고리즘에 대해 설명할 수 있음
- 선택 정렬을 이해하고 활용할 수 있음

---

### [Build_ 이론]

### 부분집합

: 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 $2^n$개

→ 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음

ex) {1,2,3,4}

→ $2 * 2 * 2 * 2 = 16$가지

**부분집합의 원소를 표현하는 방법**

![image.png](attachment:94210317-7cff-4d25-ad97-e6c6309f6af9:image.png)

arr[i] 원소가 부분집합에 포함되지 않으면 bit[i] == 0

arr[i] 원소가 부분집합에 포함되면 bit[i] == 1

**각 원소가 부분집합에 포함되어있는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법**

```python
#def print_subset(bit):
#		for i in range(4):
#				if bit[i]:   # bit[i]가 0이 아니면(True)
#						print(arr[i], end = ' ')
#		print()

arr = [7, 5, 8, 1]

bit = [0, 0, 0, 0]
for i in range(2):
		bit[0] = i    # 0번 원소
		for j in range(2):
				bit[1] = j    # 1번 원소
				for k in range(2):
						bit[2] = k    # 2번 원소
						for l in range(2):
								bit[3] = l    #3번 원소
								print(bit)
								# print_subset(bit)   # 생성된 부분집합 출력
```

**비트 연산자**

- & : 비트 단위로 AND 연산
- |  : 비트 단위로 OR 연산
- << : 피연산자의 비트 열을 왼쪽으로 이동
- >> : 피연산자의 비트 열을 오른쪽으로 이동
    - << 연산자 활용
        
        : `$1<<n$` → $2^n$ 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미
        
    - & 연산자 활용
        
        : `i&(1<<j)` → i의 j번째 비트가 1인지 아닌지를 검사
        

**비트 연산으로 부분집합을 생성하는 방법**

```python
arr = [3, 6, 7, 1, 5, 4]

n = len(arr)    # n : 원소의 개수

for i in range(1<<n):    # 1<<n : 부분 집합의 개수
		for j in range(n):    # 원소의 수만틈 비트를 비교함
				if i & (1<<j):    # i의 j번 비트가 1인 경우
						print(arr[j], end = ',')    # j번 원소 출력
		print()
print()
```

### 순차 검색_ Sequential Search

: 일렬로 되어 있는 자료를 순서대로 검색하는 방법

- 가장 간단하고 직관적인 검색 방법
- 배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함
- 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우 수행시간이 급격히 증가하여 비효율적임
- 정렬 여부에 따라
    - 순차 검색 대상이 정렬되어 있지 않은 경우
    - 순차 검색 대상이 정렬되어 있는 경우

**검색_Search**

: 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

: 목적하는 탐색 키를 가진 항목을 찾는 것

: 순차 검색(sequential search), 이진 검색(binary search), 해쉬(hash)

**탐색 키_Search Key**

: 자료를 구별하여 인식할 수 있는 키

**정렬되어 있지 않은 경우 순차 검색**

- 검색 과정
    - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾음
    - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환함
    - 자료 구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패
- 검색 성공

![image.png](attachment:a9a662de-238b-440f-b823-802c0be5addc:image.png)

- 검색 실패

![image.png](attachment:d1b9cec8-b36e-4f92-9e8e-5873c8f56a6b:image.png)

- 찾고자 하는 원소의 순서에 따라 비교 횟수가 결정됨
    - 첫 번째 원소를 찾을 때는 1번 비교, 두 번째 원소를 찾을 때는 2번 비교 …
    - 정렬되지 않은 자료에서의 순차 검색 성공 시 평균 비교 횟수
        
        $= (1 / n) * (1 + 2 + 3 + … + n) = (n + 1) / 2$
        
    - 검색 실패 시 마지막 원소까지 비교하므로 평균 비교 횟수  $= n$
    - 시간 복잡도 : $O(n)$

```python
def sequential_search(a, n, key)   # a : 자료, n : 자료 길이, key : 찾을 대상
		i <- 0
		while i < n and a[i] != key:
				i <- i + 1
		if i < n : return i
		else : return -1
```

```python
for i in range(n):
		if key == arr[i]:
				return i
		else:
				return -1
```

**순차 검색 대상이 정렬되어 있는 경우**

- 검색 과정
    - 자료가 오름차순으로 정렬된 상태에서 검색을 실시
    - 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상을 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색하지 않고 검색을 종료함
- 검색 성공

![image.png](attachment:af991b45-86a3-47ed-95c3-ecd13345f31d:image.png)

- 검색 실패

![image.png](attachment:7ff5886f-675a-41c1-9824-9321caf1dcfb:image.png)

- 찾고자 하는 원소의 순서에 따라 비교 횟수가 결정됨
    - 정렬이 되어 있으므로, 검색 실패를 반환하는 경우에도 평균 비교 횟수가 반으로 줄어듦
        
        → $(n + 1) / 2$
        
    - 시간 복잡도 : $O(n)$

```python
def sequentialSearch2(a, n, key)
		i <- 0
		while i < n and a[i] < key:
				i <- i + 1
		if i < n and a[i] == key:
				return i
		else:
				return -1
```

### 이진 검색_ Binary Search

: 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행

→ 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행

: 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 함

- 검색 과정
    - 자료의 중앙에 있는 원소를 고름
    - 중앙 원소의 값과 찾고자 하는 목표 값을 비교
    - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해 새로 검색을 수행
    - 찾고자 하는 값을 찾을 때까지 이전 과정들을 반복

![image.png](attachment:d5f4f14a-ca42-45b9-addd-0dd478bb8f2f:image.png)

![image.png](attachment:6d8a8c2e-f381-4bb1-8b9d-100b3c222b9f:image.png)

- 구현
    - 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행
    - 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업이 필요함

```python
def binarySearch(a, N, key):    # key를 찾으면 인덱스, 실패하면 -1 반환
		start = 0
		end = N - 1
		while start <= end:
				middle = (start + end) // 2
				if a[middle] == key:    # 검색 성공
						return middle
				elif a[middle] > key:    # 찾는 값보다 큰 경우
						end = middle - 1    # 왼쪽 구간 선택
				else:    # 찾는 값보다 작은 경우
						start = middle + 1    # 오른쪽 구간 선택
		return -1
```

**재귀 함수 이용**

```python
def binarySearch2(a, low, high, key):
		if low > high:    # 검색 실패
				return False
		else:
				middle = (low + high) // 2
				if key == a[middle]:    # 검색 성공
						return True
				elif key < a[middle]:
						return binarySearch2(a, low, middle - 1, key)
				elif a[middle] < key:
						return binarySearch2(a, middle + 1, high, key)
```

**인덱스**

- 원본 데이터 배열과 별개로 배열 인덱스를 추가한 예
    - 원본 데이터에 데이터가 삽입될 경우 상대적으로 크기가 작은 인덱스 배열을 정렬하기 때문에 속도가 빠름
    
    ![image.png](attachment:b52dd655-9d17-4eba-a103-a995af1d7cb5:image.png)
    

: Database에서 유래한 용어로, 테이블에 대한 동작 속도를 높여주는 자료 구조

: Database 분야가 아닌 곳에서는 Lookup table이라고도 함

: 인덱스를 저장하는데 필요한 디스크 공간은 보통 테이블을 저장하는데 필요한 디스크 공간보다 작음

→ 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문임

→ 대량의 데이터를 매번 정렬하면 프로그램의 반응이 느려짐

→ 대량 데이터의 성능 저하 문제를 해결하기 위해 배열 인덱스를 사용(DB 인덱스는 이진 탐색 트리 구조)

### 선택 정렬

![image.png](attachment:b84eb102-db06-4643-bec5-708d443672bb:image.png)

: 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식(오름차순의 경우)

: 시간 복잡도_ $O(n^2)$

- 정렬 과정
    - 주어진 리스트 중 최소값 찾기
    - 리스트의 맨 앞에 위치한 값과 교환
    
    ![image.png](attachment:8a358818-7798-40ba-8479-0f307adeaadc:image.png)
    
    - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정 반복
        - 미정렬 리스트에서 최소값을 찾음
        - 리스트의 맨 앞에 위치한 값과 교환

![image.png](attachment:a42ec3c2-593e-47f5-94bf-8c881c0c4aaa:image.png)

![image.png](attachment:e87a46fd-c1a5-4c24-a7c4-5df097233742:image.png)

```python
selection_sort(a[], n):
		for i: 0 -> n - 2
				a[i], ..., a[n - 1] 원소 중 최소값 a[k]를 찾음
				a[i]와 a[k]를 교환
```

```python
def selection_sort(a, N):
		for i in range(N - 1):    # 정렬 구간의 시작 인덱스
				min_idx = i    # 첫 원소를 최소로 가정
				for j in range(i + 1, N):
						if a[min_idx] > a[j]:    # 최소 원소 위치 갱신
								min_idx = j
				a[i], a[min_idx] = a[min_idx], a[i]    # 구간 최소값을 구간 맨 앞으로
```

### 셀렉션 알고리즘_Selection Algorithm

: 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법

→ 최소, 최대 혹은 중간값을 찾는 알고리즘을 의미하기도 함

- 선택 과정
    - 정렬 알고리즘을 이용하여 자료 정렬
    - 원하는 순서에 있는 원소 가져오기

**K번째로 작은 원소를 찾는 알고리즘**

: 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞쪽으로 이동시키고, 배열의 k번째를 반환

: k가 비교적 작을 때 유용하며 $O(kn)$의 수행시간을 필요로 함

```python
def select(arr, k):
		for i in range(0, k):
				min_index = i
				for j in range(i + 1, len(arr)):
						if arr[min_index] > arr[j]:
								min_index = j
				arr[i], arr[min_index] = arr[min_index], arr[i]
		return arr[k - 1]
```