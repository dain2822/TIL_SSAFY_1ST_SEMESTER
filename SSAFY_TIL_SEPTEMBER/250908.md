---

## 250908

---

### [Objectives_ 학습 목표]

- 탐욕 알고리즘 기법의 개념과 특성에 대해 학습함
- 탐욕적 선택이 항상 최적해를 찾는다고 보장할 수 없음을 이해함
- 최적화 문제가 탐욕적 선택 속성과 최적 부분 구조를 가질 때 탐욕 기법이 적용 가능하다는 것을 이해함
- 동전 거스름돈 문제, 배낭 문제, 활동 선택 문제에 대해 알아보고 탐욕 알고리즘을 적용해 봄

---

### [Build_ 이론]

### 부분 집합_ powerset

: 어떤 집합의 공집합과 자기 자신을 포함한 모든 부분

→ 구하고자 하는 어떤 집합의 원소가 n개일 경우 부분 집합의 수는 $2^n$개임

- 집합에 포함된 원소들을 선택하는 것
    - 부분 집합 예시
        
        : 오른쪽 표는 집합 {A, B, C}로 만들 수 있는 부분 집합의 예시
        
        : 부분 집합에는 아무것도 선택하지 않은 경우도 포함됨(공집합)
        
        ex) {A, B, C}
        
        → {}, {A}, {B}, {C}, {A, B}, {A, C}, {B, C}, {A, B, C}
        
- 집합에서 부분 집합을 찾아내는 구현 방법
    1. 완전 탐색
        1. 재귀 호출을 이용하는 완전 탐색으로, 부분 집합을 구할 수 있음
        2. 실전보다는 완전 탐색 학습용으로 추천
    2. Binary Counting
        1. 2진수 & 비트 연산을 이용하여, 부분 집합을 구할 수 있음
        2. 모든 부분 집합이 필요할 때 사용을 추천
    

**완전 탐색으로 부분 집합 구하기**

: 민철이에게는 세명의 친구가 있음 {MIN, CO, TIM}

→ 함께 영화관에 갈 수 있는 멤버를 구성하고자 할 때 모든 경우의 수를 출력

- O, X로 집합에 포함시킬 지 말지 결정

![image.png](attachment:3ab2557a-a036-4813-8319-bd4735af50ff:image.png)

Path배열은 [X, O, O]가 됨

→ MIN을 제외하고 {CO, TIM}이 선택

```python
arr = ['O', 'X']
path = []
name = ['MIN', 'CO', 'TIM']

def run(lev):
		if lev == 3: 
				print(path)
				return
		for i in range(2):
				path.append(arr[i])
				run(lev + 1)
				path.pop()
run(0)
```

```python
# 출력 결과

['O', 'O', 'O']
['O', 'O', 'X']
['O', 'X', 'O']
['X', 'O', 'O']
['X', 'O', 'X']
['X', 'X', 'O']
['X', 'X', 'X']
```

```python
arr = ['O', 'X']
path = []
name = ['MIN', 'CO', 'TIM']

def print_name():
		print('{', end='')
		for i in range(3):
				if path[i] == 'O':
						print(name[i], end=' ')
		print('}')

def run(lev):
		if lev == 3: 
				prin_name()
				return
		for i in range(2):
				path.append(arr[i])
				run(lev + 1)
				path.pop()
run(0)
```

```python
# 출력 결과

{MIN CO TIM}
{MIN CO}
{MIN TIM}
{MIN}
{CO TIM}
{CO}
{TIM}
{}
```

**바이너리 카운팅(Binary Counting)**

- 원소 수에 해당하는 N개의 비트열을 이용해 부분집합을 표시
- 001이면 부분 집합 {A}를 나타냄
    - 0번 비트가 1이므로 첫 원소인 A만 포함된 부분 집합을 나타냄
- 110이면 부분 집합 {B, C}를 나타냄
    - 1번, 2번 비트가 1이므로, 두번째와 세번째 원소인 B, C가 포함된 부분 집합을 나타냄

![image.png](attachment:2b019eb1-5f90-48c2-a4ae-b220904b687b:image.png)

→ 만들 수 있는 집합의 총 개수는 $2^n$이며 n = 3이므로 총 8개의 부분 집합이 존재

→ 2^n은 1<<n 공식을 이용하여 빠르게 구할 수 있음

```python
print(pow(2,3))    # 8
print(1<<3)    # 8
```

- 부분 집합 {B, C}를 만드는 과정
    - 6(0b110)에서 비트 연산을 이용하여 마지막 한 자리가 1인지 0인지 검사

```python
arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
		for i in range(n):
				if tar & 0x1:
						print(arr[i], end='')
				tar >>= 1    # 검사한 한 자리 제거
get_sub(6)
```

![image.png](attachment:f695eb30-5f51-4b47-8175-3ec8900b3543:image.png)

```python
arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
		for i in range(n):
				if tar & 0x1:
						print(arr[i], end='')
				tar >>= 1
				
for tar in range(1<<n):    # range(0,8)
		print('{', end='')
		get_sub(tar)
		print('}')
```

```python
# 출력 결과

{}
{A}
{B}
{AB}
{C}
{AC}
{BC}
{ABC}
```

---

### 조합_ Combination

: 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

- 순열과 조합 차이
    - 순열
        
        : {A, B, C, D, E} 5명 중 1등, 2등, 3등 뽑기 (순서 O)
        
        $nPr = n! / (n-r)!$ (단, n ≥ r)
        
    - 조합
        
        : 5명 중 3명 뽑기 (순서 X)
        
        $nCr = n! / (n-r)!r!$ (단, n ≥ r)
        
        $nCr = n-1Cr-1 + n-1Cr + … + nC0 = 1$
        

---

### 탐욕 알고리즘_ Greedy

: 결정이 필요할 때, 현재 기준으로 가장 좋아 보이는 선택지로 결정하여 답을 도출하는 알고리즘

**대표적인 문제 해결 기법**

1. 완전 탐색(Brute-Force)
    
    : 답이 될 수 있는 모든 경우를 시도해보는 알고리즘
    
2. Greedy
    
    : 결정이 필요할 때 가장 좋아 보이는 선택지로 결정하는 알고리즘
    
3. DP
    
    : 현재에서 가장 좋아 보이는 것을 선택하는 것이 아닌, 과거의 데이터를 이용하여 현재의 데이터를 만들어내는 문제 해결 기법
    
4. 분할 정복
    
    : 큰 문제를 작은 문제로 나누어 해결하는 문제 해결 기법
    