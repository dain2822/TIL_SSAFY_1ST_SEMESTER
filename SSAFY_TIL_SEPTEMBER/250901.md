## 250901

### [Objectives_ 학습 목표]

- 문제 해결 방법을 논리적으로 설명할 수 있음
- 명제와 논리, 증명의 기본 개념을 설명할 수 있음
- 집합과 조합의 개념을 바탕으로 문제를 해결할 수 있음
- 재귀 호출의 원리와 동작을 설명할 수 있음
- 조합론을 적용해 문제를 해결할 수 있음

---

### [Build_ 이론]

### 프로그래밍과 논리 / 수학

**논리(Hard Logic)의 정의**

: 생각이나 주장의 타당성과 옳고 그름을 판별하는 규칙이나 원리

: 경험적, 직관적, 확률적 판단을 의미하는 soft logic에 반대되는 의미로 hard logic이라고 표현함

→ 맞는 이유와 틀린 이유를 정확히 밝히는 생각의 규칙

**프로그래밍의 어려운 점**

- 프로그래밍 언어 문법과 라이브러리 사용
    - 처음 보는 사람은 알 수 없음
    - 훈련에 비례하여 실력이 늘게 됨
- 논리
    - 직관적인 접근을 논리로 착각하기 쉬움

**카드 문제**

- 직관으로 접근하면 어려운 문제
- 사실 : 모든 카드의 한쪽에는 알파벳이, 다른 쪽에는 숫자가 써있음
- 주장 : 한 쪽이 D이면 반대쪽은 3

Q. 주장이 사실인지 확인하기 위해 다음 카드들 중 반드시 뒤집어 보아야 하는 것은 몇 개이고 어느 것인가?

![image.png](attachment:0e6bc502-ae7f-4a46-9bb3-49c12bb3e265:image.png)

⇒ [D]와 [7]

→ [D]를 뒤집어 보아야 한다는 것은 누구나 알아냄

→ [3] 뒤에는 [D]가 있든 없든 주장이 사실인지 여부에 영향이 없음

→ [7] 뒤에 [D]가 있으면 주장이 성립하지 않게 됨

**맥주집 문제**

- 규칙 : 20세 이하인 사람은 맥주를 마실 수 없음

Q. 나이 혹은 마시고 있는 것을 표시한 다음 4명 중 확인이 필요한 사람은 몇 명이고 누구인가?

⇒ [17세]와 [맥주]

**Soft Logic**

- 맥주집 문제를 풀 때 직관을 사용한 것과 같은 경우
- 직관은 논리적인 느낌을 주는 것
- 직관의 장점은 (익숙한 상황에서) 빠름
- 직관의 단점은 정확하지 않음(가끔은 익숙한 상황에서도 틀림)
- 또 다른 단점은 강한 착각을 일으킨다는 것

### Hard Logic vs. Soft Logic

- 일상 생활
    - Soft Logic이 빠르기 때문에 유용함
    - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 이미 알고 있다는 가정이 존재함
- 프로그래밍
    - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것임
    - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요함
- 문제에 대해 오해하는 경우
    - Soft Logic으로 알고리즘을 이해하려고 하는 경우
    - 알고리즘 설명을 보고 또 봐도 이해가 되지 않는 것은 증명을 보지 않았기 때문임
    - 증명을 봐도 이해가 안 되는 것은 직관으로 이해하려 하기 때문임
    - 가끔 직관적으로 이해되는 알고리즘이 있지만, 조금만 어려워지면 직관으로 완전한 이해를 얻는 것은 사실상 불가능함

### 명제

: 참이나 거짓을 알 수 있는 식이나 문장

: p, q, r, … 로 표현

ex) 서울은 대한민국의 수도이다. / 1 + 1 = 3

- 진리값
    
    : 참이나 거짓을 표현
    
    : T, F 또는 1, 0
    
    ex) p가 거짓(F), q가 참(T)
    

**명제의 연산(결합)**

- 부정(NOT)
    - p가 명제일 때, 명제의 진릿값이 반대가 됨
    - ~p 또는 ¬p로 표기하고, not p 또는 p의 부정으로 읽음
        
        ![image.png](attachment:593d30af-eada-41be-bb47-c342caf48224:image.png)
        
- 논리곱(AND)
    - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
    - p ∧ q로 표기하고, p and q 또는 p 그리고 q로 읽음
        
        ![image.png](attachment:0fe7ba0d-683e-494e-88c8-ccbd1cd7f563:image.png)
        
- 논리합(OR)
    - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
    - p ∨ q로 표기하고, p or q나 p 또는 q로 읽음
        
        ![image.png](attachment:d2d5a1cd-e4ee-4dbc-8125-e49700495dd7:image.png)
        
- 배타적 논리합(XOR)
    - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제임
    - p ⊕ q로 표기하고, p xor q 또는 p exclusive OR q로 읽음
        
        ![image.png](attachment:633a62c5-0ea8-4047-b8cf-43f08383bf8b:image.png)
        
- 조건 명제
    - p, q가 명제일 때, 명제 p가 조건(원인), q가 결론(결과)으로 제시되는 명제
    - p → q (p이면 q이다.)
        
        ![image.png](attachment:a99d05a7-1d2d-4d80-b0a7-ab0c8956071f:image.png)
        
- 쌍방 조건 명제
    - p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
    - p ↔ q (p면 q이고, q면 p이다.)
        
        ![image.png](attachment:42ecb97c-6e84-4af5-b66c-866132b24bdc:image.png)
        
- 조건 명제의 역, 이, 대우
    - 주어진 명제 : p → q
    - 역 : q → p
    - 이 : ~p → ~q
    - 대우 : ~q → ~p

![image.png](attachment:5f03a965-6b80-4a42-9232-01b6c429eb62:image.png)

Q. 만약 0이 홀수라면, 미국에서 2080년 월드컵이 열린다.

- p : 0은 홀수이다. (거짓)
- q : 미국에서 2080년 월드컵이 열린다. (알 수 없음)

⇒ 명제식 p→q, p 명제가 거짓이므로 q명제의 참/거짓 여부에 상관없이 해당 명제식은 참임

Q. 만약 19893827938274839이 Prime Number라면, 2는 짝수이다.

- p : 19893827938274839은 Prime Number이다. (알 수 없음)
- q : 2는 짝수이다. (참)

→ 대우 명제는 ~q → ~p인데, ~q는 ‘2가 홀수이다’가 되어 거짓인 명제가 됨

→ ~q 명제가 거짓이므로, ~p 명제의 참 / 여부에 상관 없이 해당 명제식은 참이 됨

⇒ 대우 명제식이 참이므로, 본 명제식 또한 참임

Q. p와 q가 명제이고, p → q가 거짓이라고 할 때 다음 명제식의 참, 거짓은?

→ p → q가 거짓이기 위해서는 p가 참, q가 거짓인 경우임

1. ~p → q
    
    → ~p는 거짓, q도 거짓이므로 조건 명제는 참
    
2. p V q
    
    → p가 참이고 V(OR) 연산이므로 참
    
3. q → p
    
    → q는 거짓, p는 참이므로 참
    

Q. 다음 명제들의 역, 이, 대우를 쓰시고

1. 명제(p→q) : 0이 홀수면, 미국에서 2080년 월드컵이 열린다.
- 역(q→p) : 미국에서 2080년 월드컵이 열리면, 0은 홀수이다.
- 이(~p→~q) : 0이 홀수가 아니면, 미국에서 2080년 월드컵이 열리지 않는다.
- 대우(~q→~p) : 미국에서 2080년 월드컵이 열리지 않으면, 0은 홀수가 아니다.

1. 명제(p→q) : 만약 19893827938274839이 Prime Number라면, 2는 짝수이다.
- 역(p→q) : 만약 2가 짝수이면, 19893827938274839은 Prime Number이다.
- 이(~p→~q) : 만약 19893827938274839이 Prime Number가 아니라면, 2는 홀수이다.
- 대우(~q→~p) : 2가 홀수이면, 19893827938274839이 Prime Number가 아니다.

Q. 다음 명제식의 진리표를 만드시오.

1. p∧(q→~p)
    
    ![image.png](attachment:498a1cd6-4e10-4b95-aa47-b4cb4b9c26ef:image.png)
    
2. (p∧~q)→r
    
    ![image.png](attachment:8128bfa8-33a5-4039-b76f-90d837c72bc0:image.png)
    

### 증명

- 직접 증명
    - p → q가 참임을 증명하기 위해 p를 참으로 가정했을 때 q도 참임을 증명하는 방법
    - Trivial Proof(자명한 증명) _ 직접 대입 등을 통해 알 수 있는 증명
    - Vacuous Proof(공허한 증명) _ 증명할 필요가 없이 P(x)가 거짓이라 Q(x)는 참인 증명
- 간접 증명
    - 증명해야 하는 명제를 변형하여 증명하는 방법
    - 대우에 의한 증명
    - 모순에 의한 증명
- 수학적 귀납법
    - 일정한 규칙을 나타내는 명제 P(n)이 성립함을 증명하는 방법

**Trivial Proof : ∀x, P(x) → Q(x)를 증명하려 하는데, Q(x)가 항상 참인 경우**

1. 실수 x에 대해 만약 $x < -1$이면  $x^2 + 1/4 > 0$이다.
    
    →  $x^2 + 1/4 > 0, x^2 > -1/4$이고, x는 실수이므로 Q(x)는 항상 참
    
    ⇒ ∀x, P(x) → Q(x)
    
2. n이 홀수이면 $4n^3 + 6n^2 + 12$는 짝수이다.
    
    → $4n^3 + 6n^2 + 12 = 2(2n^3 + 3n^2 +6)$이므로 $4n^3 + 6n^2 + 12$는 짝수
    
    → Q(x)는 항상 참
    
    ⇒ ∀x, P(x) → Q(x)
    

**Vacuous Proof : ∀x, P(x) → Q(x)를 증명하려 하는데, P(x)가 항상 거짓인 경우**

1. 실수 x에 대해, 만약 $2x^2 - 4x + 4 < 0$이면, $x > 8$이다.
    
    → $2x^2 - 4x + 4 = 2(x^2 - 2x) + 4 = 2(x-1)^2 + 2 ≥ 0$임
    
    → $2x^2 - 4x + 4 < 0$은 거짓
    
    ⇒ P(x)는 거짓이므로 ∀x, P(x) → Q(x)는 참
    
2. $4n^3 + 6n^2 + 11$는 짝수이면 n이 홀수이다.
    
    → $4n^3 + 6n^2 + 11 = 2(2n^3 + 3n^2 + 5) + 1$이므로 $4n^3 + 6n^2 + 11$은 홀수
    
    → P(x)는 거짓
    
    ⇒ ∀x, P(x) → Q(x)는 참
    

**수학적 귀납법과 증명의 수준**

- 0보다 크거나 같은 정수 범위에 대해 P(n)이 성립함을 증명
    - 수학적 귀납법의 기본형 : P(1)이 참이고, P(n) → P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참
    - 수학적 귀납법의 강한 형태 : P(1)이 참이고, P(1)∧P(2)∧ … ∧P(n) → P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해 참
    - ex) 다음 함수가 1부터 x까지의 합을 계산함을 증명
        
        ```python
        def sum(x):
        		if (x <= 0):
        				return 0
        		return x + sum(x-1)
        ```
        
- 상세한 증명을 하려면 단순히 “답이 맞는 것이 당연하다”라고 말하는 것으로 충분하지 않음
    - 증명이 가능한 명제를 만들어야 함
    - 증명이 가능한 명제 → “sum(x)가 리턴하는 값은 1+2+…+x의 값과 항상 같다”
    - P(1)이 참이다 : “sum(1)이 리턴하는 값은 1이다.”를 증명하면 됨
        
        → 실제 코드에 1을 대입하면 1을 리턴함을 알 수 있음
        
        ```python
        sum(1)
        		if (x <= 0) return 0
        		return 1 + sum(0)
        ```
        
- 임의의 값 k에 대해 P(k)가 참이라고 가정 : sum(k)가 1+2+…+k을 리턴
- k + 1에 대해 P(k+1)이 참이라고 증명
    
    ```python
    sum(k+1):
    		if (k+1 <= 0)
    ```
