---

## 250915

---

### [Objectives_ 학습 목표]

- 현실 세계 문제를 그래프로 추상화해서 해결하는 방법을 학습함
- 그래프 탐색 기법인 BFS와 DFS에 대해 학습함
- 그래프 알고리즘에 활용되는 상호 배타 집합(Disjoint-Sets)의 자료 구조에 대해 학습함

---

### [Build_ 이론]

### 그래프_ Graph

: 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현

→ 선형 자료 구조나 트리 자료 구조로 표현하기 어려운 N : N 관계를 가지는 원소들을 표현하기에 용이함

: 점점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료

- |V| : 정점의 개수, |E| : 그래프에 포함된 간선의 개수일 때
    
    → |V|개의 정점을 가지는 그래프는 최대 |E| = |V| * (|V| - 1) / 2개의 간선을 가질 수 있음
    
    ex) 5개 정점이 있는 그래프의 최대 간선의 수는 10(= 5 * 4 / 2)개
    

**그래프 유형**

1. 무향(무방향) 그래프(Undirected Graph)(=양방향 그래프)
    
    ![image.png](attachment:ba4d5664-c928-402f-bb45-17fbdd4da4c2:image.png)
    
2. 유향(유방향) 그래프(Directed Graph)
    
    ![image.png](attachment:f944601c-ded3-4ee0-b5e5-3812a02e2388:image.png)
    
3. 가중치 그래프(Weighted Graph)
    
    ![image.png](attachment:8b68f9bf-e27a-4dd3-808e-085dbac546f4:image.png)
    
4. 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph)
    
    ![image.png](attachment:cf836df8-0a70-496f-b05a-ed77d499d36f:image.png)
    
5. 사이클이 없는 무향 그래프(UAG, Undirected Acyclic Graph)
    
    ![image.png](attachment:7c2e6f9c-e9fc-4ccc-98db-a3f6bffd6c68:image.png)
    

1. 완전 그래프
    
    : 정점들에 대해 가능한 모든 간선들을 가진 그래프
    
2. 부분 그래프
    
    : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
    
    → 간선이 적은 그래프 : 희소 그래프
    

![image.png](attachment:96772fff-520f-4617-88fa-872c78795cb9:image.png)

**인접 정점**

- 인접(Adjacency)
    
    : 두개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 함
    
    : 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있음
    

![image.png](attachment:2460503b-040f-4ca4-9fc4-d58dd74970ae:image.png)

**그래프 경로**

- 경로 : 간선들을 순서대로 나열한 것
    - 간선들 : (0,2), (2,4), (4,6)
    - 정점들 : 0 - 2 - 4 - 6
- 경로 중 한 정점을 최대한 한 번만 지나는 경로를 단순경로라고 함
    - 0 - 2 - 4 - 6, 0 - 1 - 6
- 시작한 정점에서 끝나는 경로를 사이클(Cycle)이라고 함
    - 1 - 3 - 5 - 1

![image.png](attachment:8e3ce211-f7fa-4957-8f56-2286225f8a85:image.png)

**그래프 표현**

- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬(Adjacent matrix)
    - 각 정점마다 해당 정점과 인접한 정점 정보를 저장
- 간선의 배열
    - 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장

**인접 행렬**

: 두 정점을 연결하는 간선의 유무를 행렬로 표현

- |V| * |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
- 무향 그래프
    - i번째 행의 합 = i번재 열의 합 = Vi의 차수
        
        ![image.png](attachment:296e606d-0469-4f04-bbf2-36254c612cde:image.png)
        
- 유향 그래프
    - 행 i의 합  = Vi의 진출 차수
    - 열 i의 합 = Vi의 진입 차수
        
        ![image.png](attachment:ad61dd25-70ec-4f2a-9764-8ff289ae5e9a:image.png)
        
- 인접 행렬의 단점
    
    → 정점 수에 비해 간선 수가 적은 경우 공간 낭비가 심함
    
    ![image.png](attachment:15873350-b6c5-4800-a8b2-29439b6b9627:image.png)
    

**인접 리스트**

- 각 정점에 대한 인접 정점들을 순차적으로 표현
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
    
    ![image.png](attachment:33a4a060-242c-4d4b-817d-c8f91d5d3c6a:image.png)
    
- 무향 그래프의 인접 리스트

![image.png](attachment:35eea215-50a5-43a6-93d8-5a103c2f003e:image.png)

→ 무방향 그래프 노드 수 = 간선의 수 * 2

→ 각 정점의 노드 수 = 정점의 차수

- 유향 그래프의 인접 리스트
    
    ![image.png](attachment:0ee2b685-ad3e-4a42-a857-44aa46b3f89f:image.png)
    

→ 방향 그래프 노드 수 = 간선의 수

→ 각 정점의 노드 수 = 정점의 진출 차수

---

### DFS(깊이 우선 탐색; Depth First Search) 알고리즘 - 재귀

- 모든 정점을 중복없이 빠짐없이 방문하는 경우
    - G : 탐색할 그래프
    - v : 방문하는 정점

```python
DFS_Recursive(G, v)
		visited[v] <- True // v 방문 설정
		
		FOR each all w in adjacency(G, v)
				IF visited[w] != True
						DFS_Recursive(G,w)
```

- DFS 알고리즘 - 반복

```python
STACK s    # 스택 생성
visited[]    # 방문한 정점 표시
DFS(v)
		push(s,v)
		WHILE NOT isEmpty(s)
				v <- pop(s)
				IF NOT visited[v]
						visit(v)
						FOR each w in adjacency(v)
								IF NOT visited[w]
										push(s,w)
```

- DFS 예시

![image.png](attachment:2064cc2a-da7f-4e80-99f2-0cc0b4e1c94c:image.png)

```python
STACK s
visited[]
DFS(v)
		push(s,v)
		WHILE NOT isEmpty(s)
				v <- pop(s)
				IF NOT visited[v]
						visit(v)
						FOR each w in adjacency(v)
								IF NOT visited[w]
										push(s,w)
```

- 중복 검사가 필요없는 DFS
    - 스택에 push된 정점을 visited에 표시
        
        ```python
        STACK s
        visited[]
        DFS(v)
        		push(s,v)
        		visited[v] = True
        		WHILE NOT isEmpty(s)
        				v <- pop(s)
        				visit(v)
        				FOR each w in adjacency(v)
        						IF NOT visited[w]
        								push(s,w)
        								visited[v] = True
        ```
        

---

### BFS(너비 우선 탐색; Breadth First Search) 알고리즘

: BFS는 예제 그래프를 붙여진 번호 순서로 탐색함

![image.png](attachment:ea4b063c-88d1-4a47-9faa-11fbff57d22f:image.png)

---

### Union-Find(Disjoint set)_ 서로 소 집합

- 서로 공통 원소가 없는 집합
    
    : 교집합이 없는 집합들
    
- 대표자(representative)
    
    : 각 집합을 대표하는 하나의 원소
    
- 상호 배타 집합
    
    : 확률, 논리, 집합론에서 동시에 일어날 수 없는 경우, 공통이 없는 경우를 말함
    
    : 집합론에서는 서로 소와 같은 뜻으로 사용됨
    
- 표현 방법
    
    : 연결리스트로 표현할 수 있음
    
    : 트리를 이용해 표현할 수 있음
    

**서로 소 집합 연산**

- Make-Set(x)
    
    : x를 원소로 가진 집합을 만듦
    
- Find-Set(x)
    
    : x가 속한 집합의 대표 원소를 반환함
    
- Union(x,y)
    
    : y가 속한 집합과 x가 속한 집합의 합집합을 만듦
    
    : x가 합집합의 대표원소가 됨
    