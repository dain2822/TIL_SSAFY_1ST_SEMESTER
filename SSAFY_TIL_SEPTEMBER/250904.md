## 250904


### [Objectives_ 학습 목표]

- 재귀 호출의 구조와 특성을 이해하고, 이를 활용한 알고리즘을 구현할 수 있음
- 재귀 호출을 이용해 중첩 반복 구조를 구성하고, 완전 탐색 알고리즘을 설계할 수 있음
- 순열, 조합, 부분집합 등 조합적 문제를 재귀 호출로 구현할 수 있음
- 완전 탐색(Brute-force)의 개념을 이해하고, 다양한 조합을 모두 시도하는 문제 해결 전략을 익힘
- 주사위 눈 합, 연속 3장의 트럼프 카드, Baby-Jin 문제를 통해 재귀호출을 이용한 완전 탐색 구현 방법에 대해 학습함

---

### [Build_ 이론]

### 반복과 재귀

- 반복(Iteration)과 재귀(Recursion)는 유사한 작업을 수행할 수 있음
- 반복은 수행하는 작업이 완료될 때까지 계속 반복
    
    → 루프 (for, while 구조)
    
    → 반복문은 코드를 n번 반복시킬 수 있음
    
- 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
    
    → 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합
    
    → 재귀호출은 n중 반복문과 같은 효과
    

예제) 1, 2, 3으로 만들 수 있는 두 자릿수

- 2중 for문을 이용하여 구현

![image.png](attachment:2dca89dc-e722-4697-8b2a-3034b71a6ace:image.png)

```python
for a in range(1,4):
		for b in range(1,4):
				print(a, b)
```

예제) N을 입력 받아 1, 2, 3을 사용하는 N자릿수 만들기

- 만약 N = 2이라면 11 ~ 33까지 출력
- 만약 N = 3이라면 111 ~ 333까지 출력
    
    …
    
- 만약 N = 9라면 111111111 ~ 333333333까지 출력

```python
nums = []
# N = int(input())
N = 3

def nums_func():
		
```

**함수의 특징**

- KFC 함수를 호출할 때 int 타입 객체를 전달하면 값만 복사됨

![image.png](attachment:b19bb05e-51ea-4a91-95c0-ad64fe76f612:image.png)

- main 함수의 x와 KFC 함수의 x는 서로 다른 객체

→ 한국에 사는 KIM과 미국에 사는 KIM이 이름만 같고 서로 다른 사람인 것과 같음

- 출력 결과는 4가 아니라 3

→ Main 함수의 변수 x가 KFC 함수의 변수 x로 값만 복사된 것

```python
def KFC(x):
    print(x)
    x += 1
    print(x)

x = 3
KFC(x+1)
print(x)
```

```python
# 실행 결과

4
5
3
```

- BTS 함수가 끝나면 Main으로 되돌아 오는 것이 아니라 해당 함수를 호출했던 곳으로 돌아옴

![image.png](attachment:cecd4475-3a98-46c7-87a2-754c6b3cd3c9:image.png)

```python
def BBQ(x):
		x += 10
		print(x)
		
def KFC(x):
		print(x)
		x += 3
		BBQ(x + 2)
		print(x)

x = 3
KFC(x + 1)
print(x)
```

```python
# 출력 결과

4
19
7
3
```

**무한 재귀 호출**

```python
# 무한 재귀 호출 -> RecursionError 발생
def KFC(x):
    KFC(x+1)

KFC(0)
print('끝')
```

```python
# 무한 재귀 호출 방지
def KFC(x):
    if x == 2:
        return
    print(x)
    KFC(x + 1)
    print(x)

KFC(0)
print('끝')
```

```python
# 실행 결과

0
1
1
0
끝
```

→ 재귀 함수는 종료 조건을 포함해야 무한 재귀 호출을 막을 수 있음

- 재귀 호출 코드가 1개

![image.png](attachment:81b78518-ebd8-4a36-be20-8f1a124b40d0:image.png)

→ 출력 결과 1 0

- 재귀 호출 코드가 2개

![image.png](attachment:40240f05-1dfa-44d3-b997-07e84392cceb:1a3861fd-3dc2-4280-9438-f598a853a001.png)

![image.png](attachment:c63d5f8a-ea48-4122-b7a8-ab53ae73d5b9:image.png)

→ 출력 결과 1 1 0

![image.png](attachment:e6f25e5f-680c-45d0-ba60-e949d3e9c85d:image.png)

```python
def KFC(x):
		if x == 1:
				return
				
		KFC(x + 1)
		KFC(x + 1)
		print(x)
		
KFC(0)
```

- 재귀 호출 코드가 3개

![image.png](attachment:06490310-655a-4d3f-b0bf-b9cd65a0569f:image.png)

```python
def KFC(x):
		if x == 1:
				return
				
		KFC(x + 1)
		KFC(x + 1)
		KFC(x + 1)
		print(x)
		
KFC(0)
```

---

### 순열

: 서로 다른 N개에서 R개를 중복 없이 순서를 고려하여 나열하는 것

ex) [0], [1], [2]로 구성된 3장의 카드가 다량으로 존재

→ 이 중에 2장을 뽑아 순열을 나열함(순열은 중복을 취급하지 않음)

![image.png](attachment:289d1f26-c263-4bb3-af6d-d8ff52a804b0:image.png)

**중복 순열**

: 서로 다른 N개에서 R개를 중복을 허용하고 순서를 고려하여 나열하는 것

ex) [0], [1], [2]로 구성된 3장의 카드가 다량으로 존재

→ 이 중에 2장을 뽑아 중복순열을 나열함

![image.png](attachment:6cc2c3a7-5ea7-4013-a999-16faa818ef42:image.png)

**중복 순열 구현 원리**

1. 재귀호출을 할 때마다 이동 경로를 흔적으로 남김
    
    ![image.png](attachment:45352955-d096-4a72-8bb7-b2e9258c3065:image.png)
    
2. 가장 마지막 레벨에 도착했을 때 이동 경로를 출력
    
    ![image.png](attachment:13ff4979-c90e-4e65-a65c-8a9d81d61338:image.png)
    

```python
# 중복 순열
# [0, 1, 2] 3장의 카드 존재 -> 2장을 뽑음

path = []   # 뽑은 카드들 저장

# 기저조건(종료조건) : 2개의 카드를 모두 뽑으면 종료
#   -> 시작점 : 0개의 카드를 고른 상태
# 다음 재귀호출 구조 : [0, 1, 2] 카드 중 하나를 고름
def recur(cnt):
    if cnt == 2:
        print(*path)
        return

    # 카드 0,1,2 중에 하나를 선택
    for i in range(3):
        path.append(i)
        recur(cnt + 1)
        path.pop()

recur(0)
```

```python
# 실행 결과
0 0
0 1
0 2
1 0
1 1
1 2
2 0
2 1
2 2
```

**중복을 취급하지 않는 순열 구현 방법**

1. 중복 순열 코드 작성
2. 중복을 제거하는 코드를 추가

- 중복을 제거하는 원리
    - 전역 리스트를 사용했으므로 이미 선택했던 숫자인지 아닌지 구분
        
        → 이를 used 배열 또는 visited 배열이라고 부름(DFS, BFS에 사용되는 것과 같음)
        

---

### 완전 탐색_Brute Force

: 모든 가능한 경우를 모두 시도해서 정답을 찾아내는 알고리즘

예시)

1. 자전거 열쇠 비밀번호 맞추기
    - 1111 ~ 9999 네자리 숫자를 맞춰야하면
        
        → 4중 for문으로 모두 시도
        
2. 1 ~ 9까지 이루어진 N자리의 숫자를 맞춰야하면
    
    → 순열 코드(재귀 호출)로 구현하여 모두 시도
    

1. 주사위 눈의 합

- 3개의 주사위를 던져 나올 수 있는 중복 순열에 대해, 합이 10 이하가 나오는 경우는 총 몇 가지인가?

```python
def dice_ver2(cnt, total):
    global result

    # 이미 10을 넘은 경우 더 볼 필요가 없음
    if total > 10:
        return

    if cnt == 3:
        if total <= 10:
            result += 1

        # result += 1   # 위 아래 둘 다 가능
        return

    for num in range(1,7):
        dice_ver2(cnt + 1, total + num)

result = 0
dice_ver2(0,0)
print(result)
```

1. 연속 3장의 트럼프 카드
- A, J, Q, K 4종류의 카드들이 충분히 있을 때 5장을 뽑아 나열하고, 이때 같은 종류의 카드가 3장 연속으로 나오는 경우의 수는?

```python
# [A, J, Q, K]의 카드가 충분히 있음
# 카드 5장을 뽑았을 때 같은 종류의 3장 카드가 연속으로 나오는 경우의 수

cards = ['A', 'J', 'Q', 'K']
path = []
result = 0

# 같은 종류 연속 3장이 나오면 return True 아니면 return False
def count_three():
    if path[0] == path[1] == path[2]: return True
    if path[1] == path[2] == path[3]: return True
    if path[2] == path[3] == path[4]: return True

    return False

def recur(cnt):
    global result

    if cnt == 5:
        if count_three():
            # todo: 같은 종류 연속 3개가 나오면 counting
            result += 1
        return

    # 카드들 중 하나를 선택
    for idx in range(len(cards)):
        path.append(cards[idx])
        recur(cnt + 1)
        path.pop()

recur(0)
print(result)
```