## 250902

### [Objectives_ 학습 목표]

- SW 문제해결 역량이란 무엇인가를 이해하고 역량을 강화하는 방법을 이해함
- 효율적인 알고리즘의 필요성과 성능 측정 방법 중 하나인 시간복잡도에 대해 이해함
- 비트 수준의 연산과 자주 활용되는 표현에 대해 학습함
- 다양한 진법들과 이들 사이에 변환 방법을 이해함
- 컴퓨터에서 실수 자료형의 표현과 특징을 이해함

---

### [Build_ 이론]

### SW 문제 해결

**SW 문제 해결 역량이란?**

- 프로그램을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력
- 추상적인 기술임
    - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없음
    - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않음

→ 문제 해결 역량을 향상시키기 위해서 훈련이 필요함

**문제해결 과정**

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할 지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

**리스트에 숫자 넣기**

- 수 N을 입력 받는다.
- 윗줄에는 N부터 1씩 증가되는 숫자 4개를 왼쪽에 채운다.
- 아랫줄에는 N부터 1씩 감소되는 숫자 4개를 오른쪽에 채운다.
- 최종 결과를 출력한다. 빈 공간은 0으로 출력한다.

![image.png](attachment:526f1e3e-7e8b-4a3d-a98f-19826f2b9f0b:image.png)

```python
N = 5
num_list = [[0] * 7 for i in range(2)]
i = 0

while i < 4:
		num_list[0][i] = N+i
		num_list[1][-i-1] = N-i
		i += 1
		
print(num_list)
```

**설계 예시**

- 2 * 7 크기의 0으로 채운 리스트를 준비함
- 수 N을 입력 받음
- t1 = N 대입 후, for문을 4번 돌려 t1 값을 리스트에 넣음(range(0 , 4))
- t2 = N 대입 후, for문을 4번 돌려 t2 값을 리스트에 넣음(range(6 , 2 , -1))
- 리스트를 출력

![image.png](attachment:23bf3e7d-d189-43b6-9bc8-fd718626df85:image.png)

```python
N = 5
num_list = [[0] * 7 for i in range(2)]

for i in range(0, 4):
		num_list[0][i] = N+i
for j in range(6, 2, -1):
		num_list[1][j] = N-6+j
		
print(num_list)
```

**SW 문제해결 능력을 기르는 이유**

- 코딩을 더 잘하게 하는 능력을 기르기 위함
- SWEA 문제를 통해 기본 문법 & 자료 구조 & 알고리즘을 더 능숙하게 쓸 수 있도록 훈련함

**SWEA 문제를 잘 풀기 위한 전략**

- 단계 1 : 완벽한 문제 이해
- 단계 2 : 종이와 펜을 이용한 설계하기(어떻게 구현할 지 계획)
- 단계 3 : 설계한 대로 구현 & 디버깅

---

### 복잡도 분석

**알고리즘이란?**

- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
    - 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
    
    → 어떤 문제를 해결하기 위한 절차
    

ex) 1부터 100까지의 합을 구하는 두 가지 알고리즘

![image.png](attachment:a3fa773b-25b9-4d74-b781-b6f450950919:image.png)

**알고리즘의 효율**

- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 알고리즘이 필요로 하는 메모리 공간을 말함
    - 시간적 효율성은 알고리즘이 작업을 완료하는데 걸리는 시간을 말함
        
        → 시간적 효율성은 주로 입력 크기 n에 대한 연산 횟수로 나타냄
        
    - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 됨
        
        → 복잡도가 높을 수록 효율성은 저하됨
        

**복잡도의 점근적 표기**

- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기
    - 주로 여러 개의 항을 가지는 다항식
    - 단순한 함수로 표현하기 위해 점근적 표기(Asymptotic Notation)를 사용함
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
    - O(Big-Oh)-표기
    - Ω(Big-Omega)-표기
    - Θ(Big-Theta)-표기

**O(Big-Oh)-표기**

- O-표기는 복잡도의 점근적 상한을 나타냄
- 복잡도가 f$(n) = 2n^2-7n+4$이라면, f(n)의 O-표기는 $O(n^2)$
- 먼저 f(n)의 단순화된 표현은 n$^2$
- 단순화된 함수 $n^2$에 임의의 상수 c를 곱한 $cn^2$이 n이 증가함에 따라 $f(n)$의 상한이 됨(단, $c > 0$)

- $O(n)$
    
    ```python
    n = int(input())
    
    for i in range(n):
    		print(i, end = '')
    
    for i in range(n):
    		print(i, end = '')
    
    for i in range(n):
    		print(i, end = '')
    ```
    
- $O(n^2)$
    
    ```python
    n = int(input())
    
    for i in range(n):
    		for x in range(n):
    				print(i, end = '')
    		
    		for y in range(n):
    				print(i, end = '')
    ```
    
- $O(1)$
    
    ```python
    n = int(input())
    
    for i in range(50):
    		print(i)
    ```
    

→ $O(5N)$

→ 정확한 배수를 강조하고 싶다면 O(N)대신 표현 가능함

- 자주 사용하는 O-표기
    - $O(1)$ : 상수 시간(Constant time)
    - $O(logn)$ : 로그(대수) 시간(Logarithmic time)
    - $O(n)$ : 선형 시간(Linear time)
    - $O(nlogn)$ : 로그 선형 시간(Log-linear time)
    - $O(n^2)$ : 제곱 시간(Quadratic time)
    - $O(n^3)$ : 세제곱 시간(Cubic time)