## 250903

### [Objectives_ 학습 목표]

- 비트 수준의 연산과 자주 활용되는 표현에 대해 학습함
- 다양한 진법들과 이들 사이에 변환 방법을 이해함
- 컴퓨터에서 실수 자료형의 표현과 특징을 이해함

---

### [Build_ 이론]

### 비트 연산

![image.png](attachment:242423a1-74c3-437e-9749-3ff62df82779:image.png)

: 컴퓨터의 CPU 내부적으로 비트 연산을 사용하여 덧셈, 뺄셈, 곱셈 등을 계산함

**비트와 바이트**

- 1 bit : 0과 1을 표현하는 정보의 단위
- 1 Byte : 8-bit를 묶어 1 Byte라고 함(메모리 주소가 부여되는 단위)
    
    ex) 1001011011011100은 총 몇 비트이고, 몇 바이트인가?
    
    → 16비트 / 2바이트
    

**AND와 OR 비트 연산자**

- a AND b : a, b 둘 다 1일 때만 결과가 1, 그 외에는 0
- a OR b : a, b 둘 중 하나만 1이면 결과가 1, 그 외에는 0

![image.png](attachment:a2956e4e-47a9-4217-bcf7-110f0c9d2574:image.png)

ex) 7 & 5 → 이진수로 표현하면 0b111 & 0b101 / 7 | 5 → 이진수로 표현하면 0b111 | 0b101

![image.png](attachment:8c4346d0-ae86-4fa0-985d-77769850c197:image.png)

```python
print(7 & 5)
print(7 | 5)
```

- 파이썬에서 2진수, 16진수, 10진수 변환하여 출력하기
    - 2진수는 숫자 0과 소문자 b → 0b를 접두사로 붙여 표현
    - 16진수는 숫자 0과 소문자 x → 0x를 접두사로 붙여 표현
    
    ![image.png](attachment:bef4198f-801c-4d10-9514-d20a6a4842c5:image.png)
    

**XOR와 NOT 연산자**

- ^ : XOR(엑스오어) 연산자, 둘 다 1이거나 0인 경우는 0
    
    ex) num1 ^ num2
    
    ![image.png](attachment:7e4abc1d-5a77-4c39-b708-0a2e12114ed8:image.png)
    
- 특정 수로 2회 XOR를 하면 원래 수로 돌아옴
    
    ex) 7070 ^ 1004 = 6258
    
    → 6258 ^ 1004 = 7070
    
- XOR는 암호화에 사용됨
    
    ![image.png](attachment:9cb3afb0-6863-40c5-84f5-1fd584491a59:image.png)
    

**비트 연산자**

- Left Shift << : 특정 수 만큼 비트를 왼쪽으로 밀어냄
- Right Shift >> : 특정 수 만큼 비트를 오른쪽으로 밀어냄(우측 비트들이 제거됨)

![image.png](attachment:3d1c8bec-d559-479e-b871-690022e2b384:image.png)

![image.png](attachment:64ad4204-7e64-4da9-84d9-d0fa38b49a82:image.png)

**비트 연산 응용**

1. 1 << n
    1. $2^n$의 값을 가짐
    2. 임베디드 분야에서 계산을 빠르게 하기 위해 사용됨
2. i & (1 << n)
    1. i의 n번째 비트가 1인지 아닌지를 확인할 수 있음
        
        ex) 1101 & (1 << 2)
        
        1101에서 2번 bit가 1인지 확인 가능함(결과값 = 0100)
        
        결과값이 0보다 크면 n번째 비트는 1임이 확정됨
        

**음수 표현 방법**

- 컴퓨터는 음수를 “2의 보수”로 관리함
    
    → 맨 앞자리 bit(MSB)는 음수 또는 양수를 구분하는 비트
    
- 컴퓨터가 2의 보수를 사용하여 음수를 관리하는 이유
    
    : 뺄셈의 연산 속도를 올릴 수 있으며, +0과 -0을 따로 취급하지 않기 위해 사용함
    

![image.png](attachment:93e9dadb-7983-4de2-b2e2-5825835a6e3b:image.png)

```python
def bit_print(i):
		output = ''
		for j in range(7, -1, 1):
				output += '1' if i & (1 << j) else '0'
		print(output)

for i in range(-5, 6):
		print(f'{i} =', end = '')
		bit_print(i)
```

**2의 보수 예시**

- 10001의 2의 보수
    - 수를 모두 뒤집고 +1을 함
        
        → 01110 + 1 = 01111
        
- 1111000의 2의 보수
    
    → 0000111 + 1 = 0001000
    

: 2의 보수를 취한 수를 한 번 더 2의 보수를 취하면 원래의 값으로 돌아옴

ex) 10001의 2의 보수

→ 01110 + 1 = 01111

01111의 2의 보수

→ 10000 + 1 = 10001

**-5를 2의 보수로 표현하는 방법(가정 : 수를 8-bit로 저장하는 경우)**

- 수 5를 2진수로 나타내면 0000 0101(7-bit)
- -5는 음수이기에 MSB는 1
- 나머지 7-bit에 대해 수를 뒤집고 1을 더함(2의 보수)
- 수 5를 뒤집으면 111 1010이며, 1을 더하면 111 1011이 됨

⇒ 따라서 1111 1011이 됨

**bitwise NOT(complement) 연산자**

- ~ 연산자 : 모든 비트를 반전시킴
- 만약 8-bit일 때 ~(0001 1111)이라면 값은 1110 0000이 됨

ex) 파이썬에서 ~4를 수행하면 -5가 출력됨

→ 4 = 0b0100 (MSB : 양수이므로 0)

→ NOT 연산자로 인해 뒤집으면 1011이 됨

→ MSB는 1이 되었고(음수), 나머지 bit는 011

→ 나머지 bit에 대해 2의 보수를 취하면 100 + 1 = 101이므로 5가 됨

⇒ 따라서 -5가 됨

---

### 실수

**파이썬에서 실수 출력 방법**

: 파이썬은 f-string 문법 지향

```python
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다.')
print(f'변수 값은 {t2} 입니다.')
```

![image.png](attachment:417de547-d1a9-4597-9518-5b2a4b999f9d:image.png)

**소수점 출력 방법**

: {t2:.2f} → t2값을 소수점 셋째 자리에서 반올림하여 표현

```python
t1 = 10
t2 = 3.141592

print(f'변수 값은 {t1} 입니다.')
print(f'변수 값은 {t2:.2f} 입니다.')
```

![image.png](attachment:9adfb554-84ee-4dbe-911d-97e9cdb95d9c:image.png)

**파이썬에서의 실수 표현 범위**

- 파이썬에서는 64비트 부동소수점으로 실수를 표현함
- 15~17자리 정밀도와 +- 1.8e308 범위를 가짐
- 최대로 표현할 수 있는 값은 약 1.8 * 10^308이고 이 이상은 inf로 표현(1억은 1*10^8)
- 최소로 표현할 수 있는(0에 가장 가까운) 값은 약 5.0*10^-324이며, 이 이하는 0으로 표현

**컴퓨터는 실수를 내부적으로 근사적으로 관리**

→ 실수는 정확한 값이 아니라 근사값으로 저장되는데 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴

![image.png](attachment:edfaeff5-f3fc-4979-9932-3d6a1f425c0d:image.png)

**소수점이 있는 10진수를 2진수로 변환 예시**

- 0.75 = 2^-1 + 2^-2
    
    ⇒ 0.11(2)
    
- 0.40625 = 2^-2 + 2^-3 + 2^-5
    
    ⇒ 0.01101
    

![image.png](attachment:af32cb07-8519-4958-bc04-0bc66a70abc8:image.png)

**소수점을 포함한 2진 실수를 10진수로 변환하는 예시**

- 1001.0011
    
    ![image.png](attachment:cc2984ba-9d02-4062-adfb-f98ec2e0eee0:image.png)
    
    ⇒ 총 합이 10진수로 **9.1875**
    

**실수의 표현**

- 컴퓨터는 실수를 표현하기 위해 부동 소수점(floating-point) 표기법을 사용
    
    → IEEE 754라는 컴퓨터에서 부동소수점을 표기하는 국제 표준
    
- 부동 소수점 표기 방법은 소수점의 위치를 고정시켜 표현하는 방식임
- 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑 수의 지수승으로 표현

![image.png](attachment:6fdbbf8e-dc19-447e-ac91-b973351dfcc6:image.png)

**실수를 저장하기 위한 형식(IEEE 754, 32bits - Single Precision 표기법 기준)**

- 32-bit 구조

![image.png](attachment:7539f0a0-e666-43ae-9edd-9baaa5f45ed6:image.png)

- 부호 1비트 : 0이면 양수, 1이면 음수
- 지수부(exponent) : 부동소수점의 크기 + bias 값
- 가수부(mantissa) : 실질적 수

- 12.375를 부동소수점으로 표기
    - 12.375를 2진수로 변환 : 12는 1100, 0.375는 0.011이므로 1100.011
    - 1100.011 = 1.100011 * 2^3
        
        → 즉, 가수는 100011이고, 지수는 3.(맨앞 1은 생략)
        
- 지수 + bias : IEEE 754는 bias를 더한 결과로 표기
    - 3 + 127(bias) = 130 (2진수로는 10000010)
- 12.375를 IEEE 754로 표기하는 방법
    - 부호 비트 : 0 (양수)
    - 지수 : 10000010
    - 가수 : 10001100000000000000000

**실수 자료형의 유효 자릿수**

- 32비트 실수형 유효 자릿수(10진수) → 약 6자리(C/C++, Java)
- 64비트 실수형 유효 자릿수(10진수) → 약 15자리(C/C++, Java, Python)