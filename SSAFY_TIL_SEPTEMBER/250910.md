## 250910

### [Objectives_ 학습 목표]

- 문제를 분할해서 해결하는 분할 정복 기법을 이해
- 분할 정복 기법을 적용된 대표적인 정렬 알고리즘인 퀵 정렬과 병합 정렬에 대해 학습함
- 정렬된 자료들을 분할해서 탐색하는 이진 검색에 대해 학습함

---

### [Build_ 이론]

### 분할 정복

: 문제를 작은 하위 문제로 나누고(분할) 각각을 해결(정복)한 뒤, 그 결과를 결합(통합)하여 원래 문제를 해결하는 알고리즘 기법

**분할 정복 기법의 설계 전략**

- 분할(Divide) : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복(Conquer) : 나눈 작은 문제를 각각 해결
- 통합(Combine) : (필요하다면) 해결된 해답을 모음

![분할 정복 기법의 구조_ Top-Down Approach 예시](attachment:92addcca-494f-4730-8519-513dfffe5262:image.png)

분할 정복 기법의 구조_ Top-Down Approach 예시

**분할 정복 기법의 예시 - 거듭 제곱**

- 반복(Iterative) 알고리즘 : $O(n)$
    
    $C^2 = C * C$
    
    $C^3 = C * C * C$
    
    $…$
    
    $C^n = C * C * C * …  * C$
    

```python
Iterative_Power(x, n)
		result <- 1
		
		FOR i in 1 -> n
				result <- result * x
		
		RETURN result
```

- 분할 정복 기반의 알고리즘 : $O(log2 n)$
    
    $C^8 = C * C * C * C * C * C * C * C$
    
    $C^8 = C^4 * C^4 = (C^4)^2 = ((C^2)^2)^2$
    
    …
    
    $C^n$ = $C^{\frac{n-1}{2}}$ $*$ $C^{\frac{n-1}{2}}$   = $(C^{\frac{n-1}{2}})^2$ $* C$
    

```python

```

### 병합 정렬_ Merge Sort

: 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식

→ 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄

→ Top-Down 방식

→ 시간 복잡도 : $O(n log n)$

**병합 정렬 과정 예시_ [69, 10, 30, 2, 16, 8, 31, 22]**

- 분할 단계 : 전체 자료 집합에 대해, 최소 크기의 부분 집합이 될 때까지 분할 작업을 계속함
    
    ![image.png](attachment:595c5850-8a2b-47df-8b40-80dcc57fc46f:image.png)
    
- 병합 단계 : 2개의 부분 집합을 정렬하면서 하나의 집합으로 병합. 8개의 부분 집합이 1개로 병합될 때까지 반복함
    
    ![image.png](attachment:a11255ba-5df4-4882-8f4a-ae507a455e1e:image.png)
    

```python
# 분할 과정
merge_sort(LIST m)
		IF length(m) == 1: RETURN m
		
		LIST left, right
		middle <- length(m) / 2
		FOR x in m before middle
				add x to left
		FOR x in m after or equal middle
				add x to right
				
		left <- merge_sort(left)
		right <- merge_sort(right)
		
		RETURN merge(left, right)
		
# 병합 과정
merge(LIST left, LIST right)
		LIST result
		
		WHILE length(left) > 0 OR length(right) > 0
				IF length(left) > 0 AND length(right) > 0
						IF first(left) <= first(right)
								append popfirst(left) to result
						ELSE
								append popfirst(right) to result
				ELIF length(left) > 0
						append popfirst(left) to result
				ELIF length(right) > 0
						append popfirst(right) to result
		RETURN result
```

### 퀵 정렬_ Quick Sort

: 기준값을 중심으로 주어진 배열을 두 개로 분할하고, 각각을 정렬하여 전체 배열을 정렬하는 방식

→ 평균 시간 복잡도 : $O(n log n)$

→ Partitioning이라는 과정을 반복하면서, 빠른 속도로 정렬이 되는 알고리즘

**병합 정렬과 퀵 정렬의 차이**

![image.png](attachment:cd238aea-a248-4ca0-8444-52394c76ebdf:image.png)

**Partitioning**

1. 작업 영역을 정함
    
    ![image.png](attachment:24f5f4a3-6781-42a4-bf04-547d6ad76dc6:image.png)
    

1. 작업 영역 중 가장 왼쪽에 있는 수를 Pivot이라고 함(Pivot을 기준으로 해석)
    
    ![image.png](attachment:4fec0d7f-594a-44f6-af83-ad70eacdd96d:image.png)
    

1. Pivot을 기준으로
    1. 왼쪽에는 Pivot보다 작은 수를 배치(정렬 안 됨)
    2. 오른쪽에는 Pivot보다 큰 수를 배치(정렬 안 됨)
        
        ![image.png](attachment:57ed740b-8742-4b00-8bfb-35a5a28af84e:image.png)
        

→ Partitioning이 끝나고 Pivot의 위치는 확정(Fix)됨

![image.png](attachment:f6acb913-97fc-4957-a9cb-f92208a722b8:image.png)

⇒ 한 번의 Partitioning 이후, 왼쪽과 오른쪽 부분 배열에 대해 재귀적으로 Partitioning을 반복하여 정렬 진행

![image.png](attachment:cb462e7f-83a0-4590-b500-74aec599eae8:image.png)

![image.png](attachment:3cfeba2a-4ce3-4d82-b086-dee0c5983f17:image.png)

![image.png](attachment:72a5ab3a-9829-4155-a346-5a51b3d2989c:image.png)

![image.png](attachment:d9ae44cc-858b-4011-808f-31fe725ea655:image.png)

$…$

![image.png](attachment:2fe9e70e-2b93-4a60-8d07-8f190ad95a80:image.png)

![image.png](attachment:b3ac9222-9273-4ac2-8fc2-187ffa50dbca:image.png)

![image.png](attachment:dfec9138-77d2-4c20-be28-cfe5773b709a:image.png)

![image.png](attachment:da8ba115-b7a2-4a16-993e-ccb966179d34:image.png)

![image.png](attachment:da096d39-37ac-4b91-ab16-a4ce28f419c8:image.png)

![image.png](attachment:26521197-b396-4000-afa4-1d2163cd6f92:image.png)

![image.png](attachment:a500872d-b7a5-47e7-898b-3960f4f74d50:image.png)

```python
quickSort(A[], l, r)
		if l < r
				s <- partition(A[], l, r)
				quickSort(A[], l, s-1)
				quickSort(A[], s+1, r)
```

**Hoare-Partition**

```python
partition(A[], l, r)
		p <- A[l]    # p : 피봇 값
		i <- l, j <- r
		WHILE i <= j
				WHILE i <= j and A[i] <= p : i++
				WHILE i >= j and A[i] >= p : i--
				IF i < j : swap(A[i], A[j])
		
		swap(A[l], A[j])
		RETURN j
```

![image.png](attachment:edf03548-8fc3-474c-b010-9a58c23a304c:image.png)

- 왼쪽 끝 / 오른쪽 끝 / 가운데 세 값 중에 중간 값을 선택하는 경우

![image.png](attachment:bbb58837-8895-42b8-9c59-beb0530b529e:image.png)

![image.png](attachment:d1611467-068d-43b3-8d54-5c22883a134a:image.png)

![image.png](attachment:9d0e578d-de0c-4bff-a48f-758e8306ebd3:image.png)

![image.png](attachment:c8a372f1-f2ae-40f8-bae3-96a90fe50482:image.png)

![image.png](attachment:6aa20d29-d53e-4822-8819-f2bb497e5d69:image.png)

![image.png](attachment:6fdd80bd-ec1f-45e4-9bb1-ce558ed697a2:image.png)

![image.png](attachment:2031794f-aaf6-4d49-a2cb-d2e6636e0d36:image.png)

**Lomuto Partition**

```python
partition(A[], p, r)
		x <- A[r]
		i <- p - 1
		
		FOR j in p -> r - 1
				IF A[j] <= x
						i++
						swap(A[i], A[j])
						
		swap(A[i+1], A[r])
		RETURN i + 1
```

![image.png](attachment:5150af7d-10c1-40ab-b213-1e1e4b6bc5f7:image.png)

### 이진 검색_ Binary Search

: 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

→ 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함

**이진 검색의 과정**

1. 자료의 중앙에 있는 원소를 고름
2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교
3. 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해 새로 검색을 수행함
4. 찾고자 하는 값을 찾을 때까지 1~3의 과정 반복

→ 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 함

- 이진 검색으로 7을 찾는 경우

![image.png](attachment:2148bb65-d357-43b7-abe3-19a9ae5ef307:image.png)

1. 7 < 9

⇒ 왼쪽 검색

1. 7 > 4

⇒ 오른쪽 검색

1. 7 = 7

⇒ 검색 성공!

- 이진 검색으로 20을 찾는 경우

![image.png](attachment:11821d0f-14e5-4810-bb29-9e848d9ef277:image.png)

1. 20 > 9

⇒ 오른쪽 검색

1. 20 > 19

⇒ 오른쪽 검색

1. 20 ≠ 23

⇒ 검색 실패!

**이진 검색 알고리즘**

- 반복 구조

```python
binary_search(n, S[], key):
		low <- 0
		high <- n-1
		
		WHILE low <= high
				mid <- (low+high)/2
				
				IF S[mid] == key
						RETURN mid
				ELIF S[mid] > key
						high <- mid-1
				ELSE
						low <- mid+1
						
		RETURN -1
```

- 재귀 구조

```python
binary_search(a[], low, high, key):
		IF low > high
				RETURN -1
		ELSE
				mid <- (low+high)/2
				IF key == a[mid]
						RETURN mid
				ELIF key < a[mid]
						RETURN binary_search(a[], low, mid-1, key)
				ELSE
						RETURN binary_search(a[], mid+1, high, key)
```
